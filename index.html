<html>


<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>李振杰</title>
  <meta name="author" content="LeeZhenjie">

  
  <meta name="description" content="可能大家对- (id)valueForKeyPath:(NSString *)keyPath方法不是很了解。
其实这个方法非常的强大，具体有以下几个功能: 对数组中的每个元素执行成员实例方法 1
2
NSArray *array = @[@"name", @"w", @"aa", @"jimsa &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://swplzj.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="李振杰" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- // <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> &#8211;>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  <!-- 
 -->
</head>

<body    class="collapse-sidebar sidebar-footer" >
  <nav id="main-nav" role="navigation">
<ul class="main-navigation">
  <li><a href="/" class="nav-link">首页 | Blog</a></li>
  <li><a href="/blog/archives" class="nav-link">归档 | Archives</a></li>
  <li><a href="/atom.xml" class="nav-link">订阅 | RSS</a></li>
  <li><a href="/about" class="nav-link">关于我 | About</a></li>
</ul>

</nav>
  <header role="banner"><hgroup>
	
		<img src="/images/portrait.jpg" class="portrait" height=250px width=250px />
	
  <h1><a href="/">李振杰</a></h1>
  
    <h2>An iOS developer‘s blog about programming and growing.</h2>
  
</hgroup>

</header> 
  
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/16/valueforkeypathde-shi-yong-zong-jie/">valueForKeyPath的使用总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-16T21:10:46+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>可能大家对- (id)valueForKeyPath:(NSString *)keyPath方法不是很了解。
其实这个方法非常的强大，具体有以下几个功能:</p>

<h5>对数组中的每个元素执行成员实例方法</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@"name", @"w", @"aa", @"jimsa"];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"uppercaseString"]);</span></code></pre></td></tr></table></div></figure>


<p>输出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>    NAME,
</span><span class='line'>    W,
</span><span class='line'>    AA,
</span><span class='line'>    JIMSA
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>相当于数组中的每个成员执行了uppercaseString方法，然后把返回的对象组成一个新数组返回。既然可以用uppercaseString方法，那么NSString的其他方法也可以，比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[array valueForKeyPath:@"length"]</span></code></pre></td></tr></table></div></figure>


<p>返回每个字符串长度的组成的数组。只要你能想到的成员实例方法都可以这么用。</p>

<h5>对NSNumber数组快速计算数组求和、平均数、最大值、最小值</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@1, @2, @3, @4, @10];
</span><span class='line'>NSNumber *sum = [array valueForKeyPath:@"@sum.self"];
</span><span class='line'>NSNumber *avg = [array valueForKeyPath:@"@avg.self"];
</span><span class='line'>NSNumber *max = [array valueForKeyPath:@"@max.self"];
</span><span class='line'>NSNumber *min = [array valueForKeyPath:@"@min.self"];</span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>或者指定输出类型</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSNumber *sum = [array valueForKeyPath:@"@sum.floatValue"];
</span><span class='line'>NSNumber *avg = [array valueForKeyPath:@"@avg.floatValue"];
</span><span class='line'>NSNumber *max = [array valueForKeyPath:@"@max.floatValue"];
</span><span class='line'>NSNumber *min = [array valueForKeyPath:@"@min.floatValue"];</span></code></pre></td></tr></table></div></figure>


<h5>剔除重复数据</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@"name", @"w", @"aa", @"jimsa", @"aa"];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"@distinctUnionOfObjects.self"]);</span></code></pre></td></tr></table></div></figure>


<p>打印</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>name,
</span><span class='line'>w,
</span><span class='line'>jimsa,
</span><span class='line'>aa
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<h5>对NSDictionary数组快速找出相应key对的值</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array = @[@{@"name" : @"cookeee",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @2},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jbos",@"code" : @1}];
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"name"]);</span></code></pre></td></tr></table></div></figure>


<p>直接得到字典中namekey对应的值组成的数组，显然比循环取值再加入到新数组中方便快捷</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>    cookeee,
</span><span class='line'>    jim,
</span><span class='line'>    jim,
</span><span class='line'>    jbos
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>同样可以嵌套使用，先剔除name对应值的重复数据再取值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSArray *array = @[@{@"name" : @"cookeee",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @2},
</span><span class='line'>                           @{@"name": @"jim",@"code" : @1},
</span><span class='line'>                           @{@"name": @"jbos",@"code" : @1}];
</span><span class='line'>
</span><span class='line'>NSLog(@"%@", [array valueForKeyPath:@"@distinctUnionOfObjects.name"]);</span></code></pre></td></tr></table></div></figure>


<p>打印</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(
</span><span class='line'>cookeee,
</span><span class='line'>jim,
</span><span class='line'>jbos
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<h5>改变UITextfiedl的placeholder的颜色</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[searchField setValue:[UIColor whiteColor] forKeyPath:@"_placeholderLabel.textColor"];</span></code></pre></td></tr></table></div></figure>


<p>比起重写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)drawPlaceholderInRect:(CGRect)rect;</span></code></pre></td></tr></table></div></figure>


<p>要方便很多</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/07/objective-czhong-de-selectorhe-sel/">Objective-C中的Selector和SEL</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-07T10:32:05+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>Objective-C中Selector基本概念和操作</h4>

<p>简而言之，你可以理解 @selector()就是取类方法的编号,他的行为基本可以等同C语言的中函数指针,只不过C语言中，可以把函数名直接赋给一个函数指针，而Objective-C的类不能直接应用函数指针，这样只能做一个@selector语法来取.</p>

<p>它的结果是一个SEL类型。这个类型本质是类方法的编号(函数地址)?因此我们有如下代码。</p>

<h5>一、取得selector值.</h5>

<p>C函数指针</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int add(int val)  
</span><span class='line'>{  
</span><span class='line'>  return val+1;  
</span><span class='line'>}  
</span><span class='line'>int (* c_func)(int val); //定义一个函数指针变量  
</span><span class='line'>_func = add ;  //把函数addr地址直接赋给c_func </span></code></pre></td></tr></table></div></figure>


<p>Objective-C的选择器,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface foo  
</span><span class='line'>-(int)add:int val;  
</span><span class='line'>@end  
</span><span class='line'> 
</span><span class='line'>SEL class_func ; //定义一个类方法指针  
</span><span class='line'>class_func = @selector(add:int); </span></code></pre></td></tr></table></div></figure>


<p><code>注意:</code></p>

<ol>
<li>@selector是查找当前类的方法，而[object @selector(方法名:方法参数..) ] ;是取object对应类的相庆方法;</li>
<li>查找类方法时，除了方法名,方法参数也查询条件之一.</li>
<li>可以用字符串来找方法 SEL　变量名　=　NSSelectorFromString(方法名字的字符串);</li>
<li>可以运行中用SEL变量反向查出方法名字字符串</li>
</ol>


<p>NSString　*变量名　=　NSStringFromSelector(SEL参数);</p>

<h5>二、执行selector值.</h5>

<p>取得相庆值后，怎么处理SEL值呢，这一点仍然与函数指针一样，就是执行它</p>

<p>函数指针执行，（以下有几种等效形式）</p>

<ul>
<li>*c_func(10);</li>
<li>c_func(10);</li>
<li>SEL变量的执行.用performSelecor方法来执行.</li>
<li>[对象　performSelector:SEL变量　withObject:参数1　withObject:参数2];</li>
</ul>


<h5>三.selector的应用场合</h5>

<p>selector本质是跟C的回调函数一样。主要用于两个对象之间进行松耦合的通讯.这种方法很多开发环境用到。比如GTK，Delphi.基本上整个Cocoa库之间对象，控制之间通讯都是在这个基础构建的。</p>

<h4>SEL</h4>

<p>在Objective-C中，SEL是选择器（selector）的一个类型。选择器就是指向方法的一个指针，读者可以简单理解为程序运行到这里就会执行指定的方法，可以这样定义一个选择器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL action = [button action]; </span></code></pre></td></tr></table></div></figure>


<p>我们这样使用一个选择器，下面的选择器都叫做action：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[Foo action]  
</span><span class='line'>[Bar action] </span></code></pre></td></tr></table></div></figure>


<p>在Target-Action 模式（Cocoa 程序中的一种常用模式）中：Target 指定了一个类，Action指定一个方法。在一个对象上设置Action就是通过选择器完成的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-（void）setTarget:（id）target;  
</span><span class='line'>-（void）setAction:（SEL）action; </span></code></pre></td></tr></table></div></figure>


<p>下述语句设置了一个button对象上的Action为“@selector（start:）”，即它调用start方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[button setAction:@selector（start:）]; </span></code></pre></td></tr></table></div></figure>


<p>如果你的方法上有两个参数，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-（void）setName:（NSString *）name age:（int）age; </span></code></pre></td></tr></table></div></figure>


<p>那么，你的选择器应该这样书写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector（setName:age:）; </span></code></pre></td></tr></table></div></figure>


<p>如果方法不存在的话，调用该方法的应用可能会异常中止。所以，需要使用respondsToSelector 方法来判断该对象是否存在对应的方法，使用performSelector:withObject:方法来调用选择器：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector (start:) ; // 指定action  
</span><span class='line'>if ([obj respondsToSelector:sel]) { //判断该对象是否有相应的方法  
</span><span class='line'>[obj performSelector:sel withObject:self]; //调用选择器方法  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>下面来看一个应用选择器的实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>@interface ClassA : NSObject {  
</span><span class='line'>}  
</span><span class='line'>- (void) print;  
</span><span class='line'>@end  
</span><span class='line'>@implementation ClassA  
</span><span class='line'>- (void) print{  
</span><span class='line'>NSLog (@"I'm ClassA.") ;  
</span><span class='line'>}  
</span><span class='line'>@end  
</span><span class='line'>int main (int argc, const char * argv[]) {  
</span><span class='line'>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];  
</span><span class='line'>SEL sel = @selector (print) ;  
</span><span class='line'>ClassA *classA = [[ClassA alloc]init];  
</span><span class='line'>[classA performSelector:sel withObject:nil]; //调用选择器指定的方法  
</span><span class='line'>[pool drain];  
</span><span class='line'>return 0;  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>【程序结果】</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>I'm ClassA. </span></code></pre></td></tr></table></div></figure>


<p>下面解释一下这段代码，读者有可能看不明白，因为到目前为止并没有讲述类相关的知识。读者只需要了解上述例子中选择器的用法即可，关于类的知识，会在后面的章节详细阐述。</p>

<p>代码首先创建了一个名字叫ClassA 的类，它只包含一个方法print。在随后的实现文件中，我们实现了这个方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void) print{  
</span><span class='line'>NSLog (@"I'm ClassA.") ;  
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>读者不难看出，这个方法仅仅是打印到控制台上一句话。在接下来的main方法中，定义了一个选择器sel，它指向的是一个名叫print 的方法。我们并不知道这个方法是哪个类的，因为具体的信息是在运行期间系统自动帮我们判断的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL sel = @selector (print) ; </span></code></pre></td></tr></table></div></figure>


<p>随后构建了一个对象（读者不用拘泥于语法，我们会在后面的章节详细阐述），并调用这个对象performSelector:withObject:的方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ClassA *classA = [[ClassA alloc]init];  
</span><span class='line'>[classA performSelector:sel withObject:nil]; </span></code></pre></td></tr></table></div></figure>


<p>这时候，系统就会自动调用classA对象的print方法，最终得到程序运行结果。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong/">使用神奇的PONYDEBUGGER调试iOS应用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-14T17:30:40+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>前言</h3>

<p>Debug算是开发者的基本技能之一吧，对于iOS开发者而言，可能会遇到如下一些debug需求：</p>

<p>调试网络请求问题
调试一个层次结构复杂的用户界面
查看应用内Core Data数据变化
虽然你可以通过NSLog日志，打断点，抑或LLDB的调试命令等一些常见手段来解决以上问题，但这些方式始终不够直观，效率也不高，特别是对于调试UI这个需求。要提高效率，我们可以使用一些第三方的调试工具，比如本文要介绍的PonyDebugger。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/07/shi-yong-viper-chuang-jian-kuang-jia/">使用VIPER构建iOS应用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-07T22:03:17+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>建筑领域流行这样一句话，“我们虽然在营造建筑，但建筑也会重新塑造我们”。正如所有开发者最终领悟到的，这句话同样适用于构建软件。</p>

<p>编写代码中至关重要的是，需要使每一部分容易被识别，赋有一个特定而明显的目的，并与其他部分在逻辑关系中完美契合。这就是我们所说的软件架构。好的架构不仅让一个产品成功投入使用，还可以让产品具有可维护性，并让人不断头脑清醒的对它进行维护！</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/12/07/shi-yong-viper-chuang-jian-kuang-jia/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop/">优秀开源项目：FACEBOOK PAPER动画引擎 – POP</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-14T19:02:27+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://cc.cocimg.com/cms/uploads/allimg/140429/4196_140429142234_1.gif" alt="id1" /></p>

<p>Pop是一个适用于iOS和OS X平台的可扩展动画引擎，是一个成熟的经过多重测试的，可实现Facebook Paper中的所有动画和过渡效果。除了基本的静态动画，Pop还支持spring和decay动画，有助于打造一个逼真的，基于物理的交互。你可以通过Pop的API把Pop快速集成到现有的Objective-C代码库中，并在任何对象上实现动画的任何属性。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/11/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/11/li-jie-objective-c-runtime/">理解 OBJECTIVE-C RUNTIME</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-11T21:34:12+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当人们初学 Cocoa/Objective-C 时，Objective-C Runtime 是被忽略的特性之一。原因是 Objective-C（这门语言）很容易在几小时内就熟悉，新学 Cocoa 的人花费他们大部分的时间学习 Cocoa 框架和适应它是如何工作的。然而每个人至少应该知道一些 runtime 的工作细节，需要比知道编译器会把 [target doMethodWith:var1]; 转换为 objc_msgSend(target,@selector(doMethodWith:),var1); 更深入一些。知道 Objective-C 正在做的会让你更深入的理解 Objective-C 和你正在运行的 app。我认为 Mac/iPhone 的开发者不管你现在是什么水平，都会有收获的。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/11/11/li-jie-objective-c-runtime/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/25/yi-dong-app-jia-gou-she-ji/">移动App架构设计</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-25T21:47:01+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Native app的开发相比传统的项目迭代周期要短很多, 需求的变化也频繁一些, 在开发的不同生命周期里采用不同的架构模式可以有效的节约开发时间, 提高开发效率, 这篇文章介绍几种常用的架构模式:</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/10/25/yi-dong-app-jia-gou-she-ji/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/17/ios-duo-xian-cheng-cao-zuo/">iOS多线程操作：锁 互斥 同步</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-17T23:03:45+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题，本文简单介绍：</p>

<h5>方法一，@synchronized(id anObject),(最简单的方法)</h5>

<p>会自动对参数对象加锁，保证临界区内的代码线程安全</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/10/17/ios-duo-xian-cheng-cao-zuo/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/24/xcodezhong-xi-tong-ku-wen-jian-libz-dot-dylibde-zuo-yong/">Xcode中系统库文件libz.dylib的作用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-24T22:08:21+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>libz.dylib这个Xcode系统库文件经常用到。这个其实是个动态链接库。</p>

<p>后缀名为.dylib的文件是一个动态库，这个库是运行时加载而不是编译时加载。这个也说明了obj-C是运行时语言，也就是数据的类型不是在编译时确定的，而是在运行时确定的。</p>

<p>libz.dylib也是zip压缩解压缩的库，开发中经常用到的压缩库，PDF可以使用这个库文件来压缩。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/24/xcodezhong-xi-tong-ku-wen-jian-libz-dot-dylibde-zuo-yong/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/21/instancetype-yu-id-de-qu-bie/">INSTANCETYPE 与 ID 的区别。</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-21T18:31:05+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>新的LLVM编译器为我们带来了ARC, Object Literal and Scripting, Auto Synthesis等特性，同时也引入了instancetype关键字。instancetype用来表示Related Result Types(相关返回类型)，那么它与id有什么不同呢？</p>

<p>根据Cocoa的命名惯例，init, alloc这类的方法，如果以id作为返回类型，会返回类本身的类型。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/21/instancetype-yu-id-de-qu-bie/">Read on &rarr;</a>
    </footer>
  


    </article>
  

  <div class="pagination">
   <nav id="pagenavi">

    

       
      
      
        <a href="/posts/2" class="next">Older</a>
      

    </nav>
  </div>
</div>

<!-- <aside class="sidebar">
  
    
  
</aside> &#8211;>

<footer role="contentinfo">
<p style="text-align:center">
  Copyright &copy; 2015 - LeeZhenjie -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
</footer>

    </div>
  </div>

  <footer role="contentinfo">
<p style="text-align:center">
  Copyright &copy; 2015 - LeeZhenjie -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
</footer>
  











  
<ul class="main-navigation">
  <li><a href="/" class="nav-link">首页 | Blog</a></li>
  <li><a href="/blog/archives" class="nav-link">归档 | Archives</a></li>
  <li><a href="/atom.xml" class="nav-link">订阅 | RSS</a></li>
  <li><a href="/about" class="nav-link">关于我 | About</a></li>
</ul>


<!-- <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script type="text/javascript" src="http://arrow.scrolltotop.com/arrow13.js"></script>
 &#8211;>
<script type="text/javascript" src="http://arrow.scrolltotop.com/arrow37.js"></script>
<noscript>Not seeing a <a href="http://www.scrolltotop.com/">Scroll to Top Button</a>? Go to our FAQ page for more info.</noscript>




</body>

</html>
