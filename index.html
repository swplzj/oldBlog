<html>


<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>李振杰</title>
  <meta name="author" content="LeeZhenjie">

  
  <meta name="description" content="Appearance是Apple在iOS5.0上加的一个协议，它让程序员可以很轻松地改变某控件的全局样式（背景） @selector(appearance) 支持UIAppearance协议的类可以访问appearance selector ,它为receiver返回appearance &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://swplzj.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="李振杰" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- // <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> &#8211;>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  <!-- 
 -->
</head>

<body    class="collapse-sidebar sidebar-footer" >
  <nav id="main-nav" role="navigation">
<ul class="main-navigation">
  <li><a href="/" class="nav-link">首页 | Blog</a></li>
  <li><a href="/blog/archives" class="nav-link">归档 | Archives</a></li>
  <li><a href="/atom.xml" class="nav-link">订阅 | RSS</a></li>
  <li><a href="/about" class="nav-link">关于我 | About</a></li>
</ul>

</nav>
  <header role="banner"><hgroup>
	
		<img src="/images/portrait.jpg" class="portrait" height=250px width=250px />
	
  <h1><a href="/">李振杰</a></h1>
  
    <h2>An iOS developer‘s blog about programming and growing.</h2>
  
</hgroup>

</header> 
  
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/12/at-ios5yi-shang-:she-zhi-kong-jian-quan-ju-xian-shi-yang-shi-%3C%3C-appearance-proxy/">@IOS5以上：设置控件全局显示样式《APPEARANCE PROXY》</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-12T18:34:41+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Appearance是Apple在iOS5.0上加的一个协议，它让程序员可以很轻松地改变某控件的全局样式（背景）</p>

<pre><code> @selector(appearance)
</code></pre>

<p>支持UIAppearance协议的类可以访问appearance selector ,它为receiver返回appearance proxy，我们可以给proxy发一些消息，诸如setTintColor:等</p>

<p>但是它并不是支持所有的UI类。下面列出它支持的类</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/02/12/at-ios5yi-shang-:she-zhi-kong-jian-quan-ju-xian-shi-yang-shi-%3C%3C-appearance-proxy/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop/">优秀开源项目：FACEBOOK PAPER动画引擎 – POP</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-14T19:02:27+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="http://cc.cocimg.com/cms/uploads/allimg/140429/4196_140429142234_1.gif" alt="id1" /></p>

<p>Pop是一个适用于iOS和OS X平台的可扩展动画引擎，是一个成熟的经过多重测试的，可实现Facebook Paper中的所有动画和过渡效果。除了基本的静态动画，Pop还支持spring和decay动画，有助于打造一个逼真的，基于物理的交互。你可以通过Pop的API把Pop快速集成到现有的Objective-C代码库中，并在任何对象上实现动画的任何属性。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/12/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong/">使用神奇的PONYDEBUGGER调试iOS应用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-14T17:30:40+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>前言</h3>

<p>Debug算是开发者的基本技能之一吧，对于iOS开发者而言，可能会遇到如下一些debug需求：</p>

<p>调试网络请求问题
调试一个层次结构复杂的用户界面
查看应用内Core Data数据变化
虽然你可以通过NSLog日志，打断点，抑或LLDB的调试命令等一些常见手段来解决以上问题，但这些方式始终不够直观，效率也不高，特别是对于调试UI这个需求。要提高效率，我们可以使用一些第三方的调试工具，比如本文要介绍的PonyDebugger。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/21/li-jie-objective-c-runtime/">理解 OBJECTIVE-C RUNTIME</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-21T21:34:12+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当人们初学 Cocoa/Objective-C 时，Objective-C Runtime 是被忽略的特性之一。原因是 Objective-C（这门语言）很容易在几小时内就熟悉，新学 Cocoa 的人花费他们大部分的时间学习 Cocoa 框架和适应它是如何工作的。然而每个人至少应该知道一些 runtime 的工作细节，需要比知道编译器会把 [target doMethodWith:var1]; 转换为 objc_msgSend(target,@selector(doMethodWith:),var1); 更深入一些。知道 Objective-C 正在做的会让你更深入的理解 Objective-C 和你正在运行的 app。我认为 Mac/iPhone 的开发者不管你现在是什么水平，都会有收获的。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/21/li-jie-objective-c-runtime/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/21/instancetype-yu-id-de-qu-bie/">INSTANCETYPE 与 ID 的区别。</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-21T18:31:05+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>新的LLVM编译器为我们带来了ARC, Object Literal and Scripting, Auto Synthesis等特性，同时也引入了instancetype关键字。instancetype用来表示Related Result Types(相关返回类型)，那么它与id有什么不同呢？</p>

<p>根据Cocoa的命名惯例，init, alloc这类的方法，如果以id作为返回类型，会返回类本身的类型。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/21/instancetype-yu-id-de-qu-bie/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/21/yi-dong-app-jia-gou-she-ji/">移动App架构设计</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-21T16:47:01+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Native app的开发相比传统的项目迭代周期要短很多, 需求的变化也频繁一些, 在开发的不同生命周期里采用不同的架构模式可以有效的节约开发时间, 提高开发效率, 这篇文章介绍几种常用的架构模式:</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/21/yi-dong-app-jia-gou-she-ji/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/18/min-jie-kai-fa-liu-cheng-zong-jie/">敏捷开发流程总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-18T13:42:04+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>Agile——敏捷开发</h4>

<p>作为CMM神话崩溃后被引入的一套新的软件开发模式，这几年来被广泛引起关注，并被寄予厚望。敏捷开发在其他业界的应用是否理想不得而知，但以下总结了我所在公司的敏捷开发试验，希望可以达到管中窥豹的目的。</p>

<h5>敏捷开发宣言——</h5>

<p>个体和交互 胜过 过程和工具
可以工作的软件 胜过 面面俱到的文档
客户合作 胜过 合同谈判
响应变化 胜过 遵循计划
虽然右项也有价值，但是我们认为左项具有更大的价值。</p>

<p>以上的宣言比较抽象，基于该理念，以下是ThoughtsWork咨询公司的推崇的n个敏捷开发实践：</p>

<h5>Iteration</h5>

<p>迭代开发。可以工作的软件胜过面面俱到的文档。因此，敏捷开发提倡将一个完整的软件版本划分为多个迭代，每个迭代实现不同的特性。重大的、优先级高的特性优先实现，风险高的特性优先实现。在项目的早期就将软件的原型开发出来，并基于这个原型在后续的迭代不断晚上。迭代开发的好处是：尽早编码，尽早暴露项目的技术风险。尽早使客户见到可运行的软件，并提出优化意见。可以分阶段提早向不同的客户交付可用的版本。</p>

<h5>IterationPlanningMeeting</h5>

<p>迭代计划会议。每个迭代启动时，召集整个开发团队，召开迭代计划会议，所有的团队成员畅所欲言，明确迭代的开发任务，解答疑惑。</p>

<h5>Story Card/Story Wall/Feature List</h5>

<p>在每个迭代中，架构师负责将所有的特性分解成多个Story Card。每个Story可以视为一个独立的特性。每个Story应该可以在最多1个星期内完成开发，交付提前测试（Pre-Test）。当一个迭代中的所有Story开发完毕以后，测试组再进行完整的测试。在整个测试过程中（pre-test，test），基于Daily build，测试组永远都是每天从配置库上取下最新编译的版本进行测试，开发人员也随时修改测试人员提交的问题单，并合入配置库。
敏捷开发的一个特点是开放式办公，充分沟通，包括测试人员也和开发人员一起办公。基于Story Card的开发方式，团队会在开放式办公区域放置一块白板，上面粘贴着所有的Story Card，按当前的开发状态贴在4个区域中，分别是：未开发，开发中，预测试中，测试中。Story Card的开发人员和测试人员根据开发进度在Story Wall上移动Story Card，更新Story Card的状态。这种方式可以对项目开发进度有一个非常直观的了解。
在开发人员开始开发一个Story时，ta需要找来对应的测试人员讲解Story功能，以便测试人员有一致的理解，同时开始自动化系统测试脚本的开发。</p>

<h5>Standup Meeting</h5>

<p>站立会议。每天早上，所有的团队成员围在Story Wall周围，开一个高效率的会议，通常不超过15分钟，汇报开发进展，提出问题，但不浪费所有人的时间立刻解决问题，而是会后个别沟通解决。</p>

<h5>Pair Programming</h5>

<p>结对编程是指两个开发人员结对编码。结对编程的好处是：经过两个人讨论后编写的代码比一个人独立完成会更加的完善，一些大的方向不至于出现偏差，一些细节也可以被充分考虑到。一个有经验的开发人员和一个新手结对编程，可以促进新手的成长，保证软件开发的质量。</p>

<h5>CI/Daily Build</h5>

<p>持续集成和每日构建能力是否足够强大是迭代开发是否成功的一个重要基础。基于每日构建。开发人员每天将编写/修改的代码及时的更新到配置库中，自动化编译程序每天至少一次自动从配置库上取下代码，执行自动化代码静态检查（如PCLint），单元测试，编译版本，安装，系统测试，动态检查（如Purify）。以上这些自动化任务执行完毕后，会输出报告，自动发送邮件给团队成员。如果其中存在着任何的问题，相关责任人应该及时的修改。
可以看到，整个开发组频繁的更新代码，出现一些问题不可避免。通过测试部又在不停地基于最新的代码进行测试。新增的问题是否能够被及时发现并消灭掉，取决于自动化单元测试和系统测试能力是否足够强大，特别是自动化系统测试能力。如果自动化测试只能验证最简单的操作，则新合入代码的隐患将很难被发现，并遗留到项目后期，形成大的风险。而实际上，提升自动化测试的覆盖率是最困难的。</p>

<h5>Retrospect</h5>

<p>总结和反思。每个迭代结束以后，项目组成员召开总结会议，总结好的实践和教训，并落实到后续的开发中。</p>

<h5>ShowCase</h5>

<p>演示。每个Story开发完成以后，开发人员叫上测试人员，演示软件功能，以便测试人员充分理解软件功能。</p>

<h5>Refactoring</h5>

<p>重构。因为迭代开发模式在项目早期就开发出可运行的软件原型，一开始开发出来的代码和架构不可能是最优的、面面俱到的，因此在后续的Story开发中，需要对代码和架构进行持续的重构。迭代开发对架构师要求很高。因为架构师要将一个完整的版本拆分成多个迭代，每个跌倒由拆分成很多Story，从架构的角度看，这些Story必须在是有很强的继承性，是可以不断叠加的，不至于后续开发的Story完全推翻了早期开发的代码和架构，同时也不可避免的需要对代码进行不断完善，不断重构。</p>

<h5>TDD</h5>

<p>测试驱动开发。正如上面讲的，迭代开发的特点是频繁合入代码，频繁发布版本。测试驱动开发是保证合入代码正常运行且不会在后期被破坏的重要手段。这里的测试主要指单元测试。</p>

<h5>敏捷方法反思：</h5>

<p>自己参与的敏捷开发项目总的来说不是很成功，这可能也是业界遇到的通病：
1、对于全新的软件，在项目早期测试人员就参与并实现自动化测试脚本，但实际上软件的界面等非常不稳定，导致测试人员返工的工作量很大。
2、对于全新的软件，资料人员过早参与，后期返工工作量大，原因同第一点。
3、自动化系统测试工作量大，测试人员投入大量的精力在使测试自动化起来，而没有足够的精力放在真正的测试软件的功能是否正常。即便是这样，自动化系统测试脚本也多流于形式，测不出深层次的问题。
4、代码动态检查工具执行不理想，流于形式。没有人对Purify有深刻的理解和应用经验，报告中查出来很多告警，但不知如何消除。
5、由于快速搭建原型，没有在架构上进行严谨的设计，导致后期一直堆砌代码。
6、异地开发模式下无法实现快速构建、快速交付，团队普遍感觉很疲惫。
7、敏捷开发不提倡加班，但实际上不管是CMM还是Agile哪一种开发模式跟是否加班都没有必然联系。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/17/shi-yong-viper-chuang-jian-kuang-jia/">使用VIPER构建iOS应用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-17T20:33:17+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>建筑领域流行这样一句话，“我们虽然在营造建筑，但建筑也会重新塑造我们”。正如所有开发者最终领悟到的，这句话同样适用于构建软件。</p>

<p>编写代码中至关重要的是，需要使每一部分容易被识别，赋有一个特定而明显的目的，并与其他部分在逻辑关系中完美契合。这就是我们所说的软件架构。好的架构不仅让一个产品成功投入使用，还可以让产品具有可维护性，并让人不断头脑清醒的对它进行维护！</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/17/shi-yong-viper-chuang-jian-kuang-jia/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/17/ios-duo-xian-cheng-cao-zuo/">iOS多线程操作：锁 互斥 同步</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-17T19:03:45+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题，本文简单介绍：</p>

<h5>方法一，@synchronized(id anObject),(最简单的方法)</h5>

<p>会自动对参数对象加锁，保证临界区内的代码线程安全</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/17/ios-duo-xian-cheng-cao-zuo/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/17/look-up/">《抬起头吧》</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-17T18:54:32+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>《Look up》-《抬起头吧》很有感触</h4>

<p>我有好几百位手机好友，但我仍然常常感到孤独；我每天跟他们聊天，但是好像他们并不了解真正的我。我的疑问来自于人与人之间的相处方式，我究竟是想看着他们的眼睛，还是手机上的昵称？直到有一天我发现，所谓的社交网络，并不完全是我们看到的那样。当我们打开电脑或者手机，其实也就关上了彼此心灵沟通的大门。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/17/look-up/">Read on &rarr;</a>
    </footer>
  


    </article>
  

  <div class="pagination">
   <nav id="pagenavi">

    

       
      
      
        <a href="/posts/2" class="next">Older</a>
      

    </nav>
  </div>
</div>

<!-- <aside class="sidebar">
  
    
  
</aside> &#8211;>

<footer role="contentinfo">
<p style="text-align:center">
  Copyright &copy; 2015 - LeeZhenjie -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
</footer>

    </div>
  </div>

  <footer role="contentinfo">
<p style="text-align:center">
  Copyright &copy; 2015 - LeeZhenjie -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
</footer>
  











  
<ul class="main-navigation">
  <li><a href="/" class="nav-link">首页 | Blog</a></li>
  <li><a href="/blog/archives" class="nav-link">归档 | Archives</a></li>
  <li><a href="/atom.xml" class="nav-link">订阅 | RSS</a></li>
  <li><a href="/about" class="nav-link">关于我 | About</a></li>
</ul>


<!-- <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script type="text/javascript" src="http://arrow.scrolltotop.com/arrow13.js"></script>
 &#8211;>
<script type="text/javascript" src="http://arrow.scrolltotop.com/arrow37.js"></script>
<noscript>Not seeing a <a href="http://www.scrolltotop.com/">Scroll to Top Button</a>? Go to our FAQ page for more info.</noscript>




</body>

</html>
