<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李振杰]]></title>
  <link href="http://swplzj.github.io/atom.xml" rel="self"/>
  <link href="http://swplzj.github.io/"/>
  <updated>2015-02-13T15:26:16+08:00</updated>
  <id>http://swplzj.github.io/</id>
  <author>
    <name><![CDATA[LeeZhenjie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS程序的Build过程]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/13/ioscheng-xu-de-buildguo-cheng/"/>
    <updated>2015-02-13T15:07:52+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/13/ioscheng-xu-de-buildguo-cheng</id>
    <content type="html"><![CDATA[<p>本文将轻度解密Xcode build日志，还原iOS程序build的过程。
另外将介绍如何对build过程的控制，进而定制出自己希望的流程，
例如通过Build phase的定制，给app icon打水印(包括版本号和日期)。
通过对工程文件的解读，为你揭开工程文件(.pbxproj)与
build settings的关系。这对于解决工程文件的merge冲突非常有帮助。
PS：实际上各开发平台的build过程都比较相似，如果你熟悉了
某个平台的build过程，那么同样的原理也适用于别的平台。
可以说换汤不换药，本质是一样的。</p>

<!--more-->


<h4>本文目录如下所示：</h4>

<ul>
<li>解密Build日志</li>
<li>Build过程的控制</li>
<li>工程文件</li>
<li>小结</li>
</ul>


<p>当我们进行开发时，如果需要运行程序，只要在Xcode中点击运行按钮(这个按钮看起来有点像在播放音乐)，过一会，我们的程序就会运行在设备或者模拟器上了，看似简单的操作过程，不过在这背后隐藏了许多步骤！当然，有时候也会遇到一些错误。</p>

<p>本文，我将从稍微高一点的角度来解读整个Build过程，并探索一下Build过程与Xcode界面上显示的project setting有多大关系。当然，为了更加深入的了解每一步实际执行的任务，我会适当的引入一些别的文章。</p>

<h4>解密Build日志</h4>

<p>为了了解Xcode build过程的内部工作原理，我们首先把突破点放在完整的log文件上。打开Log Navigator，从列表中选择一个Build，Xcode就会通过很漂亮的一种格式将log文件显示出来。如下图所示：</p>

<p><img src="http://beyondvincent.com/images/2013/11/41.png" alt="id1" /></p>

<p>默认情况下，XCode会把大量的log信息隐藏起来，你只需要点击选中某条log，然后点击右边的展开按钮，就能看到该条log的详细信息了。当然，你也可以选中一条或者多条日志，然后通过Cmd+C，就能将相关的所有文本信息拷贝到粘贴板上。另外，还可以通过菜单Editor中的Copy transcript for shown results将所有的log信息复制到粘贴板上。</p>

<p>在我这儿的示例中，将近有10000行log信息(当然，大多数信息是由OpenSSL带来的，并非来自我们的代码)。下面我们就开始吧！</p>

<p>首先，你可能会发现输出的log信息，被工程中对应的target分割开了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Build target Pods-SSZipArchive
</span><span class='line'>...
</span><span class='line'>Build target Makefile-openssl
</span><span class='line'>...
</span><span class='line'>Build target Pods-AFNetworking
</span><span class='line'>...
</span><span class='line'>Build target crypto
</span><span class='line'>...
</span><span class='line'>Build target Pods
</span><span class='line'>...
</span><span class='line'>Build target ssl
</span><span class='line'>...
</span><span class='line'>Build target objcio</span></code></pre></td></tr></table></div></figure>


<p>在我这的工程中有好几个依赖项：如包含在Pods中的AFNetworking 和 SSZipArchive, 已经以子工程形式存在的OpenSSL等。</p>

<p>针对这里的每个target，Xcode都会执行一些列的操作，以将相关的源代码转换为机器可读的二进制(于所选平台相关)。我们来亲密接触一下第一个targetSSZipArchive吧。</p>

<p>在这个target的log输出中，我们可以看到每个任务执行的详细情况。例如，第一个是处理一个预编译头文件(为了增加其可读性，我省略了许多细节)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(1) ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c com.apple.compilers.llvm.clang.1_0.compiler
</span><span class='line'>    (2) cd /.../Dev/objcio/Pods
</span><span class='line'>        setenv LANG en_US.US-ASCII
</span><span class='line'>        setenv PATH "..."
</span><span class='line'>    (3) /.../Xcode.app/.../clang 
</span><span class='line'>            (4) -x objective-c-header 
</span><span class='line'>            (5) -arch armv7 
</span><span class='line'>            ... configuration and warning flags ...
</span><span class='line'>            (6) -DDEBUG=1 -DCOCOAPODS=1 
</span><span class='line'>            ... include paths and more ...
</span><span class='line'>            (7) -c 
</span><span class='line'>            (8) /.../Pods-SSZipArchive-prefix.pch 
</span><span class='line'>            (9) -o /.../Pods-SSZipArchive-prefix.pch.pch</span></code></pre></td></tr></table></div></figure>


<p>在build过程中，每个任务都会出现类似上面的这些log信息，我们就通过上面的log信息了解详情吧。
每个log都会以这样的一行来对任务进行描述。</p>

<p>接着下面带缩进的这3行会被输出。此处，修改了工作路径，并对PANG和PATH环境变量进行设置。
这里才是真正焕发出魔力的地方。为了处理一个.pch文件，调用了clang，并且附带了大量的选项。这行log信息显示出了所有的调用参数，我们稍微看几个参数吧：</p>

<p>-x标示符用来指定语言，此时是objective-c-header。</p>

<p>目标架构指定为armv7。</p>

<p>标示#defines的内容已经被添加了。</p>

<p>-c标示符用来告诉clang具体如何运行。-c意味着：运行预处理器、词法分析、类型检查LLVM的生成和优化，以及特定target相关汇编代码的生成阶段，最后，运行这个汇编代码以生成.o目标文件。</p>

<p>输入文件。</p>

<p>输出文件。</p>

<p>虽然有大量的log信息，不过我不会把每个log信息都做详解。我们的目的是让你了解在build过程中，完整的了解什么工具被调用，以及都使用了什么参数。</p>

<p>针对这个target，虽然只有一个.pch文件，但实际上这里对objective-c-header文件处理了两次。下面来看看log信息告诉我们的详细情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c ...
</span><span class='line'>ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7s objective-c ...</span></code></pre></td></tr></table></div></figure>


<p>可以看到，build了两种target：armv7和armv7s，所以clang为每种架构处理了一次这个文件。
紧接着预编译头文件的处理之后，我们可以找到SSZipArchive target相关的其它一些任务：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CompileC ...
</span><span class='line'>Libtool ...
</span><span class='line'>CreateUniversalBinary ...</span></code></pre></td></tr></table></div></figure>


<p>通过名称，我们基本能够知道个大概：CompileC用来编译.m和.c文件，Libtool根据目标文件创建出一个库，而CreateUniversalBinary则将上一阶段产生的两个.a文件(对应着两个不同的架构)合并为一个通用的二进制文件(可以运行在armv7和armv7s上)。</p>

<p>上面这些类似的步骤会出现在工程中所有其它的依赖项中。</p>

<p>当所有的依赖项都准备好了，就可以开始构建我们程序的target了。针对该target输出的log信息包含了之前没有出现过的内容，这些内容非常有价值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PhaseScriptExecution ...
</span><span class='line'>DataModelVersionCompile ...
</span><span class='line'>Ld ...
</span><span class='line'>GenerateDSYMFile ...
</span><span class='line'>CopyStringsFile ...
</span><span class='line'>CpResource ...
</span><span class='line'>CopyPNGFile ...
</span><span class='line'>CompileAssetCatalog ...
</span><span class='line'>ProcessInfoPlistFile ...
</span><span class='line'>ProcessProductPackaging /.../some-hash.mobileprovision ...
</span><span class='line'>ProcessProductPackaging objcio/objcio.entitlements ...
</span><span class='line'>CodeSign ...</span></code></pre></td></tr></table></div></figure>


<p>在上面的任务中，可能Ld不能一眼看出是什么意思，此处它是一个linker工具，跟libtool类似。实际上libtool会简单的调用ld和lipo。而ld用来构建可执行文件。更多编译和链接相关的文章可以看看 Daniel 和 Chris写的。</p>

<p>上面这些步骤，实际上都会调用相关的命令行工具来做实际的工作，这跟之前我们看的步骤ProcessPCH类似。至此，我将不会继续介绍这些log信息了，我将带来大家从另外一个不同的角度来继续探索这些任务：Xcode是如何知道哪些任务需要被执行？</p>

<h4>Build过程的控制</h4>

<p>当你选中在Xcode 5中的一个工程时，project editor会在顶部显示出6个tabs：General, Capabilities, Info, Build Settings, Build Phases 以及 Build Rules。如下图所示：</p>

<p><img src="http://beyondvincent.com/images/2013/11/42.png" alt="id2" /></p>

<p>其中最后3项与build过程的相关度最大。</p>

<h6>Build Phases</h6>

<p>Build Phases代表着将代码构建为一个可执行文件的规则。它描述了build过程中必须执行的不同任务。</p>

<p><img src="http://beyondvincent.com/images/2013/11/43.png" alt="id3" /></p>

<p>首先，指定了target的依赖项。这将告诉build系统在当前target可以build之前，必须先build target的依赖项。实际上这并不属于真正的build phase，在这里，Xcode只不过将其与build phase显示到一块罢了。</p>

<p>接着是一个CocoaPods相关的脚本需要在build phase执行——更多CocoaPods相关信息可以查看Michele的文章。</p>

<p>然后在Compile Sources中指定了所有必须进行编译的文件。更多相关内容我们将在build rules和build settings中研究。在Compile Sources中指定的文件将根据这些rule和setting被处理。</p>

<p>当编译结束，下一步就是将所有的内容链接到一块：Link Binary with Libraries。在这里面列出了所有的静态库和动态库，这些库会与上面编译阶段生成的目标文件进行链接。实际上静态库和动态库的处理过程有非常大的区别，相关内容可以参考Daniel的文章 Mach-O executables。</p>

<p>当链接完成之后，build phase中最后需要处理的就是将静态资源（例如图片和字体）拷贝到app bundle中。需要注意的是，如果图片资源是PNG格式，那么不仅仅对其进行拷贝，还会做一些优化(如果build settings中的PNG优化是打开的)。</p>

<p>虽然静态资源的拷贝是build phase中的最后一步，但这并不代表build过程已经完成了。例如，还没有进行code signing(这并不是build phase考虑的范畴)，code signing属于build步骤中的最后一步Packaging。</p>

<h6>定制Build Phases</h6>

<p>至此，你已经完全可以掌控build phases相关内容(先不考虑默认的设置项)，例如，你可以在build phases中添加运行自定义脚本，就像CocoaPods使用的一样，来做额外的工作。当然也可以添加一些资源的拷贝任务，当你需要将某些确定的资源拷贝到制定的target目录中，这非常有用。</p>

<p>另外你可以通过定制build phase来添加带有水印(包括版本号和commit hash)的app icon。只需要在build phase中添加一个Run Script，然后用下面的命令来获取版本号和commit hash：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>version=`/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "${INFOPLIST_FILE}"`
</span><span class='line'>commit=`git rev-parse --short HEAD`</span></code></pre></td></tr></table></div></figure>


<p>然后可以使用ImageMagick来修改app icon。这里有一个完整的示例，可以参考。</p>

<p>如果你希望编写的代码比较简洁点，那么可以添加一个Run Script，如果一个源文件超过指定行数，就发出警告。如下代码所示，设置的行数为200。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>find "${SRCROOT}" \( -name "*.h" -or -name "*.m" \) -print0 | xargs -0 wc -l | awk '$1 &gt; 200 && $2 != "total" { print $2 ":1: warning: file more than 200 lines" }'</span></code></pre></td></tr></table></div></figure>


<h6>Build Rules</h6>

<p>Build rules指定了不同文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。如果你需要对特定的文件类型添加处理方法，那么可以在此处天剑一条新的规则。</p>

<p>一条build rule指定了其应用于那种文件类型，该文件类型是如何被处理的，以及输出内容被放置到何处。比方说，我们创建了一条预处理规则，该规则将Objective-C的实现文件当做输入，然后解析文件内部的注释内容，最后再输出一个.m文件，文件中包含了生成的代码。由于我们不能将.m文件既当做输入又当做输出，所以我使用了.mal后缀，定制的build rule如下所示：</p>

<p><img src="http://beyondvincent.com/images/2013/11/44.png" alt="id4" /></p>

<p>上面的规则应用于所有后缀为*.mal的文件，这些文件会被自定义的脚本处理(调用我们的预处理器，并附带上输入和输出参数)。最后，该规则告诉build system在哪里可以找到此规则的输出文件。</p>

<p>由于这里的输出是一个.m文件，那么build使这些.m文件会被编译处理(就如刚开始介绍的那些预处理步骤)。
在脚本中，我使用了少量的变量来指定正确的路径和文件名。在苹果的Build Setting Reference.文档中可以找到所有可用的变量。build过程中，要想观察所有已存在的环境变量，你可以添加一个Run Script build phase，并勾选上Show environment variables in build log。</p>

<h6>Build Settings</h6>

<p>至此，我们已经了解到build phases是如何被用来定义build 过程的步骤，以及build rules是如何指定哪些文件类型在编译阶段需要被预处理。在build settings中，我们可以配置每个任务(之前在build log输出中看到的任务)的详细内容。</p>

<p>在这里，你会发现build 过程的每一个阶段，都有许多选项：从编译、链接一直到code signing和packaging。注意，settings被分割为不同的部分，大部分会于build phases有关联，有时候也会指定编译的文件类型。</p>

<p>这些选项基本都有不错的文档介绍，你可以在右边面板中的quick help inspector或者 Build Setting Reference中查看到。</p>

<h6>工程文件</h6>

<p>上面我们介绍的所有内容都被保存在工程文件(.pbxproj)中，除了其它一些工程相关信息(例如file groups)，我们很少会深入该文件内部，除非在代码merge时发生冲突，或许会进去看看。
我建议你用文本编辑器打开一个工程文件，从头到尾的看一遍里面的内容。它的可读性非常高，里面的许多内容一看就知道什么意思了，不会存在太大的问题。通过阅读并完全理解工程文件，这对于合并工程文件的冲突非常有帮助。</p>

<p>首先，我们来看看文件中叫做rootObject的entry。在我的工程中，如下所示：</p>

<pre><code>rootObject = 1793817C17A9421F0078255E /* Project object */;
</code></pre>

<p>根据这个ID(1793817C17A9421F0078255E)，我们可以找到main工程的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Begin PBXProject section */
</span><span class='line'>    1793817C17A9421F0078255E /* Project object */ = {
</span><span class='line'>        isa = PBXProject;
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>在这部分section中包含了一些keys，顺从这些key，我们可以了解到更多关于这个工程文件的组成。例如，mainGroup指向了root file group。如果你按照这个思路，你可以快速了解到在.pbxproj文件中工程的结构。下面我要来介绍一些与build过程相关的内容。其中target key指向了build target的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>targets = (
</span><span class='line'>    1793818317A9421F0078255E /* objcio */,
</span><span class='line'>    170E83CE17ABF256006E716E /* objcio Tests */,
</span><span class='line'>);</span></code></pre></td></tr></table></div></figure>


<p>根据第一个id，我们找到一个target的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1793818317A9421F0078255E /* objcio */ = {
</span><span class='line'>    isa = PBXNativeTarget;
</span><span class='line'>    buildConfigurationList = 179381B617A9421F0078255E /* Build configuration list for PBXNativeTarget "objcio" */;
</span><span class='line'>    buildPhases = (
</span><span class='line'>        F3EB8576A1C24900A8F9CBB6 /* Check Pods Manifest.lock */,
</span><span class='line'>        1793818017A9421F0078255E /* Sources */,
</span><span class='line'>        1793818117A9421F0078255E /* Frameworks */,
</span><span class='line'>        1793818217A9421F0078255E /* Resources */,
</span><span class='line'>        FF25BB7F4B7D4F87AC7A4265 /* Copy Pods Resources */,
</span><span class='line'>    );
</span><span class='line'>    buildRules = (
</span><span class='line'>    );
</span><span class='line'>    dependencies = (
</span><span class='line'>        1769BED917CA8239008B6F5D /* PBXTargetDependency */,
</span><span class='line'>        1769BED717CA8236008B6F5D /* PBXTargetDependency */,
</span><span class='line'>    );
</span><span class='line'>    name = objcio;
</span><span class='line'>    productName = objcio;
</span><span class='line'>    productReference = 1793818417A9421F0078255E /* objcio.app */;
</span><span class='line'>    productType = "com.apple.product-type.application";
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>其中buildConfigurationList指向了可用的配置项，一般包括Debug和Release。根据debug对应的id，我们可以找到build setting tab中所有选项存储的位置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>179381B717A9421F0078255E /* Debug */ = {
</span><span class='line'>    isa = XCBuildConfiguration;
</span><span class='line'>    baseConfigurationReference = 05D234D6F5E146E9937E8997 /* Pods.xcconfig */;
</span><span class='line'>    buildSettings = {
</span><span class='line'>        ALWAYS_SEARCH_USER_PATHS = YES;
</span><span class='line'>        ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME = LaunchImage;
</span><span class='line'>        CODE_SIGN_ENTITLEMENTS = objcio/objcio.entitlements;
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>而buildPhases属性则简单的列出了在Xcode中定义的所有build phases。这非常容易识别出来(Xcode中的参数使用了它们原本真正的名字，并以C风格进行注释)。</p>

<p>buildRules属性是空的：因为在该工程中，我没有自定义build rules。</p>

<p>dependencies列出了在Xcode build phase tab中列出的target依赖项。</p>

<p>没那么吓人，不是吗？工程中剩下的内容就留给你去当做练习来了解吧。只需要顺着ID走，即可，一旦你找到了敲门，理解了Xcode中工程设置的不同section，那么对于merge工程文件的冲突时，将变得非常简单。甚至可以在GitHub中就能阅读工程文件，而不用将工程文件clone到本地，并用Xcode打开。</p>

<h4>小结</h4>

<p>当今的软件是都用其它复杂的一些软件和资源开发出来的，例如library和build工具等。反过来，这些工具是构建于底层架构的，这犹如剥洋葱一样，一层包着一层。虽然这样一层一层的，给人感觉太复杂，但是你完全可以去深入了解它们，这非常有助于你对软件的深入理解，实际上当你了解之后，这并没有想象中的那么神奇，只不过它是一层一层堆砌起来的，每一层都是基于下一层构建起来的。</p>

<p>在这里，我们只是轻微的探究了一下build过程，当我们点击Xcode中的允许按钮时，并没必要深入了解内部具体发生了什么。只需要了解到build的过程，以及可控的一些操作顺序即可。当然，要想进一步深入了解，可以试着阅读其它一些文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中消息的传递机制]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/13/ioszhong-xiao-xi-de-chuan-di-ji-zhi/"/>
    <updated>2015-02-13T14:43:49+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/13/ioszhong-xiao-xi-de-chuan-di-ji-zhi</id>
    <content type="html"><![CDATA[<h4>目录</h4>

<p><a href="#01">  可用的机制     </a></p>

<p><a href="#02">  做出正确的选择   </a></p>

<p><a href="#03">  Framework示例 </a></p>

<p><a href="#04">  小结              </a></p>

<p>每个应用程序或多或少，都由一些松耦合的对象构成，这些对象彼此之间要想很好的完成任务，就需要进行消息传递。本文将介绍所有可用的消息传递机制，并通过示例来介绍这些机制在苹果的Framework中如何使用，同时，还介绍了一些最佳实践建议，告诉你什么时机该选择使用什么机制。</p>

<!--more-->


<p>虽然这一期的主题是关于Foundation Framework的，不过本文中还介绍了一些超出Foundation Framework(KVO和Notification)范围的一些消息传递机制，另外还介绍了delegation，block和target-action。</p>

<p>大多数情况下，消息传递该使用什么机制，是很明确的了，当然了，在某些情况下该使用什么机制并没有明确的答案，需要你亲自去尝试一下。</p>

<p>本文中，会经常提及接收者[recipient]和发送者[sender]。在消息传递机制中具体是什么意思，我们可以通过一个示例来解释：一个table view是发送者，而它的delegate就是接收者。Core Data managed object context是notification的发送者，而获取这些notification的主体则是接收者。一个滑块(slider)是action消息的发送者，而在代码里面对应着实现这个action的responder就是接收者。对象中的某个属性支持KVO，那么谁修改这个值，谁就是发送者，对应的观察者(observer)则是接收者。</p>

<p><a name="可用的机制" id="01"></a></p>

<h4>可用的机制</h4>

<p>首先我们来看看每种机制的具体特点。在下一节中，我会结合一个流程图来介绍如何在具体情况下，选择正确的消息传递机制。最后，将介绍一些来自苹果Framework中的示例，并会解释在某种确定情况下为什么要选择固定的机制。</p>

<h5>KVO</h5>

<p>KVO提供了这样一种机制：当对象中的某个属性值发生了改变，可以对这些值的观察者做出通知。KVO的实现包含在Foundation里面，基于Foundation构建的许多Framework对KVO都有所依赖。要想了解更多关于如何使用KVO，可以阅读本期由Daniel写的的KVO和KVC文章。</p>

<p>如果对某个对象中值的改变情况感兴趣，那么可以使用KVO消息传递机制。这里有两个要求，首先，接收者(会接收到值发生改变的消息)必须知道发送者(值将发生改变的那个对象)。另外，接收者同样还需要知道发送者的生命周期，因为在销毁发送者对象之前，需要取消观察者的注册。如果这两个要求都满足了，消息传递过程中可以是1对多(多个观察者可以注册某个对象中的值)。</p>

<p>如果计划在Core Data对象上使用KVO，需要知道这跟一般的KVO使用方法有点不同。那就是必须结合Core Data的故障机制(faulting mechanism)，一旦core data出现了故障，它将会触发其属性对应的观察者(即使这些属性值没有发生改变)。</p>

<h5>Notification</h5>

<p>在不相关的两部分代码中要想进行消息传递，通知(notifacation)是非常好的一种机制，它可以对消息进行广播。特别是想要传递丰富的信息，并且不一定指望有谁对此消息关心。</p>

<p>通知可以用来发送任意的消息，甚至包含一个userInfo字典，或者是NSNotifacation的一个子类。通知的独特之处就在于发送者和接收者双方并不需要相互知道。这样就可以在非常松耦合的模块间进行消息的传递。记住，这种消息传递机制是单向的，作为接收者是不可以回复消息的。</p>

<h5>delegation</h5>

<p>在苹果的Framework中，delegation模式被广泛的只用着。delegation允许我们定制某个对象的行为，并且可以收到某些确定的事件。为了使用delegation模式，消息的发送者需要知道消息的接收者(delegate)，反过来就不用了。这里的发送者和接收者是比较松耦合的，因为发送者只知道它的delegate是遵循某个特定的协议。
delegate协议可以定义任意的方法，因此你可以准确的定义出你所需要的类型。你可以用函数参数的形式来处理消息内容，delegate还可以通过返回值的形式给发送者做出回应。如果只需要在相对接近的两个模块之间进行消息传递，那么Delegation是一种非常灵活和直接方式。</p>

<p>不过，过渡使用delegation也有一定的风险，如果两个对象的耦合程度比较紧密，相互之间不能独立存在，那么此时就没有必要使用delegate协议了，针对这种情况，对象之间可以知道相互间的类型，进而直接进行消息传递。例如UICollectionViewLayout和NSURLSessionConfiguration。</p>

<h5>block</h5>

<p>Block相对来说，是一种比较新的技术，它首次出现是在OS X 10.6和iOS 4中。一般情况下，block可以满足用delegation实现的消息传递机制。不过这两种机制都有各自的需求和优势。
当不考虑使用block时，一般主要是考虑到block极易引起retain环。如果发送者需要reatain block，而又不能确保这个引用什么时候被nil，这样就会发生潜在的retain环。
假设我们想要实现一个table view，使用block替代delegate，来当做selection的回调，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.myTableView.selectionHandler = ^void(NSIndexPath *selectedIndexPath) {
</span><span class='line'>    // handle selection ...
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>上面代码的问题在于self retain了table view，而table view为了之后能够使用block，进而 retain了block。而table view又不能把这个引用nil掉，因为它不知道什么时候不在需要这个block了。如果我们保证不了可以打破这个retain环，而我们又需要retain发送者，此时block不是好的选择。
NSOperation就可以很好的使用block，因为它能再某个时机打破retain环：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.queue = [[NSOperationQueue alloc] init];
</span><span class='line'>MyOperation *operation = [[MyOperation alloc] init];
</span><span class='line'>operation.completionBlock = ^{
</span><span class='line'>    [self finishedOperation];
</span><span class='line'>};
</span><span class='line'>[self.queue addOperation:operation];</span></code></pre></td></tr></table></div></figure>


<p>乍一看这似乎是一个retain环：self retain了queue，queue retain了operation，而operation retain了completion block，而completion blockretain了self。不过，在这里，将operation添加到queue时，会使operation在某个时机被执行，然后从queue中remove掉（如果没有被执行，就会有大问题了）。一单queue移除了operation之后，retain环就被打破了。</p>

<p>再来一个示例：这里实现了一个视频编码器的类，里面有一个名为encodeWithCompletionHandler:的方法。为了避免出现retain环，我们需要确保编码器这个对象能够在某个时机nil掉其对block的引用。其内部代码如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Encoder ()
</span><span class='line'>@property (nonatomic, copy) void (^completionHandler)();
</span><span class='line'>@end
</span><span class='line'>@implementation Encoder
</span><span class='line'>- (void)encodeWithCompletionHandler:(void (^)())handler
</span><span class='line'>{
</span><span class='line'>    self.completionHandler = handler;
</span><span class='line'>    // do the asynchronous processing...
</span><span class='line'>}
</span><span class='line'>// This one will be called once the job is done
</span><span class='line'>- (void)finishedEncoding
</span><span class='line'>{
</span><span class='line'>    self.completionHandler();
</span><span class='line'>    self.completionHandler = nil; // &lt;- Don't forget this!
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，一旦编码任务完成，就会调用complietion block，进而把引用nil掉。
如果我们发送的消息属于一次性的(具体到某个方法的调用)，由于这样可以打破潜在的retain环，那么使用block是非常不错的选择。另外，如果为了让代码可读性更强，更有连贯性，那最好是使用block了。根据这个思路，block经常可以用于completion handler、error handler等。</p>

<h5>Target-Action</h5>

<p>Target-Action主要被用于响应用户界面事件时所需要传递的消息中。iOS中的UIControl和Mac中的NSControl/NSCell都支持这种机制。Target-Action在消息的发送者和接收者之间建立了一个非常松散耦合。消息的接收者不知道发送者，甚至消息的发送者不需要预先知道消息的接收者。如果target是nil，action会在响应链(responder chain)中被传递，知道找到某个能够响应该aciton的对象。在iOS中，每个控件都能关联多个target-action。</p>

<p>基于target-action消息传递的机制有一个局限就是发送的消息不能携带自定义的payload。在Mac的action方法中，接收者总是被放在第一个参数中。而在iOS中，可以选择性的将发送者和和触发action的事件作为参数。除此之外，没有别的办法可以对发送action消息内容做控制。</p>

<p><a name="做出正确的选择" id="02"></a></p>

<h4>做出正确的选择</h4>

<p>根据上面讨论的结果，这里我画了一个流程图，来帮助我们何时使用什么消息传递机制做出更好的决定。忠告：流程图中的建议并非最终的答案；可能还有别的选项依然能实现目的。只不过大多数情况下此图可以引导你做出正确的决定。</p>

<p><img src="http://beyondvincent.com/images/2013/12/2.png" alt="id1" /></p>

<p>上图中，还有一些细节需要做更近一步的解释：</p>

<p>上图中的有个盒子这样说到：sender is KVO compliant(发送者支持compliant)。这不仅以意味着当值发生改变时，发送者会发送KVO通知，并且观察者还需要知道发送者的生命周期。如果发送者被存储在一个weak属性中，那么发送者有可能被nil掉，进而引起观察者发生leak。</p>

<p>另外底部的一个盒子说到：message is direct response to method call(消息直接在方法的调用代码中响应)。也就是说处理消息的代码跟方法的调用代码处于相同的地方。</p>

<p>最后，在左下角，处于一个决策问题的判断状态：sender can guarantee to nil out reference to block?(发送者能够确保nil掉到block的引用吗？)，这实际上涉及到之前我们讨论到基于block 的APIs已经潜在的retain环。使用block时，如果发送者不能保证在某个实际能够把对block的引用nil掉，那么将会遇到retain环的问题。</p>

<p><a name="Framework示例" id="03"></a></p>

<h4>Framework示例</h4>

<p>本节我们通过一些来自苹果Framework的示例，来看看在实际使用某种机制之前，苹果是处于何种原因做出选择的。</p>

<h5>KVO</h5>

<p>NSOperationQueue就是lion给了KVO来观察队列中operation状态属性的改变情况(isFinished, isExecuting, isCancelled)。当状态发生了改变，队列会受到一个KVO通知。为什么operationqueue要是用KVO呢？</p>

<p>消息的接收者(operation queue)明确的知道发送者(opertation)，以及通过retain来控制operation的生命周期。另外，在这种情况下，只需要单向的消息传递机制。当然，如果这样考虑：如果operation queue只关心operation值的改变情况，可能还不足以说服大家使用KVO。但是我们至少可以这样理解：什么机制可以对值的改变进行消息传递呢。</p>

<p><img src="http://beyondvincent.com/images/2013/12/3.png" alt="id2" /></p>

<p>当然KVO也不是唯一的选择。我们可以这样设计：operation queue作为operation的delegate，operation会调用类似operationDidFinish: 或 operationDidBeginExecuting: 这样的方法，来将它的state传递给queue。这样一来，就不太方便了，因为operation需要将其state属性保存下来，一遍调用这些delegate方法。另外，由于queue不能主动获取state信息，所以queue也必须保存着所有operation的state。</p>

<h5>Notifications</h5>

<p>Core Data使用notification来传递事件(例如一个managed object context内部的改变——NSManagedObjectContextDidChangeNotification)。</p>

<p>change notification是由managed object context发出的，所以我们不能确定消息的接收者一定知道发送者。如果消息并不是一个UI事件，而有可能多个接收者对该消息感兴趣，并且消息的传递属于单向(one-way communication channel)，那么notification是最佳选择。</p>

<p><img src="http://beyondvincent.com/images/2013/12/4.png" alt="id3" /></p>

<h5>Delegation</h5>

<p>Table view的delegate有多种功能，从accessory view的管理，到屏幕中cell显示的跟踪，都与delegate的功劳。例如，我们来看看 tableView:didSelectRowAtIndexPath: 方法。为什么要以delegate调用的方式来实现？而又为啥不用target-action方式？</p>

<p>正如我们在流程图中看到的一样，使用target-action时，不能传递自定义的数据。而在选中table view的某个cell时，collection view不仅仅需要告诉我们有一个cell被选中了，还需要告诉我们是哪个cell被选中了(index path)。按照这样的一种思路，那么从流程图中可以看到应该使用delegation机制。</p>

<p><img src="http://beyondvincent.com/images/2013/12/5.png" alt="id4" /></p>

<p>如果消息传递中，不包含选中cell的index path，而是每当选中项改变时，我们主动去table view中获取到选中cell的相关信息，会怎样呢？其实这会非常的麻烦，因为这样一来，我们就必须记住当前选中项相关数据，以便获知被选中的cell。</p>

<p>同理，虽然我们也可以通过观察table view中选中项的index paths属性值，当该值发生改变时，获得一个选中项改变的通知。不过，我们会遇到与上面同样的问题：不做任何记录的话，我们如何获知被选中项的相关信息。</p>

<h5>Blocks</h5>

<p>关于block的介绍，我们来看看[NSURLSession dataTaskWithURL:completionHandler:]吧。从URL loading system返回到调用者，这个过程具体是如何传递消息的呢？首先，作为这个API的调用者，我们知道消息的发送者，但是我们并没有retain这个发送者。另外，这属于单向消息传递——直接调用dataTaskWithURL:方法。如果按照这样的思路对照着流程图，我们会发现应该使用基于block消息传递的机制。</p>

<p><img src="http://beyondvincent.com/images/2013/12/6.png" alt="id5" /></p>

<p>还有其它可选的机制吗？当然有了，苹果自己的NSURLConnection就是最好的例子。NSURLConnection在block问世之前就已经存在了，所以它并没有利用block进行消息传递，而是使用delegation机制。当block出现之后，苹果在NSURLConnection中添加了sendAsynchronousRequest:queue:completionHandler:方法(OSX 10.7 iOS 5)，因此如果是简单的task，就不必在使用delegate了。</p>

<p>在OS X 10.9 和 iOS 7中，苹果引入了一个非常modern的API：NSURLSession，其中使用block当做消息传递机制(NSURLSession仍然有一个delegate，不过是用于别的目的)。</p>

<h5>Target-Action</h5>

<p>Target-Action用的最明显的一个地方就是button(按钮)。button除了需要发送一个click事件以外，并不需要再发送别的信息了。所以Target-Action在用户界面事件传递过程中，是最佳的选择。</p>

<p><img src="http://beyondvincent.com/images/2013/12/7.png" alt="id6" /></p>

<p>如果taget已经明确指定了，那么action消息回直接发送给指定的对象。如果taget是nil，action消息会以冒泡的方式在响应链中查找一个能够处理该消息的对象。此时，我们拥有一种完全解耦的消息传递机制——发送者不需要知道接收者，以及其它一些信息。</p>

<p>Target-Action非常适用于用户界面中的事件。目前也没有其它合适的消息传递机制能够提供同样的功能。虽然notification最接近这种在发送者和接收者解耦关系，但是target-action可以用于响应链(responder chain)——只有一个对象获得action并作出响应，并且action可以在响应链中传递，直到遇到能够响应该action的对象。</p>

<p><a name="小结" id="04"></a></p>

<h4>小结</h4>

<p>首次接触这些机制，感觉它们都能用于两个对象间的消息传递。但是仔细琢磨一番，会发现它们各自有其需求和功能。</p>

<p>文中给出的决策流程图可以为我们选择使用何种机制提供参考，不过图中给出的方案并不是最终答案，好多地方还需要亲自去实践。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac系统终端命令行设置自动关机/重启/睡眠]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/13/macxi-tong-zhong-duan-ming-ling-xing-she-zhi-zi-dong-guan-ji-slash-zhong-qi-slash-shui-mian/"/>
    <updated>2015-02-13T14:33:03+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/13/macxi-tong-zhong-duan-ming-ling-xing-she-zhi-zi-dong-guan-ji-slash-zhong-qi-slash-shui-mian</id>
    <content type="html"><![CDATA[<h3>mac设定定时关机/重启/睡眠，可以用终端命令来解决</h3>

<p>命令的主体主要是 Shutdown，h/r/s 分别代表关机/重启/睡眠，然后在后面加上执行时间(yymmddhhmm)即可。</p>

<h6>设定2013年11月4日14:10分关机：</h6>

<pre><code>sudo shutdown -h 1311041410
</code></pre>

<p>也可以</p>

<pre><code>sudo shutdown -h 14:10
</code></pre>

<h6>设定2013年11月4日14:10分重启：</h6>

<pre><code>    sudo shutdown -r 1311041410
</code></pre>

<p>也可以</p>

<pre><code>sudo reboot 
</code></pre>

<p>或者</p>

<pre><code>sudo shutdown -r now
</code></pre>

<h6>设定2013年11月4日14:10分睡眠：</h6>

<pre><code>sudo shutdown -s 1311041410
</code></pre>

<h6>如果想要立即关机/重启/睡眠，可以执行命令：</h6>

<pre><code>sudo halt
</code></pre>

<p>或者</p>

<pre><code>sudo shutdown -h now
</code></pre>

<p>now也可以适用于重启和睡眠。</p>

<h3>临时取消定时关机/睡眠/重启的方法也很简单</h3>

<p>我们在终端中执行了关机的命令，终端中会显示如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>swplzj:~ issuser$ sudo shutdown -s 1311041410
</span><span class='line'>Shutdown at Mon Nov  4 14:10:00 2013.
</span><span class='line'>shutdown: [pid 6609]</span></code></pre></td></tr></table></div></figure>


<p>注意上面的 pid 6609，这是指当前运行的这个 shutdown 命令的进程号，如果要取消关机，只需要停止这个进程的运行就可以了。</p>

<p>命令为：</p>

<pre><code>sudo kill 6609
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac 计算代码的总行数]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/13/mac-ji-suan-dai-ma-de-zong-xing-shu/"/>
    <updated>2015-02-13T14:31:37+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/13/mac-ji-suan-dai-ma-de-zong-xing-shu</id>
    <content type="html"><![CDATA[<p>计算代码的行数</p>

<p>在终端上的命令，作用：找到项目的根目录，可以计算出代码的行数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>find . -name "*.m" -or -name "*.h" |xargs grep -v "^$"|wc -l
</span><span class='line'>grep -v "^$"是去掉空行
</span><span class='line'>find . "(" -name "*.m" -or -name "*.strings" -or -name "*.h" ")" -print | xargs wc -l</span></code></pre></td></tr></table></div></figure>


<p>赶快试一试吧，看看你的代码量是多少！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS mac终端下的SQL语句]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/13/ios-maczhong-duan-xia-de-sqlyu-ju/"/>
    <updated>2015-02-13T14:18:47+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/13/ios-maczhong-duan-xia-de-sqlyu-ju</id>
    <content type="html"><![CDATA[<p>我们都知道数据库的创建可以借助图形化的数据库工具软件，但也可以在Mac终端下来直接使用代码创建。
下面介绍怎样建立数据库、建立资料表、建立索引、数据的增、删、改、查以及sqlite3命令列选项等。</p>

<!--more-->


<h5>建立数据库档案</h5>

<p>打开终端，在终端用sqlite3建立数据库，在shell下键入（以下$符号为shell提示号，请勿键入）：</p>

<pre><code>$ sqlite3 foo.db
</code></pre>

<p>如果目录下没有foo.db，sqlite3就会建立这个数据库。</p>

<p>sqlite3并没有强制数据库档名要怎么取，因此如果你喜欢，也可以取个例如foo.icannameitwhateverilike的档名。</p>

<p>在sqlite3提示列下操作
进入了sqlite3之后，会看到以下文字：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SQLite version 3.1.3
</span><span class='line'>Enter ".help" for instructions
</span><span class='line'>sqlite&gt; </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这时如果使用.help可以取得求助，.quit则是离开（请注意：不是quit）</p>

<h5>SQL的指令格式</h5>

<p>所有的SQL指令都是以分号（;）结尾的。如果遇到两个减号（&ndash;）则代表注解，sqlite3会略过去。</p>

<h4>建立资料表</h4>

<p>假设我们要建一个名叫film的资料表，只要键入以下指令就可以了：</p>

<pre><code>create table film(title, length, year, starring);
</code></pre>

<p>这样我们就建立了一个名叫film的资料表，里面有name、length、year、starring四个字段。
这个create table指令的语法为：</p>

<pre><code>create table table_name(field1, field2, field3, ...);
</code></pre>

<p>table_name是资料表的名称，fieldx则是字段的名字。</p>

<p>sqlite3与许多SQL数据库软件不同的是，它不在乎字段属于哪一种资料型态：sqlite3的字段可以储存任何东西：文字、数字、大量文字（blub），它会在适时自动转换。</p>

<h4>建立索引</h4>

<p>如果资料表有相当多的资料，我们便会建立索引来加快速度。好比说：</p>

<pre><code>create index film_title_index on film(title);
</code></pre>

<p>意思是针对film资料表的name字段，建立一个名叫film_name_index的索引。这个指令的语法为</p>

<pre><code>create index index_name on table_name(field_to_be_indexed);
</code></pre>

<p>一旦建立了索引，sqlite3会在针对该字段作查询时，自动使用该索引。这一切的操作都是在幕后自动发生的，无须使用者特别指令。</p>

<h4>增加数据</h4>

<p>接下来我们要插入数据了，加入的方法为使用insert into指令，语法为：</p>

<pre><code>insert into table_name values(data1, data2, data3, ...);
</code></pre>

<p>例如我们可以加入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>insert into film values ('Silence of the Lambs, The', 118, 1991, 'Jodie Foster');
</span><span class='line'>insert into film values ('Contact', 153, 1997, 'Jodie Foster');
</span><span class='line'>insert into film values ('Crouching Tiger, Hidden Dragon', 120, 2000, 'Yun-Fat Chow');
</span><span class='line'>insert into film values ('Hours, The', 114, 2002, 'Nicole Kidman');</span></code></pre></td></tr></table></div></figure>


<p>如果该字段没有资料，我们可以填NULL。</p>

<h4>删除数据</h4>

<p>delete from film where year &lt; 1970;
就会删除所有年代早于1970年（不含）的电影了。</p>

<h4>更改数据</h4>

<p>了解select的用法非常重要，因为要在sqlite更改或删除一笔资料，也是靠同样的语法。
例如有一笔资料的名字打错了：</p>

<pre><code>update film set starring='Jodie Foster' where starring='Jodee Foster';
</code></pre>

<p>就会把主角字段里，被打成&#8217;Jodee Foster&#8217;的那笔（或多笔）资料，改回成Jodie Foster。</p>

<h4>查询数据</h4>

<p>讲到这里，我们终于要开始介绍SQL最强大的select指令了。我们首先简单介绍select的基本句型：</p>

<pre><code>select columns from table_name where expression;
</code></pre>

<p>最常见的用法，当然是倒出所有数据库的内容：</p>

<pre><code>select * from film;
</code></pre>

<p>如果资料太多了，我们或许会想限制笔数：</p>

<pre><code>select * from film limit 10;
</code></pre>

<p>或是照着电影年份来排列：</p>

<pre><code>select * from film order by year limit 10;
</code></pre>

<p>或是年份比较近的电影先列出来：</p>

<pre><code>select * from film order by year desc limit 10;
</code></pre>

<p>或是我们只想看电影名称跟年份：</p>

<pre><code>select title, year from film order by year desc limit 10;
</code></pre>

<p>查所有茱蒂佛斯特演过的电影：</p>

<pre><code>select * from film where starring='Jodie Foster';
</code></pre>

<p>查所有演员名字开头叫茱蒂的电影(&lsquo;%&rsquo; 符号便是 SQL 的万用字符）：</p>

<pre><code>select * from film where starring like 'Jodie%';
</code></pre>

<p>查所有演员名字以茱蒂开头、年份晚于1985年、年份晚的优先列出、最多十笔，只列出电影名称和年份：</p>

<pre><code>select title, year from film where starring like 'Jodie%' and year &gt;= 1985 order by year desc limit 10;
</code></pre>

<p>有时候我们只想知道数据库一共有多少笔资料：</p>

<pre><code>select count(*) from film;
</code></pre>

<p>有时候我们只想知道1985年以后的电影有几部：</p>

<pre><code>select count(*) from film where year &gt;= 1985;
</code></pre>

<p>其他sqlite的特别用法</p>

<p>sqlite可以在shell底下直接执行命令：</p>

<pre><code>sqlite3 film.db "select * from film;"
</code></pre>

<p>输出 HTML 表格：</p>

<pre><code>sqlite3 -html film.db "select * from film;"
</code></pre>

<p>将数据库「导出来」：</p>

<pre><code>sqlite3 film.db ".dump" &gt; output.sql
</code></pre>

<p>利用输出的资料，建立一个一模一样的数据库（加上以上指令，就是标准的SQL数据库备份了）：</p>

<pre><code>sqlite3 film.db &lt; output.sql
</code></pre>

<p>在大量插入资料时，你可能会需要先打这个指令：</p>

<pre><code>begin;
</code></pre>

<p>插入完资料后要记得打这个指令，资料才会写进数据库中：</p>

<pre><code>commit;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7 教程：浅析Text Kit]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/13/ios-7-jiao-cheng-:qian-xi-text-kit/"/>
    <updated>2015-02-13T12:00:06+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/13/ios-7-jiao-cheng-:qian-xi-text-kit</id>
    <content type="html"><![CDATA[<p>Text Kit是iOS 7中引入的一个新功能，非常值得开发者使用，下面先看看本文的目录结构：</p>

<p><a href="#08">      1. 什么是Text Kit    </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p><a href="#01">      2. Text Kit架构   </a> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p><a href="#02">      3. Text Kit特点   </a> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p><a href="#03">      4. Text Kit功能概述 </a> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p><a href="#04">      5. Text Kit中重要的一些对象 </a> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p><a href="#05">      6. Text Kit示例   </a> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p><a href="#06">      7. 小结   </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p><a href="#07">      8. 推荐Text Kit学习资源   </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<!--more-->


<p><a name="Text Kit架构" id="08""></a></p>

<h4>什么是Text Kit</h4>

<p>在iOS7中，苹果引入了<code>Text Kit</code>——Text Kit是一个快速而又现代化的文字排版和渲染引擎。Text Kit在UIKit framework中的定义了一些类和相关协议，它最主要的作用就是为程序提供文字排版和渲染的功能。在程序中，通过Text Kit可以对文字进行存储(store)、布局(lay out)，以及用最精细的排版方式(例如文字间距、换行和对齐等)来显示文本内容。
苹果引入Text Kit的目的并非要取代已有的Core Text，Core Text的主要作用也是用于文字的排版和渲染中，它是一种先进而又处于底层技术，如果我们需要将文本内容直接渲染到图形上下文(Graphics context)时，从性能和易用性来考虑，最佳方案就是使用Core Text。而如果我们直接利用苹果提供的一些控件(例如UITextView、UILabel和UITextField等)对文字进行排版，无疑就是借助于UIkit framework中Text Kit提供的API。</p>

<p><a name="Text Kit架构" id="01""></a></p>

<h4>Text Kit架构</h4>

<p>下面，我们通过图1(此图来自WWDC2013 Session 210)来了解一下Text Kit的架构。图1是基于iOS 7绘制的，从图中，我们可以看到Text Kit是基于Core Text构建的，它通过Core Text与Core Graphics进行交互。而UI控件(UILabel、UITextField和UITextView)则构建于Text Kit之上，可见这些文本控件可以利用Text Kit提供的API来对文字进行排版和渲染处理。
从图中我们也可以看到SDK提供的UIWebView是基于WebKit的，它不能使用Text Kit提供的功能。</p>

<p><img src="http://beyondvincent.com/images/2013/11/23.jpg" title="图1 Text Kit在iOS 7 SDK中的位置" alt="id1" /></p>

<p>我们再来看看图1中的相关组件在iOS6里面是如何对应的，如图2所示，可以看出在iOS 6中是没有Text Kit，并且UILabel、UIText和UITextView是基于String Drawing和WebKit构建的。其中String Drawing是与Core Graphics直接通讯。</p>

<p><img src="http://beyondvincent.com/images/2013/11/24.jpg" title="图2 在iOS 6中并没有Text Kit" alt="id2" /></p>

<p><a name="Text Kit特点" id="02"></a></p>

<h4>Text Kit特点</h4>

<p>从上面的介绍中，我们可以了解到Text Kit在UIKit中的作用非常重要。Text Kit在实际开发中具有如下特点：
在UI控件中Text Kit完全掌控着文字的排版和渲染
UITextView、UITextField和UILabel是构建于Text Kit之上的
能够与动画、UICollectionView和UITableView做到无缝集成
Text Kit具有这样一些能力：Subclassing、Delegation和Notifcation。</p>

<p><a name="Text Kit功能概述" id="03"></a></p>

<h4>Text Kit功能概述</h4>

<p>下面我们看看通过Text Kit，都能实现那些功能(这里列出了是一些常用和重要功能)：
对文字进行分页或多列排版
支持文字的换行、折叠和着色等处理
可以调整字与字之间的距离、行间距、文字大小、指定特定的字体
支持富文本编辑，可以自定义文字截断
支持凸版印刷效果(letterpress)
支持数据类型的检测(例如链接、附件等)
如图3，是利用Text Kit对文字做的分页排版</p>

<p><img src="http://beyondvincent.com/images/2013/11/25.jpg" title="图3 利用Text Kit做的分页排版效果" alt="id3" /></p>

<p>再看图4，是利用Text Kit做的换行处理，其中对某个路径范围做了排除。</p>

<p><img src="http://beyondvincent.com/images/2013/11/26.jpg" title="图4 利用Text Kit做的换行处理效果" alt="id4" /></p>

<p>再来看看利用Text Kit做的凸版印刷效果，如图5所示</p>

<p><img src="http://beyondvincent.com/images/2013/11/27.jpg" title="图5 利用Text Kit做的凸版印刷效果" alt="id5" /></p>

<p><a name="Text Kit中重要的一些对象" id="04"></a></p>

<h4>Text Kit中重要的一些对象</h4>

<p>下面我们来看看Text Kit中重要的几个对象。</p>

<p><img src="http://beyondvincent.com/images/2013/11/28.jpg" title="图6 Text Kit中重要的几个对象" alt="id6" /></p>

<p>如图6所示，Text Kit中主要有4个重要的对象。
Text View是用来显示文本内容的控件，主要包括UILabel、UITextView和UITextField。
Text containers对应着NSTextContainer类。NSTextContainer定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化NSTextContainer来创建别的一些形状，例如圆形、不规则的形状等。NSTextContainer不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素(例如图片，如图4所示)。
Layout manager对应着NSLayoutManager类。该类负责对文字进行编辑排版处理——通过将存储在NSTextStorage中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(glyphs)上，然后将字形排版到NSTextContainer定义的区域中。
Text storage对应着NSTextStorage类。该类定义了Text Kit扩展文本处理系统中的基本存储机制。NSTextStorage继承自NSmutableAttributedString，主要用来存储文本的字符和相关属性。另外，当NSTextStorage中的字符或属性发生了改变，会通知NSLayoutManager，进而做到文本内容的显示更新。
通常情况下，NSTextStorage、NSLayoutManager和NSTextContainer是一一对应的。如图7所示关系：</p>

<p><img src="http://beyondvincent.com/images/2013/11/29.jpg" title="图7 普通排版" alt="id7" /></p>

<p>当然，如果需要将文字显示为多列，或多页，可以按照如图8所示关系——使用多个NSTextContainer。</p>

<p><img src="http://beyondvincent.com/images/2013/11/30.jpg" title="图8 多页或者多列排版" alt="id8" /></p>

<p>如果针对不同的排版方式，则可以使用多个NSLayoutManager，如图9所示</p>

<p><img src="http://beyondvincent.com/images/2013/11/31.jpg" title="图9 不同的排版方式" alt="id9" /></p>

<p>如图10所示，通过形象的方式，对UITextView的组成做了分解。通常，我们在设备上只能看到最右边的文本显示界面，而内部的NSTextStorage、NSLayoutManager和NSTextContainer是看不出来的。通常由NSLayoutManager从NSTextStorage中读取出文本数据，然后根据一定的排版方式，将文本排版到NSTextContainer中，再由NSTextContainer结合UITextView将最终效果显示出来。</p>

<p><img src="http://beyondvincent.com/images/2013/11/32.jpg" title="图10 UITextView的分解" alt="id10" /></p>

<p><a name="Text Kit示例", id="05"></a></p>

<h4>Text Kit示例</h4>

<p>前面对Text Kit做了一些介绍，下面我们配合一个例子(图文排版)，来进一步加深对Text Kit的认识。具体实现步骤如下</p>

<ol>
<li>打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li>
<li>打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li>
<li>打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    
</span><span class='line'>    //创建一个平移手势对象，该对象可以调用imagePanned：方法
</span><span class='line'>    UIPanGestureRecognizer *panGes = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(imagePanned:)];
</span><span class='line'>    [self.imageView addGestureRecognizer:panGes];
</span><span class='line'>    
</span><span class='line'>    self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。</p>

<p>下面来看一下translatedBezierPath方法的实现，如下代码所示</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UIBezierPath *)translatedBezierPath
</span><span class='line'>{
</span><span class='line'>    CGRect butterflyImageRect = [self.textView convertRect:self.imageView.frame fromView:self.view];
</span><span class='line'>    UIBezierPath *newButterflyPath = [UIBezierPath bezierPathWithRect:butterflyImageRect];
</span><span class='line'>    
</span><span class='line'>    return newButterflyPath;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。
还记得第3步中创建的平移手势吗。里面有一个action需要实现imagePanned:，下面来看看这个方法的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)imagePanned:(id)sender
</span><span class='line'>{
</span><span class='line'>    if ([sender isKindOfClass:[UIPanGestureRecognizer class]]) {
</span><span class='line'>        UIPanGestureRecognizer *localSender = sender;
</span><span class='line'>        
</span><span class='line'>        if (localSender.state == UIGestureRecognizerStateBegan) {
</span><span class='line'>            self.gestureStartingPoint = [localSender translationInView:self.textView];
</span><span class='line'>            self.gestureStartingCenter = self.imageView.center;
</span><span class='line'>        } else if (localSender.state == UIGestureRecognizerStateChanged) {
</span><span class='line'>            CGPoint currentPoint = [localSender translationInView:self.textView];
</span><span class='line'>            
</span><span class='line'>            CGFloat distanceX = currentPoint.x - self.gestureStartingPoint.x;
</span><span class='line'>            CGFloat distanceY = currentPoint.y - self.gestureStartingPoint.y;
</span><span class='line'>            
</span><span class='line'>            CGPoint newCenter = self.gestureStartingCenter;
</span><span class='line'>            
</span><span class='line'>            newCenter.x += distanceX;
</span><span class='line'>            newCenter.y += distanceY;
</span><span class='line'>            
</span><span class='line'>            self.imageView.center = newCenter;
</span><span class='line'>            
</span><span class='line'>            self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]];
</span><span class='line'>        } else if (localSender.state == UIGestureRecognizerStateEnded) {
</span><span class='line'>            self.gestureStartingPoint = CGPointZero;
</span><span class='line'>            self.gestureStartingCenter = CGPointZero;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用translatedBezierPath方法重新计算了一下排除区域。</p>

<p>至此代码编写完毕，下面来运行程序，看看实际效果。如图11所示：</p>

<p><img src="http://beyondvincent.com/images/2013/11/33.gif" title="图11 运行效果" alt="id11" /></p>

<p><a name="小结" id="06"></a></p>

<h4>小结</h4>

<p>实际上，上面的示例，只是揭秘了Text Kit功能的冰山一角。从iOS7及以后的版本中，Text Kit在UIKit framework里面占据重要的地位，Text Kit在文字处理方面，具有非常强大的功能，并且开发者可以对Text Kit进行定制和扩展。据悉，苹果利用了2年的时间来开发Text Kit，相信这对许多开发者来说都是福音。</p>

<p><a name="推荐Text Kit学习资源" id="07"></a></p>

<h4>推荐Text Kit学习资源</h4>

<p>更多关于Text Kit的学习资料，请参考下面的内容：
wwdc视频:</p>

<ul>
<li><a href="https://developer.apple.com/videos/wwdc/2013/?include=210">Introducing Text Kit</a></li>
<li><a href="https://developer.apple.com/videos/wwdc/2013/?include=220">Advanced Text Layouts and Effects with Text Kit</a></li>
<li><a href="https://developer.apple.com/videos/wwdc/2013/?include=223">Using Fonts with Text Kit</a></li>
</ul>


<p>苹果官方参考文档：</p>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/TextAndWebiPhoneOS.pdf">Text Programming Guide for iOS.pdf</a></li>
<li>NSLayoutManager Class Reference for iOS.pdf</li>
<li>NSLayoutManagerDelegate Protocol Reference for iOS.pdf</li>
<li>NSTextContainer Class Reference for iOS.pdf</li>
<li>NSTextStorage Class Reference for iOS.pdf</li>
<li>NSTextStorageDelegate Protocol Reference for iOS.pdf</li>
</ul>


<p>苹果官方示例：</p>

<ul>
<li>IntroToTextKit</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 5中的Interface Builder更有利于团队协作开发]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/13/xcode-5zhong-de-interface-buildergeng-you-li-yu-tuan-dui-xie-zuo-kai-fa/"/>
    <updated>2015-02-13T11:30:59+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/13/xcode-5zhong-de-interface-buildergeng-you-li-yu-tuan-dui-xie-zuo-kai-fa</id>
    <content type="html"><![CDATA[<h4>小引</h4>

<p>在iOS开发中，开发者有各种理由选择用代码来构建界面，其中最多的理由就是Interface Builder绘制的代码不利于团队间协作(代码的可读性和合并)。虽然Interface Builder来绘制界面有诸多优势，但是由于致命的缺陷，许多开发团队不得不远离它，当然也有一些开发团队为了在协同开发时也使用IB来绘制界面，他们尽量确保同一时期只由一个人来操作某个xib文件，以此避免提交代码的时候需要合并xib文件。然而，在Xcode 5中，苹果的开发团队已经对xib文件格式做了大量的简化工作。本文就来简要的看看相关内容。</p>

<p>注：本文译自<a href="http://nilsou.com/blog/2013/08/07/xcode-5-finally-makes-interface-builder-a-viable-option-for-teams/">Xcode 5 Finally Makes Interface Builder a Viable Option for Teams</a></p>

<h4>目录</h4>

<ul>
<li>Xcode 4中xib文件的格式</li>
<li>Xcode 5中xib文件的格式</li>
<li>小结</li>
</ul>


<p>上周我将代码merge到我的working branch时，注意到以前没曾见过的提示：</p>

<p><img src="http://beyondvincent.com/images/2013/09/1.png" alt="id1" /></p>

<p>Git会自动合并xib文件！我在想，Xcode 5中肯定对xib文件的格式做了修改，所以我准备深入研究一下。
原来由Xcode 5生成的xib文件是一种全新的格式。看起来苹果这次对xib文件格式的变更将有助于开发团队开始考虑使用IB来绘制界面。</p>

<h5>* Xcode 4中xib文件的格式</h5>

<p>为了演示xib文件格式在Xcode 4和Xcode 5中的差异，我首先在Xcode 4中创建了一个新的xib文件，并添加了一些view进去：一个UIScrollView，该scrollview中包含一些UIButton、UILable和TextView等。</p>

<p><img src="http://beyondvincent.com/images/2013/09/2.png" title="xib" alt="id2" /></p>

<p>然后我在工程导航窗口中右键单击该文件，并选择<code>Open As &gt; Source Code</code>。下面的链接中是看到的内容：
<a href="https://gist.github.com/nilsou/6057457">Xcode 4生成的.xib文件</a>(需要点击“File suppressed. Click to show.”)</p>

<p>可以看到，这么简单的一个view居然有1108行代码！这太多了。</p>

<p>对开发者来说它的可读性非常的糟糕。这是开发者为什么不喜欢xib文件的主要原因(由此放弃使用interface builder)。</p>

<p>更糟糕的是这个xib文件的格式还具有不确定性。也就是说如果我在Interface Builder创建相同的UI界面，但是我们看到的文件内容并不是相同的。这就导致xib文件的合并非常的困难，甚至不可能进行合并。这事开发者不使用xib文件的另外一个重要原因。</p>

<h5>* Xcode 5中xib文件的格式</h5>

<p>接着，我在Xcode 5中打开同一个工程。当在Xcode 5中打开用Xcode 4创建的xib文件时，会提示将文件升级到新的格式。这里需要注意的是升级之后的文件只能在Xcode 5中打开，这种新格式的文件不能在老版本中的Xcode中打开。所以，如果是团队协作开发，那么升级的时候，需要确保所有的开发者都使用Xcode 5。</p>

<p><img src="http://beyondvincent.com/images/2013/09/3.png" alt="id3" /></p>

<p>我点击Upgrade，然后再次打开xib文件的source code，看看有什么变化。如下链接中所示：</p>

<p><a href="https://gist.github.com/nilsou/6057474">Xcode 5生成的.xib文件</a>(需要点击“File suppressed. Click to show.”)</p>

<p><code>133行</code>！这与Xcode 4中创建的xib文件相差约10倍。可见苹果的开发团队已经对xib文件格式做了大量的简化。</p>

<p>再看看里面的具体内容，可以看出它的可读性也加强了。xib文件中的源代码现在也能够反应出view的层次(Interface Builder左边看到的内容结构！)，等熟悉之后，开发者可以直接对这个xml代码进行编写。
最重要的一点，可以看出Xcode 5生成的xib文件内容源码位置是确定的。这非常利于文件的合并。</p>

<h4>小结</h4>

<p>这种新的格式带来的最大好处不仅仅是增强开发者对xib文件的可读性，另外在大多数情况下，git还可以对xib文件进行自动合并，不用开发者手动进行。</p>

<p>现在如果还有开发者告诉你他不想用xib文件，那么请把这篇文章发给他看看吧，我相信已经没有太多理由不使用xib文件了。</p>

<p>其实在Xcode 5中不仅对Interface Builder进行了改善，还有其它一些功能也做了改进，例如自动布局约束的设置已经没有以前痛苦了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS X常用命令行技巧]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/13/os-xchang-yong-ming-ling-xing-ji-qiao/"/>
    <updated>2015-02-13T10:28:13+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/13/os-xchang-yong-ming-ling-xing-ji-qiao</id>
    <content type="html"><![CDATA[<h1>OS X常用命令行技巧</h1>

<h4>用“caffeinate”来停用屏幕保护和休眠</h4>

<p>山狮（Mac OS X 10.8）引入的新功能caffeinate，它完全就是命令行版本的咖啡因（Caffeine），可以让你电脑保持精神。运行方法：</p>

<p>caffeinate -t 3600</p>

<p>其中， -t用来指定时间，单位是秒，所以上面的例子就是一个小时。</p>

<!--more-->


<h4>用pkgutil来释放PKG文件</h4>

<p>如果你只是想从pkg文件里面抓取一些文件出来而不想安装整个软件？那pkgutil最适合你不过了：</p>

<p>pkgutil &ndash;expand sample.pkg ~/Desktop/</p>

<p>当然，你需要把sample.pkg的名字改成对应你要释出的pkg包的名字，上面的例子会把整个pkg包解压到桌面。</p>

<h4>用“purge”来清理内存</h4>

<p>purge清理磁盘和内存的缓存，效果类似于重启电脑。虽然有人说这也就是个安慰剂，但是它的确会对那些不活动的进程的内存释放出来，当你机器的内存不够用的时候，它是可以起到加速作用的。</p>

<p>purge的用法非常简单：</p>

<p>purge</p>

<p>执行的过程中需要等一小会儿，之后各个进程的速度就会快起来啦！</p>

<p>（小编注：如果你机器内存很大，并且用不完，真的没有什么必要总执行这个命令，需要等那个时间不说，程序自己建立的一些缓存会因为这个命令重新构建，除非是你内存真的不够用了，否则得不偿失。）</p>

<h4>使用“open” 来启动同一个app的多个实例</h4>

<p>你可能已经知道你可以通过命令行里的open命令来启动电脑上的程序，但是你知道吗，其实可以再加上-n的选项来创建多个实例。而且这非常简单，你所需要做的只是：</p>

<p>open -n /Applications/Safari.app/</p>

<p>上面的例子会创建另外的Safari ，你可以根据你的需要来启动其他的程序，别忘了.app的后缀</p>

<h4>不通过App Store更新系统</h4>

<p>更新系统这样的事情，并不一定要麻烦App Store。你可以在命令行里直接搞定这个事情，而这也非常简单：</p>

<p>sudo softwareupdate -i -a</p>

<p>这个命令其实在Mac OS X系统中已经存在好多年了。所以各种版本都可以使用这种方法来更新系统。</p>

<p>列出来所有下载过的东西</p>

<p>我们都经历过这样的事情吧：之前下载了一个什么东西，但是忘记是从那里下载的了，或者记不清出它叫什么名字。不过还好，你很幸运，因为免疫服务（Quarantine Service）保存了一份你所有的下载内容的数据库，这样一来你就可以查询那个数据库来找到你想要的东西。可以通过sqlite3命令来实现：</p>

<p>sqlite3 ~/Library/Preferences/com.apple.LaunchServices.QuarantineEventsV* &lsquo;select LSQuarantineDataURLString from LSQuarantineEvent&rsquo; |more</p>

<h4>用“chflags”来隐藏文件和文件夹</h4>

<p>有什么想隐藏的文件或者文件见吗？用chflags命令就可以把任何文件或者文件夹从系统里面隐藏起来。对于文件和文件夹，使用方法都一样：</p>

<p>chflags hidden /path/to/file/or/folder/</p>

<p>幸好（或者但是）这样隐藏过的文件和文件夹依然可以通过ls看到，不过在Finder里面还是看不到的，除非你使用了nohidden选项之前，比如：</p>

<p>chflags nohidden /path/to/unhide/</p>

<p>这两种改变都是立即生效的。</p>

<h4>用拖拽的方式来自动写入文件</h4>

<p>要是你们在命令行里面还苦逼兮兮的写很长的文件路径，就有点太对不住自己了。因为Mac OS X里面可以通过拖拽的方式输入路径：</p>

<p>sudo vi (drag file here to print the full path)</p>

<p>无论在命令行上还是终端程序里面，都生效。</p>

<h4>创建加密的压缩包</h4>

<p>如果你想加密一个压缩包，其实不需要什么其他的软件，系统自己就可以完成：</p>

<p>zip -e protected.zip /file/to/protect/</p>

<p>如果没有-e就会创建一个普通的，没有密码的压缩包。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App在iTunes Connect里面的几种状态]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/12/appzai-itunes-connectli-mian-de-ji-chong-zhuang-tai/"/>
    <updated>2015-02-12T20:00:41+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/12/appzai-itunes-connectli-mian-de-ji-chong-zhuang-tai</id>
    <content type="html"><![CDATA[<h4>Waiting for Upload (Yellow)</h4>

<p>Appears when you’ve completed entering your metadata, however, you have not finished uploading your binary or have chosen to upload your binary at a later time. Your app must be in the Waiting For Upload state before you can deliver your binary through Application Loader.</p>

<!--more-->


<h4>Prepare for Upload (Yellow)</h4>

<p>Appears when you have created a new version, but you have not yet clicked the Ready to Submit Binary button. This state also indicates that you can now deliver your binary through Application Loader.</p>

<h4>Upload Received (Yellow)</h4>

<p>Appears when your binary has been received through Application Loader, but is still being processed by the iTunes Connect system.</p>

<h4>Invalid Binary (Red)</h4>

<p>Appears when a binary is received through Application Loader, has been processed, but your binary is invalid.  Examples of an invalid binary are: your binary icon does not meet our requirements, you have placed the payload directory at the wrong level in the .app wrapper, you attempted to use a non-increasing CFBundleVersion, etc.</p>

<h4>Missing Screenshot (Red)</h4>

<p>Appears when your app is missing a required screenshot for iPhone and iPod touch or iPad for your default language app or for your added localizations. At least one screenshot is required for both iPhone and iPod touch and for iPad if you are submitting a universal app.</p>

<h4>Waiting for Review (Yellow)</h4>

<p>Appears after you submit a new application or update and prior to the application being reviewed by Apple. This status means that your app has been added to the app review queue, but has not yet started the review process.</p>

<h4>Waiting For Export Compliance (Yellow)</h4>

<p>Appears when your CCATS is in review with Export Compliance.</p>

<h4>In Review (Yellow)</h4>

<p>Appears when we are reviewing your app prior to the application being approved or rejected. It takes time to review binaries so we appreciate your patience and ask that you allow sufficient time for the processing of your application.  When the status of your application is in review, you have the option to reject the binary you have submitted by clicking Reject Binary. This will remove your binary from the review queue and will allow for another update to be submitted. If you reject your binary, the status of your app will change to Developer Rejected and when your binary is re-submitted, the review process will start over from the beginning.</p>

<h4>Pending Contract (Yellow)</h4>

<p>Appears when your application has been reviewed and is Ready for Sale but your contracts are not yet in effect. You may check the progress of your contracts in iTunes Connect by clicking on the Contracts, Tax &amp; Banking information module.</p>

<h4>Pending Developer Release (Yellow)</h4>

<p>Appears when the version of your app has been approved by Apple and you have turned on the Version Release Control, but have not yet clicked Send Version Live. You should also see a pending action symbol on the version. Your version will remain in this state, and thus will not be live on the App Store until you click Send Version Live.</p>

<h4>Processing for App Store (Yellow)</h4>

<p>Appears when the version is being processed to go live on the App Store. Once the processing is complete, the version state will change to “Ready for Sale.” This is a temporary state (approx. 1 – 2 hours).</p>

<h4>Ready for Sale (Green)</h4>

<p>Appears once your application been approved and posted to the App Store. When your application is in this status, you have the option to remove it from the store by going to the Rights and Pricing page and removing all App Store territories.</p>

<h4>Rejected (Red)</h4>

<p>Appears when the binary has been rejected.</p>

<h4>Removed from Sale (Red)</h4>

<p>Appears when the binary has been removed from the App Store.</p>

<h4>Developer Rejected (Red)</h4>

<p>Appears when youʼve rejected the binary from the review process. Existing versions of your application on the App Store will not be affected by self-rejecting binaries in review.</p>

<p>Important: When you self-reject your binary, you lose your place in the review queue. Your binary will be placed at the end of the queue when you resubmit.</p>

<h4>Developer Removed from Sale (Red)</h4>

<p>Appears when you’ve removed your application from the App Store.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac版本cornerstone的无限期破解方法]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/12/macban-ben-cornerstonede-wu-xian-qi-po-jie-fang-fa/"/>
    <updated>2015-02-12T19:39:29+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/12/macban-ben-cornerstonede-wu-xian-qi-po-jie-fang-fa</id>
    <content type="html"><![CDATA[<p>CornerStone是个人非常喜欢的mac上的一款SVN客户端工具，官方提供了14天的免费试用（trail）版本。我们可以在此基础上提供无限期试用版本。</p>

<!--more-->


<h4>方法一：修改系统时间</h4>

<p>如果你从来没有安装过这个trail版本，直接把当前系统时间改成未来的某个时间。
比如2020年，然后安装，运行一次。之后退出程序，将系统时间还原。恭喜你，你已经破解完成了。</p>

<h4>方法二：如果你不幸已经安装并运行过软件，那就需要找到安装记录并删除它。</h4>

<p>步骤如下：
1，显示系统隐藏文件。
在终端（Terminal）中输入如下命令：defaults write ~/Library/Preferences/com.apple.finder AppleShowAllFiles -bool true
（true 改成 false 就可以不再显示隐藏文件）需要重启，然后在finder中就可以看到隐藏文件了。
2，打开~/Library/Preferences/ByHost下的GlobalPreferences.XXXX.plist文件，XXXX为一串 数字，删掉&#8221;com.zennaware.Cornerstone:2.0&#8221;这一行，然后保存。（如果安装了XCode，会自动打开plist文件，否则 就得自己找个plist文件工具了，比如PlistEdit）
3，就此，安装记录已经删除，然后请重复方法一的步骤。</p>

<h4>心得：</h4>

<p>对于这类不需要连接服务器进行验证的限期使用软件，都可以采用类似的方法破解。
1，软件必须要在系统中找一个地方存储安装信息。
2，在mac文件系统里找到这个地方。
3，删掉生成的时间记录。
4，重新运行。
难点在于第二步，具体以后再说了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在iOS上绘制自然的签名]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/12/zai-iosshang-hui-zhi-zi-ran-de-qian-ming/"/>
    <updated>2015-02-12T19:32:25+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/12/zai-iosshang-hui-zhi-zi-ran-de-qian-ming</id>
    <content type="html"><![CDATA[<p>这里有一篇很棒的文章写如何在Android上获取流畅的签名：<a href="http://corner.squareup.com/2012/07/smoother-signatures.html">Smoother Signatures</a>，但是我没有找到一篇是写在iOS上如何实现。那么，究竟怎么做才能在iOS设备上获取用户的签名呢？</p>

<!--more-->


<p>虽然我没有找到任何关于获取签名的文章，但是在App store上已经有了实现得很好的app。  <a href="http://fiftythree.com/paper">Paper by 53</a> 是一个画画的iPad应用程序，它拥有漂亮并且灵敏的画笔，这也是我所要追求的用户体验。</p>

<p>代码可以从这里得到： <a href="https://www.github.com/jharwig/SignatureDemo">SignatureDemo</a></p>

<h5>连点成线</h5>

<p><img src="http://img.my.csdn.net/uploads/201304/25/1366858755_4942.png" alt="id1" /></p>

<p>最简单得办法是，依次获取触摸点并且用直线把它们连起来。
在UIView子类的初始化方法中创建path和用于捕获触摸事件的gesture recongnizer .</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Create a path to connect lines
</span><span class='line'>path = [UIBezierPath bezierPath];
</span><span class='line'>
</span><span class='line'>// Capture touches
</span><span class='line'>UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];
</span><span class='line'>pan.maximumNumberOfTouches = pan.minimumNumberOfTouches = 1;
</span><span class='line'>[self addGestureRecognizer:pan];</span></code></pre></td></tr></table></div></figure>


<p>将捕获到的pan事件location数据依次加入到贝塞尔path中，连点成线。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)pan:(UIPanGestureRecognizer *)pan {
</span><span class='line'>    CGPoint currentPoint = [pan locationInView:self];
</span><span class='line'>
</span><span class='line'>    if (pan.state == UIGestureRecognizerStateBegan) {
</span><span class='line'>        [path moveToPoint:currentPoint];
</span><span class='line'>    } else if (pan.state == UIGestureRecognizerStateChanged)
</span><span class='line'>        [path addLineToPoint:currentPoint];
</span><span class='line'>
</span><span class='line'>    [self setNeedsDisplay];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>画出轨迹</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)drawRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    [[UIColor blackColor] setStroke];
</span><span class='line'>    [path stroke];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="http://img.my.csdn.net/uploads/201304/25/1366859967_1064.png" title="image" alt="id2" /></p>

<p>用这种方法画个字母J就暴露出一些问题了。
当签名速度较慢时，iOS可以捕获到足够的touch位置信息，让连接起来的直线看起来不那么明显。但是当手指移动速度很快时就有麻烦了。</p>

<p>在2012苹果开发者大会中介绍的 Building Advanced Gesture Recognizers 提到，可以用数学来解决这个问题。</p>

<h5>二次贝塞尔曲线</h5>

<p>我们需要用二次贝塞尔曲线去连接那些触摸点，而并非用直线，可以参考上面给出的苹果开发者大会视频（大约在42：15处）。连接二次贝塞尔曲线时，应把触摸点当作控制点，而取中点为对应的起点和终点。</p>

<p>添加二次贝塞尔曲线到之前的代码中，需要用到上一次的touch信息，所以我们增加一个实例变量来存储它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGPoint previousPoint;</span></code></pre></td></tr></table></div></figure>


<p>写一个计算2点中点的方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static CGPoint midpoint(CGPoint p0, CGPoint p1) {
</span><span class='line'>    return (CGPoint) {
</span><span class='line'>        (p0.x + p1.x) / 2.0,
</span><span class='line'>        (p0.y + p1.y) / 2.0
</span><span class='line'>    };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>更新手势处理，用二次贝塞尔曲线替换掉之前的直接连接处理</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)pan:(UIPanGestureRecognizer *)pan {
</span><span class='line'>    CGPoint currentPoint = [pan locationInView:self];
</span><span class='line'>    CGPoint midPoint = midpoint(previousPoint, currentPoint);
</span><span class='line'>
</span><span class='line'>    if (pan.state == UIGestureRecognizerStateBegan) {
</span><span class='line'>        [path moveToPoint:currentPoint];
</span><span class='line'>    } else if (pan.state == UIGestureRecognizerStateChanged) {
</span><span class='line'>        [path addQuadCurveToPoint:midPoint controlPoint:previousPoint];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    previousPoint = currentPoint;
</span><span class='line'>
</span><span class='line'>    [self setNeedsDisplay];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="http://img.my.csdn.net/uploads/201304/25/1366862268_4928.png" alt="id3" /></p>

<p>没有写很多代码，我们就看到了很大的改观。棱角不见了，但是作为签名似乎有点乏味。每一处曲线都是等宽的，和用一只真正的钢笔签出来的签名效果相违背。</p>

<h5>可变的笔刷宽度</h5>

<p>笔刷的宽度应该基于签名的速度而变化，这样的签名看起来才自然。UIPanGestureRecognizer 有一个 velocityInView 方法可以返回当前触摸点的速度。</p>

<p>为了画出变化的宽度，我改用OpenGL ES 曲面细分将笔刷转换成三角序列（OpenGL支持画线，但是iOS不支持绘制平滑的可变宽度的线条）。二次贝塞尔曲线点需要重新计算，但是这超出了这篇文章的讨论范畴，具体可以查看代码：github</p>

<p>用相邻的2个二次贝塞尔曲线点来说明一下，可以计算得到此两点差值表示的向量的垂直向量，并且设定其长度为当前厚度值的1/2（译者注：下图大括号部分包含2份1/2厚度值长度，故恰好为当前厚度），采用GL_TRIANGLE_STRIP的方式绘制三角序列，因此需要2个二次贝塞尔曲线点来确定一个含有2个三角形的矩形段。</p>

<p><img src="http://img.my.csdn.net/uploads/201304/25/1366864689_3366.png" alt="id4" /></p>

<p>这个例子，就是用二次贝塞尔曲线和速度控制笔刷厚度的方法画出来的签名，自然多了吧。</p>

<p><img src="http://img.my.csdn.net/uploads/201304/25/1366864895_3168.png" alt="id5" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac使用技巧]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/12/at-macshi-yong-ji-qiao/"/>
    <updated>2015-02-12T19:25:20+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/12/at-macshi-yong-ji-qiao</id>
    <content type="html"><![CDATA[<h5>1. [技巧]终端模式下用Finder打开当前目录</h5>

<p>方法如下</p>

<p>open .</p>

<h5>2.强制退出应用</h5>

<p>如果您无法从无响应的 app 进行切换，请按住 Command-Option-Shift-Esc 键三秒钟，以强制其退出。该组合键将命令 OS X 强制退出最前面的 app。</p>

<!--more-->


<h5>3.如何为 Mac OS X 启用 Root 账户?</h5>

<p>尽管 Apple 不推荐开启 Mac OS X 的 Root 账户，但有时会遇到一些操作上的麻烦不得不开启 Root 账户来解决。那么怎么开启 Mac OS X 的 Root 账户呢？</p>

<h6>开启 Root 账户</h6>

<p>打开“系统偏好设置”，进入“用户与群组”面板，记得把面板左下角的小锁打开，然后选择面板里的“登录选项”。在面板右边你会看到“网络账户服务器”，点击它旁边的“加入…”按钮，再点击弹出的窗口中“打开目录实用工具”。这时会弹出一个新窗口，把左下角的小锁打开，然后点击菜单栏上的“编辑” – “启用 Root 用户”，在弹出的窗口中设置 Root 的密码就可以了。</p>

<h6>如何为 OS X 启用 Root 账户?</h6>

<p>上面的步骤有些啰嗦，你可以在 Finder 中按组合键“shift + command + G”直接前往文件夹 /System/Library/CoreServices，在里面找到“目录实用工具”来开启 Root 账户。</p>

<p>启用之后，你可以注销系统然后用刚刚开启的 Root 帐号登录 Mac OS X 了。</p>

<h6>关闭 Root 账户</h6>

<p>Root 账户的权限系统中最高级别了，在我们日常生活中几乎用不到，为了避免发生各种安全问题，MacGG建议在用 Root 账户解决完问题后关闭 Root 账户。关闭的步骤跟上面差不多，只是在打开“目录实用工具”后，点击“编辑”菜单里的“停用 Root 用户”即可。</p>

<h5>4.同时按住 control + command + 电源键，这样也会强制关闭电脑，但好处是不会损坏系统文件。</h5>

<h5>5.[Mac]如何让 OS X 定时截图？</h5>

<pre><code>screencapture -t png -T 10 ~/Desktop/screenshot01.png
</code></pre>

<h5>6.[Mac]如何删除Mac系统里面的所有 DS_Store 文件呢？</h5>

<p>DS_Store (英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮文件夹的自定义属性，例如文件们的图标位置或者是背景色的选择等。</p>

<p>如何删除Mac系统里面的所有 DS_Store 文件呢？</p>

<p>启动“终端”，再/应用程序/工具文件夹中。
输入以下命令：</p>

<pre><code>sudo find / -name “.DS_Store” -depth -exec rm {} \;
</code></pre>

<p>接着输入你的管理员密码，这时你的 .DS_Store 全都没了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IOS5以上：设置控件全局显示样式《APPEARANCE PROXY》]]></title>
    <link href="http://swplzj.github.io/blog/2015/02/12/at-ios5yi-shang-:she-zhi-kong-jian-quan-ju-xian-shi-yang-shi-%3C%3C-appearance-proxy/"/>
    <updated>2015-02-12T18:34:41+08:00</updated>
    <id>http://swplzj.github.io/blog/2015/02/12/at-ios5yi-shang-:she-zhi-kong-jian-quan-ju-xian-shi-yang-shi-<<-appearance-proxy</id>
    <content type="html"><![CDATA[<p>Appearance是Apple在iOS5.0上加的一个协议，它让程序员可以很轻松地改变某控件的全局样式（背景）</p>

<pre><code> @selector(appearance)
</code></pre>

<p>支持UIAppearance协议的类可以访问appearance selector ,它为receiver返回appearance proxy，我们可以给proxy发一些消息，诸如setTintColor:等</p>

<p>但是它并不是支持所有的UI类。下面列出它支持的类</p>

<!--more-->


<p>   1.UIActivitiIndicatorView
　　 <br/>
　　2.UIBarButtonItem</p>

<p>　　3.UIBarItem</p>

<p>　　4.UINavgationBar</p>

<p>　　5.UIPopoverControll</p>

<p>　　6.UIProgressView</p>

<p>　　7.UISearchBar</p>

<p>　　8.UISegmentControll</p>

<p>　　9.UISlider</p>

<p>　　10.UISwitch</p>

<p>　　11.UITabBar</p>

<p>　　12.UITabBarItem</p>

<p>　　13.UIToolBar</p>

<p>　　14.UIView</p>

<p>　　15.UIViewController</p>

<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> [[UINavigationBar appearance] setTintColor：[UIColor blackColor]];
</span><span class='line'>
</span><span class='line'> [[UISearchBar appearance] setTintColor: [UIColor blackr]];
</span><span class='line'> ```
</span><span class='line'> 
</span><span class='line'>注意：
</span><span class='line'>
</span><span class='line'>初学者肯定会任意调用方法，大部分方法时无效的，如果调用时会抛出unknown selector 异常
</span><span class='line'>
</span><span class='line'>那么如何查看你调用的方法时有效的呢，我们可以在此类的头文件中查看包含“UI_APPEARANCE_SELECTOR”常量的方法。
</span><span class='line'>
</span><span class='line'>例如UIToolBar
</span><span class='line'>
</span><span class='line'>它支持下列方法
</span></code></pre></td></tr></table></div></figure>


<p>@property(nonatomic,retain) UIColor   *tintColor  UI_APPEARANCE_SELECTOR;</p>

<ul>
<li><p>(void)setBackgroundImage:(UIImage *)backgroundImage forToolbarPosition:(UIToolbarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;</p></li>
<li><p>(UIImage *)backgroundImageForToolbarPosition:(UIToolbarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;</p></li>
<li><p>(void)setShadowImage:(UIImage *)shadowImage forToolbarPosition:(UIToolbarPosition)topOrBottom NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</p></li>
<li><p>(UIImage *)shadowImageForToolbarPosition:(UIToolbarPosition)topOrBottom NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</p></li>
</ul>


<p>&#8220;`</p>

<p><a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UIAppearance_Protocol/Reference/Reference.html">了解更多请点击访问</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优秀开源项目：FACEBOOK PAPER动画引擎 – POP]]></title>
    <link href="http://swplzj.github.io/blog/2014/12/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop/"/>
    <updated>2014-12-14T19:02:27+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/12/14/you-xiu-kai-yuan-xiang-mu-facebook-paper-dong-hua-yin-qing-pop</id>
    <content type="html"><![CDATA[<p><img src="http://cc.cocimg.com/cms/uploads/allimg/140429/4196_140429142234_1.gif" alt="id1" /></p>

<p>Pop是一个适用于iOS和OS X平台的可扩展动画引擎，是一个成熟的经过多重测试的，可实现Facebook Paper中的所有动画和过渡效果。除了基本的静态动画，Pop还支持spring和decay动画，有助于打造一个逼真的，基于物理的交互。你可以通过Pop的API把Pop快速集成到现有的Objective-C代码库中，并在任何对象上实现动画的任何属性。</p>

<!--more-->


<p></p>

<h5>开始，停止以及更新</h5>

<p>开始动画–把它添加到你想要动画的对象上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animation]; 
</span><span class='line'>… 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"myKey"]; </span></code></pre></td></tr></table></div></figure>


<p>停止动画–把它从key在刚开始时指定的对象引用中移除。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[layer pop_removeAnimationForKey:@"myKey"]; 
</span><span class='line'>key可以用来查询现有的动画。更新运行中动画的toValue，为改变进程提供了很好的方式：
</span><span class='line'>anim = [layer pop_animationForKey:@"myKey"]; 
</span><span class='line'>if (anim) { 
</span><span class='line'>  /* update to value to new destination */ 
</span><span class='line'>  anim.toValue = @(42.0); 
</span><span class='line'>} else { 
</span><span class='line'>  /* create and start a new animation */ 
</span><span class='line'>  …. 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>虽然上述代码中使用了layer，但是Pop接口作为一个NSObject上附加类别执行。任何NSObject或者子类可以被动画。</p>

<h5>类型</h5>

<p>Pop有四个具体的动画类型：spring, decay, basic和custom
Spring动画可以用来给对象一个令人愉悦的弹跳效果。在这个例子中，我们用spring动画来动画一个层次的弹跳效果，从现有的值设定为(0, 0, 400, 400)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerBounds]; 
</span><span class='line'>anim.toValue = [NSValue valueWithCGRec 
</span><span class='line'>t:CGRectMake(0, 0, 400, 400)]; 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"size"]; </span></code></pre></td></tr></table></div></figure>


<p>Decay动画能用于逐渐减慢一个对象直至停止。在这个例子中，我们将layer的速率减小为每秒钟1000pts。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPDecayAnimation *anim = [POPDecayAnimation animationWithPropertyNamed:kPOPLayerPositionX]; 
</span><span class='line'>anim.velocity = @(1000.); 
</span><span class='line'>[layer pop_addAnimation:anim forKey:@"slide"]; </span></code></pre></td></tr></table></div></figure>


<p>基本动画能用于在指定的时间段插入值。使用一个淡入淡出动画在默认时间段将视图的透明度从0.0设置为1.0。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPBasicAnimation *anim = [POPBasicAnimation animationWithPropertyNamed:kPOPViewAlpha]; 
</span><span class='line'>anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; 
</span><span class='line'>anim.fromValue = @(0.0); 
</span><span class='line'>anim.toValue = @(1.0); 
</span><span class='line'>[view pop_addAnimation:anim forKey:@"slide"]; </span></code></pre></td></tr></table></div></figure>


<p>通过处理CADisplayLink和相关的time-step管理，POPCustomAnimation使创建自定义动画和过渡变得更加容易。更多详情请查看header。</p>

<h5>属性</h5>

<p>属性由POPAnimatableProperty类指定动画。在这个例子中，我们创建一个spring动画，明确地设置与-[CALayer bounds]一致的动画属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPSpringAnimation *anim = [POPSpringAnimation animation]; 
</span><span class='line'>anim.property = [POPAnimatableProperty propertyWithName:kPOPLayerBounds]; </span></code></pre></td></tr></table></div></figure>


<p>这个框架提供了很多常见的层以及额外的视图动画属性。你可以通过创建类的新实例来动画一个自定义属性。在这个例子中，我声明了一个自定义音量属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>prop = [POPAnimatableProperty propertyWithName:@"com.foo.radio.vo 
</span><span class='line'>lume" initializer:^(POPMutableAnimatableProperty *prop) { 
</span><span class='line'>  // read value 
</span><span class='line'>  prop.readBlock = ^(id obj, CGFloat values[]) { 
</span><span class='line'>    values[0] = [obj volume]; 
</span><span class='line'>  }; 
</span><span class='line'>  // write value 
</span><span class='line'>  prop.writeBlock = ^(id obj, const CGFloat values[]) { 
</span><span class='line'>    [obj setVolume:values[0]]; 
</span><span class='line'>  }; 
</span><span class='line'>  // dynamics threshold 
</span><span class='line'>  prop.threshold = 0.01; 
</span><span class='line'>}]; 
</span><span class='line'>anim.property = prop; </span></code></pre></td></tr></table></div></figure>


<p>关于动画属性的完整列表以及声明自定义属性的更多信息，请看POPAnimatableProperty.h。</p>

<h5>调试</h5>

<p>这里有一些关于调试的技巧。Pop遵循模拟器的Toggle Slow Animations设置。试着用它放慢动画，将能更容易查看交互。
考虑给你的动画命名。当你通过日志查看动画或者调试动画时，这将使你更容易识别它们。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>anim.name = @“springOpen”; </span></code></pre></td></tr></table></div></figure>


<p>每个动画都有一个关联的tracer，它以一种快速高效的方式允许你记录所有的动画相关事件，还允许你在动画完成后对其进行查询和分析。下边的例子展示启动和配置tracer，以记录所有动画事件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>POPAnimationTracer *tracer = anim.tracer; 
</span><span class='line'>tracer.shouldLogAndResetOnCompletion = YES; 
</span><span class='line'>[tracer start]; </span></code></pre></td></tr></table></div></figure>


<p>更多详情，请查看POPAnimationTracer.h。
假设已经安装了CocoaPods，这将在单元测试目标中包含必要的OCMock依赖。</p>

<h5>相关资源</h5>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html">Core Animation Programming Guide</a>
<a href="http://tapity.com/tutorial-getting-started-with-pop/">Tapity Tutorial – Getting Started with Pop</a>
<a href="https://github.com/facebook/tweaks">Tweaks – Easily adjust parameters for iOS apps in development</a>
<a href="http://facebook.github.io/rebound/">Rebound – Springs Animations for Android</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用神奇的PONYDEBUGGER调试iOS应用]]></title>
    <link href="http://swplzj.github.io/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong/"/>
    <updated>2014-12-14T17:30:40+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/12/14/shi-yong-shen-qi-de-ponydebugger-tiao-shi-ios-ying-yong</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>Debug算是开发者的基本技能之一吧，对于iOS开发者而言，可能会遇到如下一些debug需求：</p>

<p>调试网络请求问题
调试一个层次结构复杂的用户界面
查看应用内Core Data数据变化
虽然你可以通过NSLog日志，打断点，抑或LLDB的调试命令等一些常见手段来解决以上问题，但这些方式始终不够直观，效率也不高，特别是对于调试UI这个需求。要提高效率，我们可以使用一些第三方的调试工具，比如本文要介绍的PonyDebugger。</p>

<!--more-->


<h3>关于PonyDebugger</h3>

<p>PonyDebugger是Square开源的一个远程调试工具包，它可以通过Chrome开发者工具来调试iOS应用的网络流量，数据存储以及用户界面。</p>

<h3>安装和使用</h3>

<h4>服务端安装</h4>

<p>curl -sk <a href="https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py">https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py</a> | \ python - &ndash;ponyd-symlink=/usr/local/bin/ponyd ~/Library/PonyDebugger</p>

<p>安装时遇到的一些坑记录如下：</p>

<p>移动宽带下偶尔出现连接不上pypi的情况，使用电信宽带则正常，移动宽带用户可以改用国内的镜像地址，比如V2EX的pypi镜像<a href="http://pypi.v2ex.com/simple">http://pypi.v2ex.com/simple</a>
服务端依赖pybonjour，但是在zsh终端下使用pip安装会提示找不到这个包，需要手动安装，添加allow-external和allow-unverified
手动安装方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source ~/Library/PonyDebugger/bin/activate
</span><span class='line'>
</span><span class='line'>pip install -U -e git+https://github.com/square/PonyDebugger.git#egg=ponydebugger --allow-external pybonjour --allow-unverified pybonjour
</span><span class='line'>
</span><span class='line'>ponyd update-devtools</span></code></pre></td></tr></table></div></figure>


<h4>客户端安装</h4>

<p>使用CocoaPods，在PodFile中添加以下依赖：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'PonyDebugger', '~&gt; 0.3.1'</span></code></pre></td></tr></table></div></figure>


<p>也可以直接指向Github开源地址，这样可以随时使用最新版本的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'PonyDebugger', :git =&gt; 'https://github.com/square/PonyDebugger.git'</span></code></pre></td></tr></table></div></figure>


<h4>使用</h4>

<p>终端输入以下命令启动服务端，然后Chrome打开<a href="http://localhost:9000">http://localhost:9000</a> ，使用开发者工具即可进行调试</p>

<p>ponyd serve &ndash;listen-interface=127.0.0.1</p>

<p>为了便于随时开启和关闭PonyDebugger，客户端在Preprocessor Macros中定义了一个宏ENABLE_PONYDEBUGGER</p>

<p>在AppDeleagate的didFinishLaunchingWithOptions方法中使用如下代码进行一些初始化工作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if ENABLE_PONYDEBUGGER
</span><span class='line'>
</span><span class='line'>    PDDebugger *debugger = [PDDebugger defaultInstance];
</span><span class='line'>    
</span><span class='line'>    // Enable Network debugging, and automatically track network traffic that comes through any classes that NSURLConnectionDelegate methods.
</span><span class='line'>    [debugger enableNetworkTrafficDebugging];
</span><span class='line'>    [debugger forwardAllNetworkTraffic];
</span><span class='line'>    
</span><span class='line'>    // Enable Core Data debugging, and broadcast the main managed object context.
</span><span class='line'>    [debugger enableCoreDataDebugging];
</span><span class='line'>    [debugger addManagedObjectContext:self.managedObjectContext withName:@"Twitter Test MOC"];
</span><span class='line'>    
</span><span class='line'>    // Enable View Hierarchy debugging. This will swizzle UIView methods to monitor changes in the hierarchy
</span><span class='line'>    // Choose a few UIView key paths to display as attributes of the dom nodes
</span><span class='line'>    [debugger enableViewHierarchyDebugging];
</span><span class='line'>    [debugger setDisplayedViewAttributeKeyPaths:@[@"frame", @"hidden", @"alpha", @"opaque", @"accessibilityLabel", @"text"]];
</span><span class='line'>    
</span><span class='line'>    // Connect to a specific host
</span><span class='line'>    [debugger connectToURL:[NSURL URLWithString:@"ws://localhost:9000/device"]];
</span><span class='line'>    // Or auto connect via bonjour discovery
</span><span class='line'>    //[debugger autoConnect];
</span><span class='line'>    // Or to a specific ponyd bonjour service
</span><span class='line'>    //[debugger autoConnectToBonjourServiceNamed:@"MY PONY"];
</span><span class='line'>
</span><span class='line'>    // Enable remote logging to the DevTools Console via PDLog()/PDLogObjects().
</span><span class='line'>    [debugger enableRemoteLogging];
</span><span class='line'>    
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>Chrome看到网页显示如下说明连接成功：</p>

<p><img src="http://ww4.sinaimg.cn/large/674a21d2gw1eemkgp4t9rj216c0ea40f.jpg" alt="id1" /></p>

<p>点击网页中间的应用名即可跳转到debug工具</p>

<h4>实现原理</h4>

<p>简单看了一下PonyDebugger的源码，服务端使用Tornado框架提供WebSocket服务，客户端则是基于Square自家开源的SocketRocket，关于WebSocket相关的知识，可以参考我之前的这篇博文。</p>

<p>网络请求抓包功能是通过注入到NSURLConnectionDelegate中实现的，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)injectIntoAllNSURLConnectionDelegateClasses;
</span><span class='line'>{
</span><span class='line'>    // Only allow swizzling once.
</span><span class='line'>    static BOOL swizzled = NO;
</span><span class='line'>    if (swizzled) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    swizzled = YES;
</span><span class='line'>
</span><span class='line'>    // Swizzle any classes that implement one of these selectors.
</span><span class='line'>    const SEL selectors[] = {
</span><span class='line'>        @selector(connectionDidFinishLoading:),
</span><span class='line'>        @selector(connection:didReceiveResponse:)
</span><span class='line'>    };
</span><span class='line'>    
</span><span class='line'>    const int numSelectors = sizeof(selectors) / sizeof(SEL);
</span><span class='line'>
</span><span class='line'>    Class *classes = NULL;
</span><span class='line'>    NSInteger numClasses = objc_getClassList(NULL, 0);
</span><span class='line'>    
</span><span class='line'>    if (numClasses &gt; 0) {
</span><span class='line'>        classes = (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);
</span><span class='line'>        numClasses = objc_getClassList(classes, numClasses);
</span><span class='line'>        for (NSInteger classIndex = 0; classIndex &lt; numClasses; ++classIndex) {
</span><span class='line'>            Class class = classes[classIndex];
</span><span class='line'>            
</span><span class='line'>            if (class_getClassMethod(class, @selector(isSubclassOfClass:)) == NULL) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            if (![class isSubclassOfClass:[NSObject class]]) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            if ([class isSubclassOfClass:[PDNetworkDomainController class]]) {
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>            for (int selectorIndex = 0; selectorIndex &lt; numSelectors; ++selectorIndex) {
</span><span class='line'>                if ([class instancesRespondToSelector:selectors[selectorIndex]]) {
</span><span class='line'>                    [self injectIntoDelegateClass:class];
</span><span class='line'>                    break;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        free(classes);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从这个实现也可以发现，像ASIHttpRequest这样的直接基于底层CFNetwork封装的库，以及iOS 7中新引入的NSURLSession都是无法抓到请求包的，这种情况下如果需要抓包就只能使用Charles这类工具了。</p>

<p>调试视图功能调用了一些runtime的私有API，部分代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)startMonitoringUIViewChanges;
</span><span class='line'>{
</span><span class='line'>    // Swizzle UIView add/remove methods to monitor changes in the view hierarchy
</span><span class='line'>    // Only do it once to avoid swapping back if this method is called again
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        Method original, swizzle;
</span><span class='line'>        Class viewClass = [UIView class];
</span><span class='line'>
</span><span class='line'>        // Using sel_registerName() because compiler complains about the swizzled selectors not being found.
</span><span class='line'>        original = class_getInstanceMethod(viewClass, @selector(addSubview:));
</span><span class='line'>        swizzle = class_getInstanceMethod(viewClass, sel_registerName("pd_swizzled_addSubview:"));
</span><span class='line'>        method_exchangeImplementations(original, swizzle);
</span><span class='line'>        
</span><span class='line'>        ···
</span><span class='line'>                  
</span><span class='line'>        original = class_getInstanceMethod(viewClass, @selector(exchangeSubviewAtIndex:withSubviewAtIndex:));
</span><span class='line'>        swizzle = class_getInstanceMethod(viewClass, sel_registerName("pd_swizzled_exchangeSubviewAtIndex:withSubviewAtIndex:"));
</span><span class='line'>        method_exchangeImplementations(original, swizzle);
</span><span class='line'>    });
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这部分可以看到是通过Method Swizzling来动态交换了UIView的方法实现，以addSubview为例，替换成了pd_swizzled_addSubview，至于pd_swizzled_addSubview的实现请看下面</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)pd_swizzled_addSubview:(UIView *)subview;
</span><span class='line'>{
</span><span class='line'>    [[PDDOMDomainController defaultInstance] removeView:subview];
</span><span class='line'>    [self pd_swizzled_addSubview:subview];
</span><span class='line'>    [[PDDOMDomainController defaultInstance] addView:subview];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>替换后的removeView和addView方法都是重新实现的，里面会将UIView的变动以DOM形式写到PDDOMDomain对象中输出。</p>

<p>除了以上两个主要功能，还有Core Data远程调试，日志远程输出等功能，其实现方式大同小异，就不一一赘述了。</p>

<p>总的来说，PonyDebugger的功能还是十分强大的，也能够有效地提高开发者的调试效率，有类似需求的很值得一试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解 OBJECTIVE-C RUNTIME]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/21/li-jie-objective-c-runtime/"/>
    <updated>2014-09-21T21:34:12+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/21/li-jie-objective-c-runtime</id>
    <content type="html"><![CDATA[<p>当人们初学 Cocoa/Objective-C 时，Objective-C Runtime 是被忽略的特性之一。原因是 Objective-C（这门语言）很容易在几小时内就熟悉，新学 Cocoa 的人花费他们大部分的时间学习 Cocoa 框架和适应它是如何工作的。然而每个人至少应该知道一些 runtime 的工作细节，需要比知道编译器会把 [target doMethodWith:var1]; 转换为 objc_msgSend(target,@selector(doMethodWith:),var1); 更深入一些。知道 Objective-C 正在做的会让你更深入的理解 Objective-C 和你正在运行的 app。我认为 Mac/iPhone 的开发者不管你现在是什么水平，都会有收获的。</p>

<!--more-->


<h4>Objective-C Runtime 是开源的</h4>

<p>Objective-C 是开源的，任何时候你都能从 <a href="http://opensource.apple.com.">http://opensource.apple.com.</a> 获取。事实上查看 Objective-C 源码是我理解它是如何工作的第一种方式，在这个问题上要比读苹果的文档要好。你可以下载适合 Mac OS X 10.6.2 的 objc4-437.1.tar.gz。（译注：最新objc4-551.1.tar.gz）</p>

<h4>动态 vs 静态语言</h4>

<p>Objective-C 是面相运行时的语言（runtime oriented language），就是说它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。这就给了你很大的灵活性，你可以按需要把消息重定向给合适的对象，你甚至可以交换方法的实现，等等（译注：在 Objective-C 中调用一个对象的方法可以看成向一个对象发送消息, Method Swizzling 具体实现可以参看 jrswizzle ）。这就需要使用 runtime，runtime 可以做对象自省查看他们正在做的和不能做的（don’t respond to）并且合适的分发消息（译注：感兴趣的同学可以查看 NSObject 类的 – forwardingTargetForSelector: 和 – forwardInvocation: 方法。P.S. 不是 NSObject 协议！ ）。如果我们和 C 这样的语言对比。在 C 里，你从 main() 方法开始写然后就是从上到下的写逻辑了并按你写代码的顺序执行程序。一个 C 的结构体不能转发函数执行请求到其他的目标上（other targets）。很可能你的程序是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt; stdio.h &gt;
</span><span class='line'>int main(int argc, const char **argv[])
</span><span class='line'>{        
</span><span class='line'>    printf("Hello World!");
</span><span class='line'>    return 0;
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>编译器解析，优化然后把优化后的代码转成汇编：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.text
</span><span class='line'> .align 4,0x90
</span><span class='line'> .globl _main
</span><span class='line'>_main:
</span><span class='line'>Leh_func_begin1:
</span><span class='line'> pushq %rbp
</span><span class='line'>Llabel1:
</span><span class='line'> movq %rsp, %rbp
</span><span class='line'>Llabel2:
</span><span class='line'> subq $16, %rsp
</span><span class='line'>Llabel3:
</span><span class='line'> movq %rsi, %rax
</span><span class='line'> movl %edi, %ecx 
</span><span class='line'> movl %ecx, -8(%rbp)
</span><span class='line'> movq %rax, -16(%rbp) 
</span><span class='line'> xorb %al, %al 
</span><span class='line'> leaq LC(%rip), %rcx 
</span><span class='line'> movq %rcx, %rdi 
</span><span class='line'> call _printf 
</span><span class='line'> movl $0, -4(%rbp) 
</span><span class='line'> movl -4(%rbp), %eax 
</span><span class='line'> addq $16, %rsp 
</span><span class='line'> popq %rbp 
</span><span class='line'> ret
</span><span class='line'>Leh_func_end1: 
</span><span class='line'> .cstring
</span><span class='line'>LC: 
</span><span class='line'> .asciz "Hello World!"</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>然后链接库并生成可执行程序（译注：如果你对 C 的编译链接过程还不熟悉可以参看 Deep C and C++）。要和 Objective-C 对比的话，处理过程很相似，生成的代码依赖于是否有 Objective-C Runtime 库。当刚学 Objective-C 时，我们最先了解的(最简单的那种)是 Objective-C 中用括号包起来的代码像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self doSomethingWithVar:var1];</span></code></pre></td></tr></table></div></figure>


<p>被转换为…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>objc_msgSend(self,@selector(doSomethingWithVar:),var1);</span></code></pre></td></tr></table></div></figure>


<p>但除了这些，我们就不知道之后在运行时做了什么了。</p>

<h4>Objective-C Runtime 是什么？</h4>

<p>Objective-C 的 Runtime 是一个运行时库（Runtime Library），它是一个主要使用 C 和汇编写的库，为 C 添加了面相对象的能力并创造了 Objective-C。这就是说它在类信息（Class information） 中被加载，完成所有的方法分发，方法转发，等等。Objective-C runtime 创建了所有需要的结构体，让 Objective-C 的面相对象编程变为可能。</p>

<h4>Objective-C Runtime 术语</h4>

<p>更深入之前，咱们先了解点术语。Mac 和 iPhone 开发者关心的有两个 runtime：Modern Runtime（现代的 Runtime） 和 Legacy Runtime（过时的 Runtime）。Modern Runtime：覆盖所有 64 位的 Mac OS X 应用和所有 iPhone OS 的应用。 Legacy Runtime: 覆盖其他的所有应用（所有 32 位的 Mac OS X 应用） Method 有 2 种基本类型的方法。Instance Method（实例方法）：以 ‘-’ 开始，比如 -(void)doFoo; 在对象实例上操作。Class Method（类方法）：以 ‘+’ 开始，比如 +(id)alloc。方法（Methods）和 C 的函数很像，是一组代码，执行一个小的任务，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSString *)movieTitle
</span><span class='line'>{
</span><span class='line'>    return @"Futurama: Into the Wild Green Yonder";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Selector 在 Objective-C 中 selector 只是一个 C 的数据结构，用于表示一个你想在一个对象上执行的 Objective-C 方法。在 runtime 中的定义像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct objc_selector  *SEL; </span></code></pre></td></tr></table></div></figure>


<p>像这样使用…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SEL aSel = @selector(movieTitle); </span></code></pre></td></tr></table></div></figure>


<h4>Message（消息）</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[target getMovieTitleForObject:obj];</span></code></pre></td></tr></table></div></figure>


<p>消息是方括号 ‘[]’ 中的那部分，由你要向其发送消息的对象（target），你想要在上面执行的方法（method）还有你发送的参数（arguments）组成。Objective-C 的消息和 C 函数调用是不同的。事实上，你向一个对象发送消息并不意味着它会执行它。Object（对象）会检查消息的发送者，基于这点再决定是执行一个不同的方法还是转发消息到另一个目标对象上。Class 如果你查看一个类的runtime信息，你会看到这个…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct objc_class *Class;
</span><span class='line'>typedef struct objc_object {
</span><span class='line'>    Class isa;
</span><span class='line'>} *id; </span></code></pre></td></tr></table></div></figure>


<p>这里有几个事情。我们有一个 Objective-C 类的结构体和一个对象的结构体。objc_object 只有一个指向类的 isa 指针，就是我们说的术语 “isa pointer”（isa 指针）。这个 isa 指针是当你向对象发送消息时，Objective-C Runtime 检查一个对象并且查看它的类是什么然后开始查看它是否响应这些 selectors 所需要的一切。最后我么看到了 id 指针。默认情况下 id 指针除了告诉我们它们是 Objective-C 对象外没有其他用了。当你有一个 id 指针，然后你就可以问这个对象是什么类的，看看它是否响应一个方法，等等，然后你就可以在知道这个指针指向的是什么对象后执行更多的操作了。你可以在 LLVM/Clang 的文档中的 Block 中看到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Block_literal_1 {
</span><span class='line'>    void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock    
</span><span class='line'>    int flags;    
</span><span class='line'>    int reserved;     
</span><span class='line'>    void (*invoke)(void *, ...); 
</span><span class='line'>    struct Block_descriptor_1 { 
</span><span class='line'>        unsigned long int reserved; // NULL     
</span><span class='line'>        unsigned long int size;  // sizeof(struct Block_literal_1)
</span><span class='line'>        // optional helper functions     
</span><span class='line'>        void (*copy_helper)(void *dst, void *src);
</span><span class='line'>        void (*dispose_helper)(void *src);     
</span><span class='line'>    } *descriptor;    
</span><span class='line'>    // imported variables
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>Blocks 被设计为兼容 Objective-C 的 runtime，所以他们被作为对象对待，因此他们可以响应消息，比如 -retain，-release，-copy ，等等。IMP（方法实现 MethodImplementations）</p>

<p>typedef id (*IMP)(id self,SEL _cmd,&hellip;);
IMP 是指向方法实现的函数指针，由编译器为你生成。如果你新接触 Objective-C 你现在不需要直接接触这些，但是我们将会看到，Objective-C runtime 将如何调用你的方法的。Objective-C Classes（Objective-C 类） 那么什么是 Objective-C 类？在 Objective-C 中的一个类实现看起来像这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface MyClass : NSObject {
</span><span class='line'>    // vars
</span><span class='line'>    NSInteger counter;
</span><span class='line'>}
</span><span class='line'>// methods
</span><span class='line'>-(void)doFoo;
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>//但是 runtime 不只要追踪这些
</span><span class='line'>
</span><span class='line'>#if !__OBJC2__   
</span><span class='line'>    Class super_class                        OBJC2_UNAVAILABLE;
</span><span class='line'>    const char *name                         OBJC2_UNAVAILABLE;
</span><span class='line'>    long version                             OBJC2_UNAVAILABLE;
</span><span class='line'>    long info                                OBJC2_UNAVAILABLE;
</span><span class='line'>    long instance_size                       OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_method_list **methodLists    OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_cache *cache                 OBJC2_UNAVAILABLE;    
</span><span class='line'>    struct objc_protocol_*protocols          OBJC2_UNAVAILABLE;
</span><span class='line'>#endif </span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，一个类有其父类的引用，它的名字，实例变量，方法，缓存还有它遵循的协议。runtime 在响应类或实例的方法时需要这些信息。</p>

<h4>那么 Class 定义的是对象还是对象本身？它是如何实现的 （译注：读者需要区分 Class 和 class 是不同的，正如 Nil 和 nil 的用途是不同的）</h4>

<p>是的，之前我说过 Objective-C 类也是对象，runtime 通过创建 Meta Classes 来处理这些。当你发送一个消息像这样 [NSObject alloc] 你正在向类对象发送一个消息，这个类对象需要是 MetaClass 的实例，MetaClass 也是 root meta class 的实例。当你说继承自 NSObject 时，你的类指向 NSObject 作为自己的 superclass。然而，所有的 meta class 指向 root metaclass 作为自己的 superclass。所有的 meta class 只是简单的有一个自己响应的方法列表。所以当你向一个类对象发送消息如 [NSObject alloc]，然后实际上 objc_msgSend() 会检查 meta class 看看它是否响应这个方法，如果他找到了一个方法，就在这个 Class 对象上执行（译注：class 是一个实例对象的类型，Class 是一个类（class）的类型。对于完全的 OO 来说，类也是个对象，类是类类型(MetaClass)的实例，所以类的类型描述就是 meta class）。</p>

<h4>为什么我们继承自苹果的类</h4>

<p>从你开始 Cocoa 开发时，那些教程就说如继承自 NSObject 然后开始写一些代码，你享受了很多继承自苹果的类所带来的便利。有一件事你从未意识到的是你的对象被设置为使用 Objective-C 的 runtime。当我们为我们的类的一个实例分配了内存，像这样…</p>

<p>MyObject *object = [[MyObject alloc] init];
最先执行的消息是 +alloc。如果你查看下文档，它说“新的实例对象的 isa 实例变量被初始化为指向一个数据结构，那个数据结构描述了这个类；其他的实例变量被初始化为 0。”所以继承自苹果的类不仅仅是继承了一些重要的属性，也继承了能在内存中轻松分配内存的能力和在内存中创建满足 runtime 期望的对象结构（设置 isa 指针指向我们的类）。</p>

<h4>那么 Class Cache 是什么？（objc_cache *cache）</h4>

<p>当 Objective-C runtime 沿着一个对象的 isa 指针检查时，它会发现一个对象实现了许多的方法。然而你可能只调用其中一小部分的方法，也没有意义每次检查时搜索这个类的分发表（dispatch table）中的所有 selector。所以这个类实现了一个缓存，当你搜索一个类的分发表，并找到合适的 selector 后，就会把它放进缓存中。所以当 objc_msgSend() 在一个类中查找 selector 时会先查找类缓存。有个理论是，当你在一个类上调用了一个消息，你很可能之后还会调用它。所以如果我们考虑到这点，就意味着当我们有个子类继承自 NSObject 叫做 MyObject 并且运行了以下的代码</p>

<p>MyObject *obj = [[MyObject alloc] init];</p>

<p>@implementation MyObject
- (id)init {
    if(self = [super init]) {
        [self setVarA:@”blah”];  <br/>
    }
    return self;
}
@end
发生了以下的事：</p>

<p>(1) [MyObject alloc] 首先被执行。MyObject 没有实现 alloc 方法，所以我们不能在这个类中找到 +alloc 方法，然后沿着 superclass 指针会指向 NSObject。</p>

<p>(2) 我们询问 NSObject 是否响应 +alloc 方法，它可以。+alloc 检查消息的接收者类，是 MyObject，然后分配一块和我们的类同样大小的内存空间，并初始化它的 isa 指针指向 MyObject 类，我们现在有了一个实例对象，最终把类对象的 +alloc 方法加入 NSObject 的类缓存（class cache）中（lastly we put +alloc in NSObject’s class cache for the class object ）。</p>

<p>(3) 到现在为止，我们发送了一个类消息，但是现在我们发送一个实例消息，只是简单的调用 -init 或者我们设计的初始化方法。当然，我们的类会响应这个方法，所以 -(id)init 加入到缓存中。（译注：要是 MyObject 实现了 init 方法，就会把 init 方法加入到 MyObject 的 class cache 中，要是没有实现，只是因为继承才有了这个方法，init 方法还是会加入到 NSObject 的 class cache 中）。</p>

<p>(4) 然后 self = [super init] 被调用。super 是个 magic keyword，指向对象的父类，所以我们得到了 NSObject 并调用它的的 init 方法。这样可以确保 OOP（面相对象编程） 的继承功能正常，这个方法可以正确的初始化父类的变量，之后你（在子类中）可以初始化自己的变量，如果需要可以覆盖父类的方法。在 NSObject 的例子中，没什么重要的要做，但并不总是这样。有时要做些重要的初始化。比如…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>
</span><span class='line'>@interface MyObject : NSObject {
</span><span class='line'>    NSString *aString;
</span><span class='line'>} 
</span><span class='line'>    @property(retain) NSString *aString; 
</span><span class='line'>
</span><span class='line'>@end 
</span><span class='line'>
</span><span class='line'>@implementation MyObject
</span><span class='line'>
</span><span class='line'>-(id)init 
</span><span class='line'>{ 
</span><span class='line'>    if (self = [super init]) {
</span><span class='line'>        [self setAString:nil];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@synthesize aString;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>int main (int argc, const char * argv[]) 
</span><span class='line'>{
</span><span class='line'>    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
</span><span class='line'>
</span><span class='line'>    id obj1 = [NSMutableArray alloc]; 
</span><span class='line'>    id obj2 = [[NSMutableArray alloc] init];   
</span><span class='line'>    id obj3 = [NSArray alloc]; 
</span><span class='line'>    id obj4 = [[NSArray alloc] initWithObjects:@"Hello",nil];
</span><span class='line'>
</span><span class='line'>    NSLog(@"obj1 class is %@",NSStringFromClass([obj1 class]));
</span><span class='line'>    NSLog(@"obj2 class is %@",NSStringFromClass([obj2 class]));
</span><span class='line'>    NSLog(@"obj3 class is %@",NSStringFromClass([obj3 class]));
</span><span class='line'>    NSLog(@"obj4 class is %@",NSStringFromClass([obj4 class]));
</span><span class='line'>
</span><span class='line'>    id obj5 = [MyObject alloc]; 
</span><span class='line'>    id obj6 = [[MyObject alloc] init];   
</span><span class='line'>
</span><span class='line'>    NSLog(@"obj5 class is %@",NSStringFromClass([obj5 class]));    
</span><span class='line'>    NSLog(@"obj6 class is %@",NSStringFromClass([obj6 class]));   
</span><span class='line'>
</span><span class='line'>    [pool drain];
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在如果你新接触 Cocoa ，我让你猜会会输出什么，你可能会说</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray
</span><span class='line'>NSMutableArray 
</span><span class='line'>NSArray
</span><span class='line'>NSArray
</span><span class='line'>MyObject
</span><span class='line'>MyObject</span></code></pre></td></tr></table></div></figure>


<p>但是，实际上是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>obj1 class is __NSPlaceholderArray
</span><span class='line'>obj2 class is NSCFArray
</span><span class='line'>obj3 class is __NSPlaceholderArray
</span><span class='line'>obj4 class is NSCFArray
</span><span class='line'>obj5 class is MyObject
</span><span class='line'>obj6 class is MyObject</span></code></pre></td></tr></table></div></figure>


<p>这是因为在 Objective-C 中 +alloc 方法可能会返回某个类的对象，然后在 -init 中返回另一个类的对象。
（译注：感兴趣的同学可以看下这两篇文章：Class Clusters, Make Your Own Abstract Factory Class Cluster in Objective-C, 第二篇文章需要自备小梯子。)</p>

<h4>那么在 objc_msgSend 中发生了什么？</h4>

<p>事实上在 objc_msgSend() 中发生了许多事儿。假设我们有这样的代码…</p>

<p>[self printMessageWithString:@&ldquo;Hello World!&rdquo;];
它实际上会被编译器翻译为…</p>

<p>objc_msgSend(self,@selector(printMessageWithString:),@&ldquo;Hello World!&rdquo;);
我们沿着目标对象的 isa 指针查找，看看是否这个对象响应 @selector(printMessageWithString:) selector。假设我们在类的分发表或者缓存中找到了这个 selector，我们沿着函数指针并且执行它。这样 objcmsgSend() 就永远不会返回，它开始执行，然后沿着指向方法的指针，然后你的方法返回，这样看起来 objcmsgSend() 方法返回了。Bill Bumgarner 比我讲了更多 objc_msgSend() 的细节（部分1，部分2 和 部分3）。</p>

<p>概括下他说的，并且你已经看过了 Objective-C 的 runtime 代码…</p>

<p>检查忽略的 Selector 和短路（Short Circut）—— 显然，如果我们运行在垃圾回收机制下，我们可以忽略调用 -retain, -release, 等等。
检查 nil 对象（target）。和其他的语言不一样的是，在 Objective-C 中向 nil 发送消息是完全合法的，并且有些原因下你会愿意这么做的。假设我们有个非 nil 的对象，然后我们继续…
然后我们需要在这个类上找到 IMP，所以我们先从 class cache 中找起，如果找到了就沿着指针跳到这个函数。
如果没有在缓存中找到 IMP，然后去查找类的分发表，如果找到了，就沿着指针跳到这个函数。
如果 IMP 没有在缓存和类的分发表中找到，然后我们跳到转发机制。这意味着最终你的代码被编译器转换为 C 函数。你写的方法会像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(int)doComputeWithNum:(int)aNum </span></code></pre></td></tr></table></div></figure>


<p>会被翻译为…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int aClass_doComputeWithNum(aClass *self,SEL _cmd,int aNum) </span></code></pre></td></tr></table></div></figure>


<p>Objective-C Runtime 通过调用（invoking）指向这些方法的函数指针调用你的方法（call your methods）。现在，我要说的是，你不能直接调用这些被翻译的方法，但是 Cocoa 框架提供了获得函数指针的方法…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//declare C function pointer
</span><span class='line'>int (computeNum *)(id,SEL,int);
</span><span class='line'>
</span><span class='line'>//methodForSelector is COCOA & not ObjC Runtime
</span><span class='line'>//gets the same function pointer objc_msgSend gets
</span><span class='line'>computeNum = (int (*)(id,SEL,int))[target methodForSelector:@selector(    doComputeWithNum:)]; 
</span><span class='line'>
</span><span class='line'>//execute the C function pointer returned by the runtime
</span><span class='line'>computeNum(obj,@selector(doComputeWithNum:),aNum); </span></code></pre></td></tr></table></div></figure>


<p>通过这种方法，你可以直接访问这个函数，并且可以在运行时直接调用，甚至可以使用这个避开 runtime 的动态特性，如果你绝对需要确保一个方法被执行。Objective-C 就是用这种途径去调用你的方法的，但是使用的是 objc_msgSend()。</p>

<h4>Objective-C 消息转发</h4>

<p>在 Objective-C 中向一个不知道如何响应这个方法的对象发送消息是完全合法的（甚至可能是一种潜在的设计决定）。苹果的文档中给出的一个原因是模拟多继承，Objective-C 不是原生支持的，或者你可能只是想抽象你的设计并且隐藏幕后处理这些消息的其他对象/类。这一点是 runtime 非常需要的。它是这样做的 1. Runtime 检查了你的类和所有父类的 class cache 和分发表，但是没找到指定的方法。2. Objective_C 的 Runtime 会在你的类上调用 + (BOOL) resolveInstanceMethod:(SEL)aSEL。 这就给了你一个机会去提供一个方法实现并且告诉 runtime 你已经解析了这个方法，如果它开始查找，这回就会找到这个方法。你可以像这样实现…定义一个函数…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void fooMethod(id obj, SEL _cmd)
</span><span class='line'>{ 
</span><span class='line'>    NSLog(@"Doing Foo");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后你可以像这样使用 class_addMethod() 解析它…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+(BOOL)resolveInstanceMethod:(SEL)aSEL
</span><span class='line'>{
</span><span class='line'>    if(aSEL == @selector(doFoo:))
</span><span class='line'>    {
</span><span class='line'>            class_addMethod([self class],aSEL,(IMP)fooMethod,"v@:");
</span><span class='line'>            return YES;
</span><span class='line'>    }
</span><span class='line'>    return [super resolveInstanceMethod];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在 class_addMethod() 最后一部分的 “v@:” 是方法的返回和参数类型。你可以在 Runtime Guide 的 Type Encoding 章节看到完整介绍。 3. Runtime 然后调用 – (id)forwardingTargetForSelector:(SEL)aSelector。这样做是为了给你一次机会（因为我们不能解析这个方法（参见上面的 #2））引导 Objective-C runtime 到另一个可以响应这个消息的对象上，在花费昂贵的处理过程调用 – (void)forwardInvocation:(NSInvocation *)anInvocation 之前调用这个方法也是更好的。你可以像这样实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)forwardingTargetForSelector:(SEL)aSelector
</span><span class='line'>{
</span><span class='line'>    if(aSelector == @selector(mysteriousMethod:))
</span><span class='line'>    {        
</span><span class='line'>        return alternateObject;
</span><span class='line'>    }
</span><span class='line'>    return [super forwardingTargetForSelector:aSelector];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>显然你不想从这个方法直接返回 self，否则可能会产生一个死循环。 4. Runtime 最后一次会尝试在目标对象上调用 – (void)forwardInvocation:(NSInvocation *)anInvocation。如果你从没看过 NSInvocation，它是 Objective-C 消息的对象形式。一旦你有了一个 NSInvocation 你可以改变这个消息的一切，包括目标对象，selector 和参数。所以你可以这样做…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(void)forwardInvocation:(NSInvocation *)invocation
</span><span class='line'>{  
</span><span class='line'>    SEL invSEL = invocation.selector;    
</span><span class='line'>    if([altObject respondsToSelector:invSEL]) {        
</span><span class='line'>        [invocation invokeWithTarget:altObject];    
</span><span class='line'>    } else {        
</span><span class='line'>        [self doesNotRecognizeSelector:invSEL];    
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果你继承自 NSObject，默认它的 – (void)forwardInvocation:(NSInvocation *)anInvocation 实现只是简单的调用 -doesNotRecognizeSelector:，你可以在最后一次机会里覆盖这个方法去做一些事情。（译注：对这块内容有兴趣的同学可以参见：<a href="http://www.cnblogs.com/biosli/p/NSObjectinherit2.html%EF%BC%89">http://www.cnblogs.com/biosli/p/NSObjectinherit2.html%EF%BC%89</a></p>

<h4>Non Fragile ivars（Modern Runtime）（非脆弱的 ivar）</h4>

<p>我们最近在 Modern Runtime 里得到的是 Non Fragile ivars 的概念。当编译你的类时，编译器生成了一个 ivar 布局，显示了在你的类中从哪可以访问你的 ivars，获取指向你的对象的指针，查看 ivar 与对象起始字节的偏移关系，和获取读入的变量类型的总共字节大小等一些底层的细节。所以你的 ivar 布局可能看起来像这样，左侧的数字是字节偏移量。</p>

<p>我们有了 NSObject 的 ivar 布局，然后我们继承自 NSObject 去扩展它并且添加了我们自己的 ivars。在苹果发布更新前这都工作的很好，但是 Mac OS X 10.6 发布后，就成了这样</p>

<p>你的自定义对象被剔除了因为我们有了一个重叠的父类。唯一可以防止这个的办法是如果苹果坚持之前的布局，如果他们这么做了，那么他们的框架就不能改进，因为他们的 ivar 布局被冻住了。在 fragile ivar 下你不得不重新编译你继承自苹果类的类来恢复兼容性。所以在非 fragile ivar 时，会发生生么？</p>

<p>使用非 fragile ivars 时，编译器生成和 fragile ivars 相同的 ivar 布局。然而当 runtime 检测到一个重叠的超类时，它调整你在这个类中新增的 ivar 的偏移量，这样在子类中新增加的那部分就显示出来了。</p>

<h4>Objective-C 关联对象</h4>

<p>最近在 Mac OS X 10.6 雪豹 中新引入了关联引用。Objective-C 不能动态的添加一些属性到对象上，和其他的一些原生支持这点的语言不一样。所以之前你都不得不努力为未来要增加的变量预留好空间。在 Mac OS X 10.6 中，Objective-C 的 Runtime 已经原生的支持这个功能了。如果我们想向一个已有的类添加变量，看起来像这样…</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Cocoa/Cocoa.h&gt; //Cocoa
</span><span class='line'>#include &lt;objc/runtime.h&gt; //objc runtime api’s 
</span><span class='line'>
</span><span class='line'>@interface NSView (CustomAdditions)
</span><span class='line'>@property(retain) NSImage *customImage;
</span><span class='line'>@end 
</span><span class='line'>
</span><span class='line'>@implementation NSView (CustomAdditions) 
</span><span class='line'>
</span><span class='line'>static char img_key; //has a unique address (identifier)
</span><span class='line'>
</span><span class='line'>- (NSImage *)customImage
</span><span class='line'>{    
</span><span class='line'>    return objc_getAssociatedObject(self,&img_key);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setCustomImage:(NSImage *)image
</span><span class='line'>{    
</span><span class='line'>    objc_setAssociatedObject(self, &img_key,image, OBJC_ASSOCIATION_RETAIN);
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>objc_setAssociatedObject() 的选项，你可以在 runtime.h 文件中找到。
</span><span class='line'>
</span><span class='line'>/* Associated Object support. */ 
</span><span class='line'>
</span><span class='line'>/* objc_setAssociatedObject() options */
</span><span class='line'>enum {    
</span><span class='line'>    OBJC_ASSOCIATION_ASSIGN = 0,    
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,    
</span><span class='line'>    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,    
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN = 01401,    
</span><span class='line'>    OBJC_ASSOCIATION_COPY = 01403
</span><span class='line'>}; </span></code></pre></td></tr></table></div></figure>


<p>这些和 @property 语法中的选项意思一样。</p>

<h4>混和的 vTable Dispatch</h4>

<p>如果你看过 modern runtime 的代码，你会发现这个（在 objc-runtime-new.m 中）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/***********************************************************************
</span><span class='line'>* vtable dispatch
</span><span class='line'>* 
</span><span class='line'>* Every class gets a vtable pointer. The vtable is an array of IMPs.
</span><span class='line'>* The selectors represented in the vtable are the same for all classes
</span><span class='line'>*   (i.e. no class has a bigger or smaller vtable).
</span><span class='line'>* Each vtable index has an associated trampoline which dispatches to 
</span><span class='line'>*   the IMP at that index for the receiver class's vtable (after 
</span><span class='line'>*   checking for NULL). Dispatch fixup uses these trampolines instead 
</span><span class='line'>*   of objc_msgSend.
</span><span class='line'>* Fragility: The vtable size and list of selectors is chosen at launch 
</span><span class='line'>*   time. No compiler-generated code depends on any particular vtable 
</span><span class='line'>*   configuration, or even the use of vtable dispatch at all.
</span><span class='line'>* Memory size: If a class's vtable is identical to its superclass's 
</span><span class='line'>*   (i.e. the class overrides none of the vtable selectors), then 
</span><span class='line'>*   the class points directly to its superclass's vtable. This means 
</span><span class='line'>*   selectors to be included in the vtable should be chosen so they are 
</span><span class='line'>*   (1) frequently called, but (2) not too frequently overridden. In 
</span><span class='line'>*   particular, -dealloc is a bad choice.
</span><span class='line'>* Forwarding: If a class doesn't implement some vtable selector, that 
</span><span class='line'>*   selector's IMP is set to objc_msgSend in that class's vtable.
</span><span class='line'>* +initialize: Each class keeps the default vtable (which always 
</span><span class='line'>*   redirects to objc_msgSend) until its +initialize is completed.
</span><span class='line'>*   Otherwise, the first message to a class could be a vtable dispatch, 
</span><span class='line'>*   and the vtable trampoline doesn't include +initialize checking.
</span><span class='line'>* Changes: Categories, addMethod, and setImplementation all force vtable 
</span><span class='line'>*   reconstruction for the class and all of its subclasses, if the 
</span><span class='line'>*   vtable selectors are affected.
</span><span class='line'>**********************************************************************/ </span></code></pre></td></tr></table></div></figure>


<p>背后的思想是，runtime 尝试在这个 vtable 中存储最近被调用的 selectors，这样就可以提升你的应用的速度，因为它使用了比 objc_msgSend 更少的指令（fewer instructions）。vtable 中保存 16 个全局最经常调用的 selectors，事实上顺着代码往下看你可以发现垃圾回收和非垃圾回收类型程序的默认 selectors …</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[INSTANCETYPE 与 ID 的区别。]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/21/instancetype-yu-id-de-qu-bie/"/>
    <updated>2014-09-21T18:31:05+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/21/instancetype-yu-id-de-qu-bie</id>
    <content type="html"><![CDATA[<p>新的LLVM编译器为我们带来了ARC, Object Literal and Scripting, Auto Synthesis等特性，同时也引入了instancetype关键字。instancetype用来表示Related Result Types(相关返回类型)，那么它与id有什么不同呢？</p>

<p>根据Cocoa的命名惯例，init, alloc这类的方法，如果以id作为返回类型，会返回类本身的类型。</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Person
</span><span class='line'>- (id)initWithName:(NSString *)name;
</span><span class='line'>+ (id)personWithName:(NSString *)name;</span></code></pre></td></tr></table></div></figure>


<p>但类方法的返回类型，LLVM(或者说Clang)却无法判断，我们来看一段代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// You may get two warnings if you're using MRC rather than ARC
</span><span class='line'>
</span><span class='line'>[[[NSArray alloc] init] mediaPlaybackAllowsAirPlay]; //  "No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`"
</span><span class='line'>[[NSArray array] mediaPlaybackAllowsAirPlay]; // It's OK. But You'll get a runtime error instead of a compile time one</span></code></pre></td></tr></table></div></figure>


<p>[NSArray array]除非显式转换为(NSArray *)，否则编译器不会有错误提示。如果使用instancetype就不会有这样的问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Person
</span><span class='line'>- (instancetype)initWithName:(NSString *)name;
</span><span class='line'>+ (instancetype)personWithName:(NSString *)name;</span></code></pre></td></tr></table></div></figure>


<p>简单来说，instancetype关键字，保证了编译器能够正确推断方法返回值的类型。这种技术基本从iOS 5的UINavigationController里就开始应用了。</p>

<p>Clang的文档里提到 instancetype
is a contextual keyword that is only permitted in the result type of an Objective-C method. 也就是说，instancetype只能作为返回值，不能像id那样作为参数。</p>

<ul>
<li><a href="http://clang.llvm.org/docs/LanguageExtensions.html#objective-c-features">ClangClang Language Extensions</a></li>
<li><a href="http://nshipster.com/instancetype/">NSHipster</a></li>
<li><a href="http://www.jonmsterling.com/posts/2012-02-05-typed-collections-with-self-types-in-objective-c.html">Typed Collections With Self Types in Objective-C</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[移动App架构设计]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/21/yi-dong-app-jia-gou-she-ji/"/>
    <updated>2014-09-21T16:47:01+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/21/yi-dong-app-jia-gou-she-ji</id>
    <content type="html"><![CDATA[<p>Native app的开发相比传统的项目迭代周期要短很多, 需求的变化也频繁一些, 在开发的不同生命周期里采用不同的架构模式可以有效的节约开发时间, 提高开发效率, 这篇文章介绍几种常用的架构模式:</p>

<!--more-->


<h4>表现层</h4>

<h5>基本的MVC</h5>

<p>移动app一般都是采用经典的mvc架构</p>

<table>
<thead>
<tr>
<th>层次      </th>
<th> 作用     </th>
<th> 设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>模型层(model)</td>
<td>   封装了应用的一系列数据, 并定义了操作, 处理这些数据的逻辑和计算规则。</td>
<td>通过Notification,KVO对控制器进行反馈</td>
</tr>
<tr>
<td>视图层(view) </td>
<td>视图对象是一个应用中, 用户可以看到的对象. 视图对象知道如何绘制自己, 也能够响应用户的操作. 视图对象的主要目的之一是将应用模型对象中的数据显示出来, 并允许用户编辑该数据 </td>
<td>视图通过不能直接操作模型层, 通过target-action, delegate, dataSource和控制器进行反馈</td>
</tr>
<tr>
<td>控制器层(controller)    </td>
<td>控制器层是在视图层和若干个模型层的中间人</td>
<td> c可以直接操作模型层和视图层</td>
</tr>
</tbody>
</table>


<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvc.png" alt="id1" /></p>

<h5>总结:</h5>

<ul>
<li>C对M：API</li>
<li>C对V：Outlet</li>
<li>V对C：Target-action， Delegate，Datasource</li>
<li>M对C：Notification，KVO</li>
</ul>


<h5>MVC的改进版 MVVM</h5>

<p>MVVM是在MVC的基础上多了一个View Model: 表示逻辑, 将 model 的数据转换为 view 可以呈现的东西. 适合大量展示类的App.</p>

<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvvm.png" alt="id2" /></p>

<h5>HMVC</h5>

<p>Hierarchical MVC, 把客户端应用程序分解为有层次的父子关系的MVC, 反复应用这个模式, 形成结构化的客户端架构. 适合重型B/S架构的WebApp.</p>

<p>一个MVC模块由应用程序的一个模块抽象而成. 其中很重要的一个概念就是 Parent MVC , 它可以对应界面上的实体, 也可以是一个抽象的对象. 设想一个app 有标签栏, 工具栏, 导航栏, 主工作区, 对应到HMVC上就是这个app最底部的标签栏 是 Layer1, Layer2 导航栏,主要工作区, 工具栏. 如果觉得 Layer2 太复杂可以吧主要工作区放到 Layer3, 依次类推.</p>

<p>Controller 是功能模块的总控室, 它负责和子Controller或父Controller通信，并通知它的 View 处理改变界面显示, Model 处理一些业务逻辑或数据库访问操作. 如才的例子里, 点击了工具栏里的一个按钮, 工具栏的Controller 响应这个event, 发现是要切换主工作区, 工具栏做不了,就传递他的父Controller处理(如果父Controller也处理不了, 就继续往上传递)然后标签栏的Controller处理切换主工作区.</p>

<p>优点:</p>

<p>把程序分成了几个部分, 降低了依赖性
支持鼓励重用代码, 组件或者模块。
在今后的维护中, 提高了可扩展性。</p>

<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/hmvc.png" alt="id3" /></p>

<h4>分层设计</h4>

<h5>三层架构</h5>

<p>我们在来看一下经典的三层架构</p>

<p>从上至下为</p>

<ul>
<li>表现层(UI)</li>
<li>业务逻辑层或称为领域层(BLL)</li>
<li>数据访问层(DAL)</li>
</ul>


<table>
<thead>
<tr>
<th>层次  </th>
<th> 作用    </th>
<th>设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>表现层(UI) </td>
<td> 向用户展现特定业务数据，采集用户的输入信息和操 </td>
<td>用户至上，兼顾简洁；不包含任何业务相关的逻辑处理</td>
</tr>
<tr>
<td>业务逻辑层(BLL)    </td>
<td>从ＤＡＬ中获取数据, 在ＵＩ显示; 从ＵＩ中获取用户指令和数据, 执行业务逻辑或通过ＤＡＬ写入数据源 </td>
<td> 作为U层与Ｄ层的桥梁,目的在于展现清晰的函数结构, 只负责数据处理传递, 不涉及ＳＱＬ语句和ＡＤＯ.ＮＥＴ</td>
</tr>
<tr>
<td>数据访问层(DAL)    </td>
<td> 直接操作数据库，针对数据的增添 删除 修改 查找; 具体为业务逻辑层或表示层提供数据服务。</td>
<td> 专门操作数据库, 不考虑数据合法性. 数据库错误返回－1, 逻辑错误返回0, 并告知错误原因, 成功返回1</td>
</tr>
</tbody>
</table>


<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvc_vs_3.png" alt="id4" /></p>

<p>然后呢,我们现在的架构则是
<img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/3.png" alt="id5" /></p>

<h5>四层架构</h5>

<p>在三层架构的基础上多了业务规则层, 通常的三层是把业务逻辑和业务规则合并为一个层，统称为业务层. 业务规则层的提出,既可以及时处理用户输入的不合法信息, 又可以及时处理数据库错误, 增大了业务逻辑层的结构清晰度, 让业务逻辑人员专心致志做逻辑.</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>业务规则层</li>
<li>业务逻辑层或称为领域层</li>
<li>数据访问层</li>
</ul>


<table>
<thead>
<tr>
<th>层次  </th>
<th>作用</th>
<th>    设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>业务规则层(ECL)</td>
<td>   对于UI层传下来的参数来说，检查合法性。</td>
<td>用户至上，兼顾简洁；不包含任何业务相关的逻辑处理</td>
</tr>
</tbody>
</table>


<h5>五层架构</h5>

<p>一般情况下, 我们的业务逻辑放在中间层, 那么对内部的这些大量种类繁多，使用方法也各异的不同的类的调用任务，就完全落到了表示层. 这样势必会增加表示层的代码量, 将表示层的任务复杂化, 和表示层只负责接受用户的输入并返回结果的任务不太相称, 并增加了层与层之间的耦合程度. 因此呢,我们需要增加接口去去统一的管理这些业务, 是设计模式中Facade模式的思想.</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>业务外观层</li>
<li>业务规则层</li>
<li>业务逻辑层或称为领域层</li>
<li>数据访问层</li>
</ul>


<table>
<thead>
<tr>
<th>层次</th>
<th> 作用</th>
<th>     设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>业务外观层 </td>
<td>为负责子系统中的一组接口提供一个一致而且简单的接口。</td>
<td></td>
</tr>
</tbody>
</table>


<h5>引入service层</h5>

<p>引入service层的架构和普通的分层架构的不同是: service层内部有数据, 可以单独运行.</p>

<p>service</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>服务层(service)</li>
<li>数据访问层</li>
<li>业务逻辑层</li>
</ul>


<table>
<thead>
<tr>
<th>层次</th>
<th> 作用  </th>
<th> 设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>表现层   </td>
<td>显示与用户的互交   </td>
<td></td>
</tr>
<tr>
<td>服务层   </td>
<td>service层提供表现层的业务逻辑入口,通过定义接口服务的形式,通过接口调用来完成.</td>
<td></td>
</tr>
<tr>
<td>业务逻辑层 </td>
<td>1接收服务层传来的DTO, 然后根据业务规则, 对传入的DTO进行加工, 返回加工后的信息 2 需要为每个对象提供业务行为, 并且这些对象之间是独立的 3 业务对象之间的交互流程通过服务层来组织</td>
<td></td>
</tr>
<tr>
<td>数据访问层 </td>
<td>本地数据远程数据的访问接口    </td>
<td></td>
</tr>
</tbody>
</table>


<h5>新秀VIPER</h5>

<p>viper这里不多说了,请想了解的自行搜索
<img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/viper.png" alt="id6" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏捷开发流程总结]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/18/min-jie-kai-fa-liu-cheng-zong-jie/"/>
    <updated>2014-09-18T13:42:04+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/18/min-jie-kai-fa-liu-cheng-zong-jie</id>
    <content type="html"><![CDATA[<h4>Agile——敏捷开发</h4>

<p>作为CMM神话崩溃后被引入的一套新的软件开发模式，这几年来被广泛引起关注，并被寄予厚望。敏捷开发在其他业界的应用是否理想不得而知，但以下总结了我所在公司的敏捷开发试验，希望可以达到管中窥豹的目的。</p>

<!--more-->


<h5>敏捷开发宣言——</h5>

<p>个体和交互 胜过 过程和工具
可以工作的软件 胜过 面面俱到的文档
客户合作 胜过 合同谈判
响应变化 胜过 遵循计划
虽然右项也有价值，但是我们认为左项具有更大的价值。</p>

<p>以上的宣言比较抽象，基于该理念，以下是ThoughtsWork咨询公司的推崇的n个敏捷开发实践：</p>

<h5>Iteration</h5>

<p>迭代开发。可以工作的软件胜过面面俱到的文档。因此，敏捷开发提倡将一个完整的软件版本划分为多个迭代，每个迭代实现不同的特性。重大的、优先级高的特性优先实现，风险高的特性优先实现。在项目的早期就将软件的原型开发出来，并基于这个原型在后续的迭代不断晚上。迭代开发的好处是：尽早编码，尽早暴露项目的技术风险。尽早使客户见到可运行的软件，并提出优化意见。可以分阶段提早向不同的客户交付可用的版本。</p>

<h5>IterationPlanningMeeting</h5>

<p>迭代计划会议。每个迭代启动时，召集整个开发团队，召开迭代计划会议，所有的团队成员畅所欲言，明确迭代的开发任务，解答疑惑。</p>

<h5>Story Card/Story Wall/Feature List</h5>

<p>在每个迭代中，架构师负责将所有的特性分解成多个Story Card。每个Story可以视为一个独立的特性。每个Story应该可以在最多1个星期内完成开发，交付提前测试（Pre-Test）。当一个迭代中的所有Story开发完毕以后，测试组再进行完整的测试。在整个测试过程中（pre-test，test），基于Daily build，测试组永远都是每天从配置库上取下最新编译的版本进行测试，开发人员也随时修改测试人员提交的问题单，并合入配置库。
敏捷开发的一个特点是开放式办公，充分沟通，包括测试人员也和开发人员一起办公。基于Story Card的开发方式，团队会在开放式办公区域放置一块白板，上面粘贴着所有的Story Card，按当前的开发状态贴在4个区域中，分别是：未开发，开发中，预测试中，测试中。Story Card的开发人员和测试人员根据开发进度在Story Wall上移动Story Card，更新Story Card的状态。这种方式可以对项目开发进度有一个非常直观的了解。
在开发人员开始开发一个Story时，ta需要找来对应的测试人员讲解Story功能，以便测试人员有一致的理解，同时开始自动化系统测试脚本的开发。</p>

<h5>Standup Meeting</h5>

<p>站立会议。每天早上，所有的团队成员围在Story Wall周围，开一个高效率的会议，通常不超过15分钟，汇报开发进展，提出问题，但不浪费所有人的时间立刻解决问题，而是会后个别沟通解决。</p>

<h5>Pair Programming</h5>

<p>结对编程是指两个开发人员结对编码。结对编程的好处是：经过两个人讨论后编写的代码比一个人独立完成会更加的完善，一些大的方向不至于出现偏差，一些细节也可以被充分考虑到。一个有经验的开发人员和一个新手结对编程，可以促进新手的成长，保证软件开发的质量。</p>

<h5>CI/Daily Build</h5>

<p>持续集成和每日构建能力是否足够强大是迭代开发是否成功的一个重要基础。基于每日构建。开发人员每天将编写/修改的代码及时的更新到配置库中，自动化编译程序每天至少一次自动从配置库上取下代码，执行自动化代码静态检查（如PCLint），单元测试，编译版本，安装，系统测试，动态检查（如Purify）。以上这些自动化任务执行完毕后，会输出报告，自动发送邮件给团队成员。如果其中存在着任何的问题，相关责任人应该及时的修改。
可以看到，整个开发组频繁的更新代码，出现一些问题不可避免。通过测试部又在不停地基于最新的代码进行测试。新增的问题是否能够被及时发现并消灭掉，取决于自动化单元测试和系统测试能力是否足够强大，特别是自动化系统测试能力。如果自动化测试只能验证最简单的操作，则新合入代码的隐患将很难被发现，并遗留到项目后期，形成大的风险。而实际上，提升自动化测试的覆盖率是最困难的。</p>

<h5>Retrospect</h5>

<p>总结和反思。每个迭代结束以后，项目组成员召开总结会议，总结好的实践和教训，并落实到后续的开发中。</p>

<h5>ShowCase</h5>

<p>演示。每个Story开发完成以后，开发人员叫上测试人员，演示软件功能，以便测试人员充分理解软件功能。</p>

<h5>Refactoring</h5>

<p>重构。因为迭代开发模式在项目早期就开发出可运行的软件原型，一开始开发出来的代码和架构不可能是最优的、面面俱到的，因此在后续的Story开发中，需要对代码和架构进行持续的重构。迭代开发对架构师要求很高。因为架构师要将一个完整的版本拆分成多个迭代，每个跌倒由拆分成很多Story，从架构的角度看，这些Story必须在是有很强的继承性，是可以不断叠加的，不至于后续开发的Story完全推翻了早期开发的代码和架构，同时也不可避免的需要对代码进行不断完善，不断重构。</p>

<h5>TDD</h5>

<p>测试驱动开发。正如上面讲的，迭代开发的特点是频繁合入代码，频繁发布版本。测试驱动开发是保证合入代码正常运行且不会在后期被破坏的重要手段。这里的测试主要指单元测试。</p>

<h5>敏捷方法反思：</h5>

<p>自己参与的敏捷开发项目总的来说不是很成功，这可能也是业界遇到的通病：
1、对于全新的软件，在项目早期测试人员就参与并实现自动化测试脚本，但实际上软件的界面等非常不稳定，导致测试人员返工的工作量很大。
2、对于全新的软件，资料人员过早参与，后期返工工作量大，原因同第一点。
3、自动化系统测试工作量大，测试人员投入大量的精力在使测试自动化起来，而没有足够的精力放在真正的测试软件的功能是否正常。即便是这样，自动化系统测试脚本也多流于形式，测不出深层次的问题。
4、代码动态检查工具执行不理想，流于形式。没有人对Purify有深刻的理解和应用经验，报告中查出来很多告警，但不知如何消除。
5、由于快速搭建原型，没有在架构上进行严谨的设计，导致后期一直堆砌代码。
6、异地开发模式下无法实现快速构建、快速交付，团队普遍感觉很疲惫。
7、敏捷开发不提倡加班，但实际上不管是CMM还是Agile哪一种开发模式跟是否加班都没有必然联系。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用VIPER构建iOS应用]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/17/shi-yong-viper-chuang-jian-kuang-jia/"/>
    <updated>2014-09-17T20:33:17+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/17/shi-yong-viper-chuang-jian-kuang-jia</id>
    <content type="html"><![CDATA[<p>建筑领域流行这样一句话，“我们虽然在营造建筑，但建筑也会重新塑造我们”。正如所有开发者最终领悟到的，这句话同样适用于构建软件。</p>

<p>编写代码中至关重要的是，需要使每一部分容易被识别，赋有一个特定而明显的目的，并与其他部分在逻辑关系中完美契合。这就是我们所说的软件架构。好的架构不仅让一个产品成功投入使用，还可以让产品具有可维护性，并让人不断头脑清醒的对它进行维护！</p>

<!--more-->


<p>在这篇文章中，我们介绍了一种称之为 <a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">VIPER</a> 的 iOS 应用架构的方式。VIPER 已经在很多大型的项目上成功实践，但是出于本文的目的我们将通过一个待办事项清单 (to-do app) 来介绍 VIPER 。你可以在 <a href="https://github.com/objcio/issue-13-viper">GitHub</a> 上关注这个项目。</p>

<h5>什么是 VIPER？</h5>

<p>测试永远不是构建 iOS 应用的主要部分。当我们 <a href="https://github.com/mutualmobile/">Mutual Mobile</a> 着手改善我们的测试实践时，我们发现给 iOS 应用写测试代码非常困难。因此如果想要设法改变测试的现状，我们首先需要一个更好的方式来架构应用，我们称之为 VIPER。</p>

<p>VIPER 是一个创建 iOS 应用<a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">简明构架</a>的程序。VIPER 可以是视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Routing) 的首字母缩写。简明架构将一个应用程序的逻辑结构划分为不同的责任层。这使得它更容易隔离依赖项 (如数据库)，也更容易测试各层间的边界处的交互：
<img src="http://www.cocoachina.com/cms/uploads/allimg/140703/8370_140703100012_1.jpg" alt="id1" /></p>

<p>大部分 iOS 应用利用 MVC 构建，使用 MVC 应用程序架构可以引导你将每一个类看做模型，视图或控制器中的一个。但由于大部分应用程序的逻辑不会存在于模型或视图中，所以通常最终总是在控制器里实现。这就导致一个称为<a href="https://twitter.com/Colin_Campbell/status/293167951132098560">重量级视图控制器</a>的问题，在这里，视图控制器做了太多工作。为这些重量级视图控制器<a href="http://www.objc.io/issue-1/lighter-view-controllers.html">瘦身</a>并不是 iOS 开发者寻求提高代码的质量所要面临的唯一挑战，但至少这是一个很好的开端。</p>

<p>VIPER 的不同层提供了明确的程序逻辑以及导航控制代码来应对这个挑战，利用 VIPER ，你会注意到在我们的待办事项示例清单中的视图控制器可以简洁高效，意义明确地控制视图。你也会发现视图控制器中代码和所有的其他类很容易理解，容易测试，理所当然也更易维护。</p>

<h5>基于用例的应用设计</h5>

<p>应用通常是一些用户用例的集合。用例也被称为验收标准，或行为集，它们用来描述应用的用途。清单可以根据时间，类型以及名字排序，这就是一个用例。用例是应用程序中用来负责业务逻辑的一层，应独立于用户界面的实现，同时要足够小，并且有良好的定义。决定如何将一个复杂的应用分解成较小的用例非常具有挑战性，并且需要长期实践，但这对于缩小你解决的问题时所要面临的范围及完成的每个类的所要涉及的内容来说，是很有帮助的。</p>

<p>利用 VIPER 建立一个应用需要实施一组套件来满足所有的用例，应用逻辑是实现用例的主要组成部分，但却不是唯一。用例也会影响用户界面。另一个重要的方面，是要考虑用例如何与其他应用程序的核心组件相互配合，例如网络和数据持久化。组件就好比用例的插件，VIPER 则用来描述这些组件的作用是什么，如何进行交互。</p>

<p>我们其中一个用例，或者说待办事项清单中其中的一个需求是可以基于用户的选择来将待办事项分组。通过分离的逻辑将数据组织成一个用例，我们能够在测试时使用户界面代码保持干净，用例更易组装，从而确保它如我们预期的方式工作。</p>

<h5>VIPER 的主要部分</h5>

<p>VIPER 的主要部分是：</p>

<p>视图：根据展示器的要求显示界面，并将用户输入反馈给展示器。
交互器：包含由用例指定的业务逻辑。
展示器：包含为显示（从交互器接受的内容）做的准备工作的相关视图逻辑，并对用户输入进行反馈（从交互器获取新数据）。
实体：包含交互器要使用的基本模型对象。
路由：包含用来描述屏幕显示和显示顺序的导航逻辑。</p>

<p>这种分隔形式同样遵循<a href="http://www.objectmentor.com/resources/articles/srp.pdf">单一责任原则</a>。交互器负责业务分析的部分，展示器代表交互设计师，而视图相当于视觉设计师。</p>

<p>以下则是不同组件的相关图解，并展示了他们之间是如何关联的：</p>

<p><img src="http://www.cocoachina.com/cms/uploads/allimg/140703/8370_140703100110_1.png" alt="id2" /></p>

<p>虽然在应用中 VIPER 的组件可以以任意顺序实现，我们在这里选择按照我们推荐的顺序来进行介绍。你会注意到这个顺序与构建整个应用的进程大致符合 &ndash; 首先要讨论的是产品需要做什么，以及用户会如何与之交互。</p>

<h5>交互器</h5>

<p>交互器在应用中代表着一个独立的用例。它具有业务逻辑以操纵模型对象（实体）执行特定的任务。交互器中的工作应当独立与任何用户界面，同样的交互器可以同时运用于 iOS 应用或者 OS X 应用中。</p>

<p>由于交互器是一个 PONSO (Plain Old NSObject，普通的 NSObject)，它主要包含了逻辑，因此很容易使用 TDD 进行开发。</p>

<p>示例应用的主要用例是向用户展示所有的待办事项（比如任何截止于下周末的任务）。此类用例的业务逻辑主要是找出今天至下周末之间将要到期的待办事项，然后为它们分配一个相对的截止日期，比如今天，明天，本周以内，或者下周。</p>

<p>以下是来自 VTDListInteractor 的对应方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)findUpcomingItems 
</span><span class='line'>{ 
</span><span class='line'>    __weak typeof(self) welf = self; 
</span><span class='line'>    NSDate* today = [self.clock today]; 
</span><span class='line'>    NSDate* endOfNextWeek = [[NSCalendar currentCalendar] dateForEndOfFollowingWeekWithDate:today]; 
</span><span class='line'>    [self.dataManager todoItemsBetweenStartDate:today endDate:endOfNextWeek completionBlock:^(NSArray* todoItems) { 
</span><span class='line'>        [welf.output foundUpcomingItems:[welf upcomingItemsFromToDoItems:todoItems]]; 
</span><span class='line'>    }]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<h5>实体</h5>

<p>实体是被交互器操作的模型对象，并且它们只被交互器所操作。交互器永远不会传输实体至表现层 (比如说展示器)。</p>

<p>实体也应该是 PONSOs。如果你使用 Core Data，最好是将托管对象保持在你的数据层之后，交互器不应与 NSManageObjects 协同工作。</p>

<p>这里是我们的待办事项服务的实体：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface VTDTodoItem : NSObject 
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong)   NSDate*     dueDate; 
</span><span class='line'>@property (nonatomic, copy)     NSString*   name; 
</span><span class='line'> 
</span><span class='line'>+ (instancetype)todoItemWithDueDate:(NSDate*)dueDate name:(NSString*)name; 
</span><span class='line'> 
</span><span class='line'>@end 
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>不要诧异于你的实体仅仅是数据结构，任何依赖于应用的逻辑都应该放到交互器中。</p>

<h5>展示器</h5>

<p>展示器是一个主要包含了驱动用户界面的逻辑的 PONSO，它总是知道何时呈现用户界面。基于其收集来自用户交互的输入功能，它可以在合适的时候更新用户界面并向交互器发送请求。</p>

<p>当用户点击 “+” 键新建待办事项时，addNewEntry 被调用。对于此项操作，展示器会要求 wireframe 显示用户界面以增加新项目：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addNewEntry 
</span><span class='line'>{ 
</span><span class='line'>    [self.listWireframe presentAddInterface]; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>展示器还会从交互器接收结果并将结果转换成能够在视图中有效显示的形式。</p>

<p>下面是如何从交互器接受待办事项的过程，其中包含了处理数据的过程并决定展现给用户哪些内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)foundUpcomingItems:(NSArray*)upcomingItems 
</span><span class='line'>{ 
</span><span class='line'>    if ([upcomingItems count] == 0) 
</span><span class='line'>    { 
</span><span class='line'>        [self.userInterface showNoContentMessage]; 
</span><span class='line'>    } 
</span><span class='line'>    else 
</span><span class='line'>    { 
</span><span class='line'>        [self updateUserInterfaceWithUpcomingItems:upcomingItems]; 
</span><span class='line'>    } 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>实体永远不会由交互器传输给展示器，取而代之，那些无行为的简单数据结构会从交互器传输到展示器那里。这就防止了那些“真正的工作”在展示器那里进行，展示器只能负责准备那些在视图里显示的数据。</p>

<h5>视图</h5>

<p>视图一般是被动的，它通常等待展示器下发需要显示的内容，而不会向其索取数据。视图（例如登录界面的登录视图控件）所定义的方法应该允许展示器在高度抽象的层次与之交流。展示器通过内容进行表达，而不关心那些内容所显示的样子。展示器不知道 UILabel，UIButton 等的存在，它只知道其中包含的内容以及何时需要显示。内容如何被显示是由视图来进行控制的。</p>

<p>视图是一个抽象的接口 (Interface)，在 Objective-C 中使用协议被定义。一个 UIViewController 或者它的一个子类会实现视图协议。比如我们的示例中 “添加” 界面会有以下接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddViewInterface  
</span><span class='line'> 
</span><span class='line'>- (void)setEntryName:(NSString *)name; 
</span><span class='line'>- (void)setEntryDueDate:(NSDate *)date; 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>视图和视图控制器同样会操纵用户界面和相关输入。因为通常来说视图控制器是最容易处理这些输入和执行某些操作的地方，所以也就不难理解为什么视图控制器总是这么大了。为了使视图控制器保持苗条，我们需要使它们在用户进行相关操作的时候可以有途径来通知相关部分。视图控制器不应当根据这些行为进行相关决定，但是它应当将发生的事件传递到能够做决定的部分。</p>

<p>在我们的例子中，Add View Controller 有一个事件处理的属性，它实现了如下接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddModuleInterface  
</span><span class='line'> 
</span><span class='line'>- (void)cancelAddAction; 
</span><span class='line'>- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate 
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>当用户点击取消键的时候，视图控制器告知这个事件处理程序用户需要其取消这次添加的动作。这样一来，事件处理程序便可以处理关闭 add view controller 并告知列表视图进行更新。</p>

<p>视图和展示器之间边界处是一个使用 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> 的好地方。在这个示例中，视图控制器可以返回一个代表按钮操作的信号。这将允许展示器在不打破职责分离的前提下轻松地对那些信号进行响应。</p>

<h5>路由</h5>

<p>屏幕间的路径会在交互设计师创建的线框 (wireframes) 里进行定义。在 VIPER 中，路由是由两个部分来负责的：展示器和线框。一个线框对象包括 UIWindow，UINavigationController，UIViewController 等部分，它负责创建视图/视图控制器并将其装配到窗口中。</p>

<p>由于展示器包含了响应用户输入的逻辑，因此它就拥有知晓何时导航至另一个屏幕以及具体是哪一个屏幕的能力。而同时，线框知道如何进行导航。在两者结合起来的情况下，展示器可以使用线框来进行实现导航功能，它们两者一起描述了从一个屏幕至另一个屏幕的路由过程。</p>

<p>线框同时也明显是一个处理导航转场动画的地方。来看看这个 add wireframe 中的例子吧：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDAddWireframe 
</span><span class='line'> 
</span><span class='line'>- (void)presentAddInterfaceFromViewController:(UIViewController *)viewController  
</span><span class='line'>{ 
</span><span class='line'>    VTDAddViewController *addViewController = [self addViewController]; 
</span><span class='line'>    addViewController.eventHandler = self.addPresenter; 
</span><span class='line'>    addViewController.modalPresentationStyle = UIModalPresentationCustom; 
</span><span class='line'>    addViewController.transitioningDelegate = self; 
</span><span class='line'> 
</span><span class='line'>    [viewController presentViewController:addViewController animated:YES completion:nil]; 
</span><span class='line'> 
</span><span class='line'>    self.presentedViewController = viewController; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>#pragma mark - UIViewControllerTransitioningDelegate Methods 
</span><span class='line'> 
</span><span class='line'>- (id)animationControllerForDismissedController:(UIViewController *)dismissed  
</span><span class='line'>{ 
</span><span class='line'>    return [[VTDAddDismissalTransition alloc] init]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (id)animationControllerForPresentedController:(UIViewController *)presented 
</span><span class='line'>                                                                  presentingController:(UIViewController *)presenting 
</span><span class='line'>                                                                      sourceController:(UIViewController *)source  
</span><span class='line'>{ 
</span><span class='line'>    return [[VTDAddPresentationTransition alloc] init]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end 
</span></code></pre></td></tr></table></div></figure>


<p>应用使用了自定义的视图控制器转场来呈现 add view controller。因为线框部件负责实施这个转场，所以它成为了 add view controller 转场的委托，并且返回适当的转场动画。</p>

<h5>利用 VIPER 组织应用组件</h5>

<p>iOS 应用的构架需要考虑到 UIKit 和 Cocoa Touch 是建立应用的主要工具。架构需要和应用的所有组件都能够和平相处，但又需要为如何使用框架的某些部分以及它们应该在什么位置提供一些指导和建议。</p>

<p>iOS 应用程序的主力是 UIViewController，我们不难想象找一个竞争者来取代 MVC 就可以避免大量使用视图控制器。但是视图控制器现在是这个平台的核心：它们处理设备方向的变化，回应用户的输入，和类似导航控制器之类的系统系统组件集成得很好，而现在在 iOS 7 中又能实现自定义屏幕之间的转换，功能实在是太强大了。</p>

<p>有了 VIPER，视图控制器便就能真正的做它本来应该做的事情了，那就是控制视图。 我们的待办事项应拥有两个视图控制器，一个是列表视图，另一个是新建待办。因为 add view controller 要做的所有事情就是控制视图，所以实现起来非常的简单基础：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDAddViewController 
</span><span class='line'> 
</span><span class='line'>- (void)viewDidAppear:(BOOL)animated  
</span><span class='line'>{ 
</span><span class='line'>    [super viewDidAppear:animated]; 
</span><span class='line'> 
</span><span class='line'>    UITapGestureRecognizer *gestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self 
</span><span class='line'>                                                                                        action:@selector(dismiss)]; 
</span><span class='line'>    [self.transitioningBackgroundView addGestureRecognizer:gestureRecognizer]; 
</span><span class='line'>    self.transitioningBackgroundView.userInteractionEnabled = YES; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)dismiss  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler cancelAddAction]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)setEntryName:(NSString *)name  
</span><span class='line'>{ 
</span><span class='line'>    self.nameTextField.text = name; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)setEntryDueDate:(NSDate *)date  
</span><span class='line'>{ 
</span><span class='line'>    [self.datePicker setDate:date]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (IBAction)save:(id)sender  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler saveAddActionWithName:self.nameTextField.text 
</span><span class='line'>                                     dueDate:self.datePicker.date]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (IBAction)cancel:(id)sender  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler cancelAddAction]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>#pragma mark - UITextFieldDelegate Methods 
</span><span class='line'> 
</span><span class='line'>- (BOOL)textFieldShouldReturn:(UITextField *)textField  
</span><span class='line'>{ 
</span><span class='line'>    [textField resignFirstResponder]; 
</span><span class='line'> 
</span><span class='line'>    return YES; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>应用在接入网络以后会变得更有用处，但是究竟该在什么时候联网呢？又由谁来负责启动网络连接呢？典型的情况下，由交互器来启动网络连接操作的项目，但是它不会直接处理网络代码。它会寻找一个像是 network manager 或者 API client 这样的依赖项。交互器可能聚合来自多个源的数据来提供所需的信息，从而完成一个用例。最终，就由展示器来采集交互器反馈的数据，然后组织并进行展示。</p>

<p>数据存储模块负责提供实体给交互器。因为交互器要完成业务逻辑，因此它需要从数据存储中获取实体并操纵它们，然后将更新后的实体再放回数据存储中。数据存储管理实体的持久化，而实体应该对数据库全然不知，正因如此，实体并不知道如何对自己进行持久化。</p>

<p>交互器同样不需要知道如何将实体持久化，有时交互器更希望使用一个 data manager 来使其与数据存储的交互变得容易。Data manager 可以处理更多的针对存储的操作，比如创建获取请求，构建查询等等。这就使交互器能够将更多的注意力放在应用逻辑上，而不必再了解实体是如何被聚集或持久化的。下面我们举一个例子来说明使用 data manager 有意义的，这个例子假设你在使用 Core Data。这是示例应用程序的 data manager 的接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface VTDListDataManager : NSObject 
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong) VTDCoreDataStore *dataStore; 
</span><span class='line'> 
</span><span class='line'>- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate *)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock; 
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>当使用 TDD 来开发一个交互器时，是可以用一个测试用的模拟存储来代替生产环境的数据存储的。避免与远程服务器通讯（网络服务）以及避免读取磁盘（数据库）可以加快你测试的速度并加强其可重复性。</p>

<p>将数据存储保持为一个界限清晰的特定层的原因之一是，这可以让你延迟选择一个特定的持久化技术。如果你的数据存储是一个独立的类，那你就可以使用一个基础的持久化策略来开始你的应用，然后等到有意义的时候升级至 SQLite 或者 Core Data。而因为数据存储层的存在，你的应用代码库中就不需要改变任何东西。</p>

<p>在 iOS 的项目中使用 Core Data 经常比构架本身还容易引起更多争议。然而，利用 VIPER 来使用 Core Data 将给你带来使用 Core Data 的前所未有的良好体验。在持久化数据的工具层面上，Core Data 可以保持快速存取和低内存占用方面，简直是个神器。但是有个很恼人的地方，它会像触须一样把 NSManagedObjectContext 延伸至你所有的应用实现文件中，特别是那些它们不该待的地方。VIPER 可以使 Core Data 待在正确的地方：数据存储层。</p>

<p>在待办事项示例中，应用仅有的两部分知道使用了 Core Data，其一是数据存储本身，它负责建立 Core Data 堆栈；另一个是 data manager。Data manager 执行了获取请求，将数据存储返回的 NSManagedObject 对象转换为标准的 PONSO 模型对象，并传输回业务逻辑层。这样一来，应用程序核心将不再依赖于 Core Data，附加得到的好处是，你也再也不用担心过期数据 (stale) 和没有良好组织的多线程 NSManagedObjects 来糟蹋你的工作成果了。</p>

<p>在通过请求访问 Core Data 存储时，data manager 中看起来是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDListDataManager 
</span><span class='line'> 
</span><span class='line'>- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate*)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock 
</span><span class='line'>{ 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; 
</span><span class='line'> 
</span><span class='line'>    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"(date &gt;= %@) AND (date &lt;= %@)", [calendar dateForBeginningOfDay:startDate], [calendar dateForEndOfDay:endDate]]; 
</span><span class='line'>    NSArray *sortDescriptors = @[]; 
</span><span class='line'> 
</span><span class='line'>    __weak typeof(self) welf = self; 
</span><span class='line'>    [self.dataStore 
</span><span class='line'>     fetchEntriesWithPredicate:predicate 
</span><span class='line'>     sortDescriptors:sortDescriptors 
</span><span class='line'>     completionBlock:^(NSArray* entries) { 
</span><span class='line'>         if (completionBlock) 
</span><span class='line'>         { 
</span><span class='line'>             completionBlock([welf todoItemsFromDataStoreEntries:entries]); 
</span><span class='line'>         } 
</span><span class='line'>     }]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (NSArray*)todoItemsFromDataStoreEntries:(NSArray *)entries 
</span><span class='line'>{ 
</span><span class='line'>    return [entries arrayFromObjectsCollectedWithBlock:^id(VTDManagedTodoItem *todo) { 
</span><span class='line'>        return [VTDTodoItem todoItemWithDueDate:todo.date name:todo.name]; 
</span><span class='line'>    }]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>与 Core Data 一样极富争议的恐怕就是 UI 故事板了。故事板具有很多有用的功能，如果完全忽视它将会是一个错误。然而，调用故事版所能提供的所有功能来完成 VIPER 的所有目标仍然是很困难的。</p>

<p>我们所能做出的妥协就是选择不使用 segues 。有时候使用 segues 是有效的，但是使用 segues 的危险性在于它们很难原封不动地保持屏幕之间的分离，以及 UI 和应用逻辑之间的分离。一般来说，如果实现 prepareForSegue 方法是必须的话，我们就尽量不去使用 segues。</p>

<p>除此之外，故事板是一个实现用户界面布局有效方法，特别是在使用自动布局的时候。我们选择在实现待办事项两个界面的实例中使用故事板，并且使用这样的代码来执行自己的导航操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static NSString *ListViewControllerIdentifier = @"VTDListViewController"; 
</span><span class='line'> 
</span><span class='line'>@implementation VTDListWireframe 
</span><span class='line'> 
</span><span class='line'>- (void)presentListInterfaceFromWindow:(UIWindow *)window  
</span><span class='line'>{ 
</span><span class='line'>    VTDListViewController *listViewController = [self listViewControllerFromStoryboard]; 
</span><span class='line'>    listViewController.eventHandler = self.listPresenter; 
</span><span class='line'>    self.listPresenter.userInterface = listViewController; 
</span><span class='line'>    self.listViewController = listViewController; 
</span><span class='line'> 
</span><span class='line'>    [self.rootWireframe showRootViewController:listViewController 
</span><span class='line'>                                      inWindow:window]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (VTDListViewController *)listViewControllerFromStoryboard  
</span><span class='line'>{ 
</span><span class='line'>    UIStoryboard *storyboard = [self mainStoryboard]; 
</span><span class='line'>    VTDListViewController *viewController = [storyboard instantiateViewControllerWithIdentifier:ListViewControllerIdentifier]; 
</span><span class='line'>    return viewController; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (UIStoryboard *)mainStoryboard  
</span><span class='line'>{ 
</span><span class='line'>    UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"Main" 
</span><span class='line'>                                                         bundle:[NSBundle mainBundle]]; 
</span><span class='line'>    return storyboard; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<h5>使用 VIPER 构建模块</h5>

<p>一般在使用 VIPER 的时候，你会发现一个屏幕或一组屏幕倾向于聚在一起作为一个模块。模块可以以多种形式体现，但一般最好把它想成是一种特性。在播客应用中，一个模块可能是音频播放器或订阅浏览器。然而在我们的待办事项应用中，列表和添加事项的屏幕都将作为单独的模块被建立。</p>

<p>将你的应用作为一组模块来设计有很多好处，其中之一就是模块可以有非常明确和定义良好的接口，并且独立于其他的模块。这就使增加或者移除特性变得更加简单，也使在界面中向用户展示各种可变模块变得更加简单。</p>

<p>我们希望能将待办事项中各模块之间分隔更加明确，我们为添加模块定义了两个协议。一个是模块接口，它定义了模块可以做什么；另一个则是模块的代理，用来描述该模块做了什么。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddModuleInterface  
</span><span class='line'> 
</span><span class='line'>- (void)cancelAddAction; 
</span><span class='line'>- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate; 
</span><span class='line'> 
</span><span class='line'>@end 
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>@protocol VTDAddModuleDelegate  
</span><span class='line'> 
</span><span class='line'>- (void)addModuleDidCancelAddAction; 
</span><span class='line'>- (void)addModuleDidSaveAddAction; 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>因为模块必须要被展示，才能对用户产生价值，所以模块的展示器通常需要实现模型的接口。当另一个模型想要展现当前模块时，它的展示器就需要实现模型的委托协议，这样它就能在展示时知道当前模块做了些什么。</p>

<p>一个模块可能包括实体，交互器和管理器的通用应用逻辑层，这些通常可用于多个屏幕。当然，这取决于这些屏幕之间的交互及它们的相似度。一个模块可以像在待办事项列表里面一样，简单的只代表一个屏幕。这样一来，应用逻辑层对于它的特定模块的行为来说就非常特有了。</p>

<p>模块同样是组织代码的简便途径。将模块所有的编码都放在它自己的文件夹中并在 Xcode 中建一个 group，这会在你需要寻找和改变更加容易。当你在要寻找一个类时，它恰到好处地就在你所期待的地方，这种感觉真是无法形容的棒。</p>

<p>利用 VIPER 建立模块的另一个好处是它使得扩展到多平台时变得更加简单。独立在交互器层中的所有用例的应用逻辑允许你可以专注于为平板，电话或者 Mac 构建新的用户界面，同时可以重用你的应用层。</p>

<p>进一步来说，iPad 应用的用户界面能够将部分 iPhone 应用的视图，视图控制器及展示器进行再利用。在这种情况下，iPad 屏幕将由 ‘super’ 展示器和线框来代表，这样可以利用 iPhone 使用过的展示器和线框来组成屏幕。建立进而维护一个跨多平台的应用是一个巨大的挑战，但是好的构架可以对整个模型和应用层的再利用有大幅度的提升，并使其实现起来更加容易。</p>

<h5>利用 VIPER 进行测试</h5>

<p>VIPER 的出现激发了一个关注点的分离，这使得采用 TDD 变得更加简便。交互器包含独立与任何 UI 的纯粹逻辑，这使测试驱动开发更加简单。同时展示器包含用来为显示准备数据的逻辑，并且它也独立于任何一个 UIKit 部件。对于这个逻辑的开发也很容易用测试来驱动。</p>

<p>我们更倾向于先从交互器下手。用户界面里所有部分都服务于用例，而通过采用 TDD 来测试驱动交互器的 API 可以让你对用户界面和用例之间的关系有一个更好的了解。</p>

<p>作为实例，我们来看一下负责待办事项列表的交互器。寻找待办事项的策略是要找出所有的将在下周末前截止的项目，并将这些项目分别归类至截止于今天，明天，本周或者下周。</p>

<p>我们编写的第一个测试是为了保证交互器能够找到所有的截止于下周末的待办事项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFindingUpcomingItemsRequestsAllToDoItemsFromTodayThroughEndOfNextWeek 
</span><span class='line'>{ 
</span><span class='line'>    [[self.dataManager expect] todoItemsBetweenStartDate:self.today endDate:self.endOfNextWeek completionBlock:OCMOCK_ANY]; 
</span><span class='line'>    [self.interactor findUpcomingItems]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>一旦知道了交互器找到了正确的待办事项后，我们就需要编写几个小测试用来确认它确实将待办事项分配到了正确的相对日期组内（比如说今天，明天，等等）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFindingUpcomingItemsWithOneItemDueTodayReturnsOneUpcomingItemsForToday 
</span><span class='line'>{ 
</span><span class='line'>    NSArray *todoItems = @[[VTDTodoItem todoItemWithDueDate:self.today name:@"Item 1"]]; 
</span><span class='line'>    [self dataStoreWillReturnToDoItems:todoItems]; 
</span><span class='line'> 
</span><span class='line'>    NSArray *upcomingItems = @[[VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:self.today title:@"Item 1"]]; 
</span><span class='line'>    [self expectUpcomingItems:upcomingItems]; 
</span><span class='line'> 
</span><span class='line'>    [self.interactor findUpcomingItems]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>既然我们已经知道了交互器的 API 长什么样，接下来就是开发展示器。一旦展示器接收到了交互器传来的待办事项，我们就需要测试看看我们是否适当的将数据进行格式化并且在用户界面中正确的显示它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFoundZeroUpcomingItemsDisplaysNoContentMessage 
</span><span class='line'>{ 
</span><span class='line'>    [[self.ui expect] showNoContentMessage]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[]]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)testFoundUpcomingItemForTodayDisplaysUpcomingDataWithNoDay 
</span><span class='line'>{ 
</span><span class='line'>    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Today" 
</span><span class='line'>                                                          sectionImageName:@"check" 
</span><span class='line'>                                                                 itemTitle:@"Get a haircut" 
</span><span class='line'>                                                                itemDueDay:@""]; 
</span><span class='line'>    [[self.ui expect] showUpcomingDisplayData:displayData]; 
</span><span class='line'> 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar gregorianCalendar]; 
</span><span class='line'>    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29]; 
</span><span class='line'>    VTDUpcomingItem *haircut = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:dueDate title:@"Get a haircut"]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[haircut]]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)testFoundUpcomingItemForTomorrowDisplaysUpcomingDataWithDay 
</span><span class='line'>{ 
</span><span class='line'>    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Tomorrow" 
</span><span class='line'>                                                          sectionImageName:@"alarm" 
</span><span class='line'>                                                                 itemTitle:@"Buy groceries" 
</span><span class='line'>                                                                itemDueDay:@"Thursday"]; 
</span><span class='line'>    [[self.ui expect] showUpcomingDisplayData:displayData]; 
</span><span class='line'> 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar gregorianCalendar]; 
</span><span class='line'>    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29]; 
</span><span class='line'>    VTDUpcomingItem *groceries = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationTomorrow dueDate:dueDate title:@"Buy groceries"]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[groceries]]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>同样需要测试的是应用是否在用户想要新建待办事项时正确启动了相应操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAddNewToDoItemActionPresentsAddToDoUI 
</span><span class='line'>{ 
</span><span class='line'>    [[self.wireframe expect] presentAddInterface]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter addNewEntry]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>这时我们可以开发视图功能了，并且在没有待办事项的时候我们想要展示一个特殊的信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testShowingNoContentMessageShowsNoContentView 
</span><span class='line'>{ 
</span><span class='line'>    [self.view showNoContentMessage]; 
</span><span class='line'> 
</span><span class='line'>    XCTAssertEqualObjects(self.view.view, self.view.noContentView, @"the no content view should be the view"); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>有待办事项出现时，我们要确保列表是显示出来的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testShowingUpcomingItemsShowsTableView 
</span><span class='line'>{ 
</span><span class='line'>    [self.view showUpcomingDisplayData:nil]; 
</span><span class='line'> 
</span><span class='line'>    XCTAssertEqualObjects(self.view.view, self.view.tableView, @"the table view should be the view"); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>首先建立交互器是一种符合 TDD 的自然规律。如果你首先开发交互器，紧接着是展示器，你就可以首先建立一个位于这些层的套件测试，并且为实现这是实例奠定基础。由于你不需要为了测试它们而去与用户界面进行交互，所以这些类可以进行快速迭代。在你需要开发视图的时候，你会有一个可以工作并测试过的逻辑和表现层来与其进行连接。在快要完成对视图的开发时，你会发现第一次运行程序时所有部件都运行良好，因为你所有已通过的测试已经告诉你它可以工作。</p>

<h5>结论</h5>

<p>我们希望你喜欢这篇对 VIPER 的介绍。或许你们都很好奇接下来应该做什么，如果你希望通过 VIPER 来对你下一个应用进行设计，该从哪里开始呢？</p>

<p>我们竭尽全力使这篇文章和我们利用 VIPER 实现的应用实例足够明确并且进行了很好的定义。我们的待办事项里列表程序相当直接简单，但是它准确地解释了如何利用 VIPER 来建立一个应用。在实际的项目中，你可以根据你自己的挑战和约束条件来决定要如何实践这个例子。根据以往的经验，我们的每个项目在使用 VIPER 时都或多或少地改变了一些策略，但它们无一例外的都从中得益，找到了正确的方向。</p>

<p>很多情况下由于某些原因，你可能会想要偏离 VIPER 所指引的道路。可能你遇到了很多 &lsquo;bunny&rsquo; 对象，或者你的应用使用了故事板的 segues。没关系的，在这些情况下，你只需要在做决定时稍微考虑下 VIPER 所代表的精神就好。VIPER 的核心在于它是建立在单一责任原则上的架构。如果你碰到了些许麻烦，想想这些原则再考虑如何前进。</p>

<p>你一定想知道在现有的应用中能否只用 VIPER 。在这种情况下，你可以考虑使用 VIPER 构建新的特性。我们许多现有项目都使用了这个方法。你可以利用 VIPER 建立一个模块，这能帮助你发现许多建立在单一责任原则基础上造成难以运用架构的现有问题。</p>

<p>软件开发最伟大的事情之一就是每个应用程序都是不同的，而设计每个应用的架构的方式也是不同的。这就意味着每个应用对于我们来说都是一个学习和尝试的机遇，如果你决定开始使用 VIPER，你会受益匪浅。感谢你的阅读。</p>

<h5>Swift 补充</h5>

<p>苹果上周在 WWDC 介绍了一门称之为 Swift 的编程语言来作为 Cocoa 和 Cocoa Touch 开发的未来。现在发表关于 Swift 的完整意见还为时尚早，但众所周知编程语言对我们如何设计和构建应用有着重大影响。我们决定使用 Swift 重写我们的待办事项清单，帮助我们学习它对 VIPER 意味着什么。至今为止，收获颇丰。Swift 中的一些特性对于构建应用的体验有着显著的提升。</p>

<h5>结构体</h5>

<p>在 VIPER 中我们使用小型，轻量级的 model 类来在比如从展示器到视图这样不同的层间传递数据。这些 PONSOs 通常是只是简单地带有少量数据，并且通常这些类不会被继承。Swift 的结构体非常适合这个情况。下面的结构体的例子来自 VIPER Swift。这个结构体需要被判断是否相等，所以我们重载了 == 操作符来比较这个类型的两个实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct UpcomingDisplayItem : Equatable, Printable { 
</span><span class='line'>    let title : String = "" 
</span><span class='line'>    let dueDate : String = "" 
</span><span class='line'> 
</span><span class='line'>    var description : String { get { 
</span><span class='line'>        return "\(title) -- \(dueDate)" 
</span><span class='line'>    }} 
</span><span class='line'> 
</span><span class='line'>    init(title: String, dueDate: String) { 
</span><span class='line'>        self.title = title 
</span><span class='line'>        self.dueDate = dueDate 
</span><span class='line'>    } 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>func == (leftSide: UpcomingDisplayItem, rightSide: UpcomingDisplayItem) -&gt; Bool { 
</span><span class='line'>    var hasEqualSections = false 
</span><span class='line'>    hasEqualSections = rightSide.title == leftSide.title 
</span><span class='line'> 
</span><span class='line'>    if hasEqualSections == false { 
</span><span class='line'>        return false 
</span><span class='line'>    } 
</span><span class='line'> 
</span><span class='line'>    hasEqualSections = rightSide.dueDate == rightSide.dueDate 
</span><span class='line'> 
</span><span class='line'>    return hasEqualSections 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>类型安全</h5>

<p>也许 Objective-C 和 Swift 的最大区别是它们在对于类型处理上的不同。 Objective-C 是动态类型，而 Swift 故意在编译时做了严格的类型检查。对于一个类似 VIPER 的架构， 应用由不同层构成，类型安全是提升程序员效率和设计架构有非常大的好处。编译器帮助你确保正确类型的容器和对象在层的边界传递。如上所示，这是一个使用结构体的好地方。如果一个结构体的被设计为存在于两层之间，那么由于类型安全，你可以保证它将永远无法脱离这些层之间。</p>

<h5>扩展阅读</h5>

<p><a href="https://github.com/objcio/issue-13-viper">VIPER TODO, 文章示例</a></p>

<p><a href="https://github.com/objcio/issue-13-viper-swift">VIPER SWIFT, 基于 Swift 的文章示例</a></p>

<p><a href="https://github.com/mutualmobile/Counter">另一个计数器应用</a></p>

<p><a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">Mutual Mobile 关于 VIPER 的介绍</a></p>

<p><a href="http://blog.8thlight.com/uncle-bob/2011/11/22/Clean-Architecture.html">简明架构</a></p>

<p><a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a></p>

<p><a href="http://objccn.io/issue-1-3/">测试 View Controllers</a></p>

<p><a href="http://inessential.com/2014/03/16/smaller_please">Bunnies</a></p>
]]></content>
  </entry>
  
</feed>
