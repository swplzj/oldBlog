<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[李振杰]]></title>
  <link href="http://swplzj.github.io/atom.xml" rel="self"/>
  <link href="http://swplzj.github.io/"/>
  <updated>2015-02-12T17:11:49+08:00</updated>
  <id>http://swplzj.github.io/</id>
  <author>
    <name><![CDATA[LeeZhenjie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[1215]]></title>
    <link href="http://swplzj.github.io/blog/2014/12/14/1215/"/>
    <updated>2014-12-14T19:02:27+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/12/14/1215</id>
    <content type="html"><![CDATA[<p>The Greatest Love Of All</p>

<p>I believe the children is our future</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wo]]></title>
    <link href="http://swplzj.github.io/blog/2014/12/14/wo/"/>
    <updated>2014-12-14T17:30:40+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/12/14/wo</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tenth_blog]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/21/tenth-blog/"/>
    <updated>2014-09-21T21:34:12+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/21/tenth-blog</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[接口实例]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/21/jie-kou-shi-li/"/>
    <updated>2014-09-21T18:31:05+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/21/jie-kou-shi-li</id>
    <content type="html"><![CDATA[<h1>categ</h1>

<hr />

<h3>获取商城分类列表</h3>

<p><code>接口URL</code></p>

<h4><a href="http:/www.categ.php">http:/www.categ.php</a></h4>

<p><code>HTTP请求方式</code></p>

<h4>POST</h4>

<p><code>请求参数</code></p>

<table>
<thead>
<tr>
<th style="text-align:left;">请求参数  </th>
<th style="text-align:left;">   类型及范围     </th>
<th style="text-align:left;">   说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">request </td>
<td style="text-align:left;"> String            </td>
<td style="text-align:left;">   请求接口名称</td>
</tr>
</tbody>
</table>


<!--more-->


<p><code>返回结果 — 成功</code></p>

<pre><code>{
"response": "categ",
"category": [
    {
        "id": "129",
        "name": "手机数码",
        "cat_thumb": "images/category/small_pic/129.png",
        "url": "category.php",
        "cat_id": [
            {
                "id": "130",
                "name": "手机",
                "url": "category.php",
                "cat_id": [
                    {
                        "id": "146",
                        "name": "苹果",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "147",
                        "name": "三星",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "148",
                        "name": "小米",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "149",
                        "name": "红米",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "150",
                        "name": "魅族",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "151",
                        "name": "华为",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "180",
                        "name": "NIT",
                        "url": "category.php",
                        "cat_id": []
                    }
                ]
            },
            {
                "id": "131",
                "name": "电脑",
                "url": "category.php",
                "cat_id": [
                    {
                        "id": "152",
                        "name": "苹果",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "153",
                        "name": "三星",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "171",
                        "name": "联想",
                        "url": "category.php",
                        "cat_id": []
                    }
                ]
            },
            {
                "id": "132",
                "name": "耳机/音箱",
                "url": "category.php",
                "cat_id": [
                    {
                        "id": "154",
                        "name": "JBL",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "155",
                        "name": "法拉利",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "156",
                        "name": "Beats",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "157",
                        "name": "PRECISION",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "165",
                        "name": "Aftershokz",
                        "url": "category.php",
                        "cat_id": []
                    }
                ]
            },
            {
                "id": "164",
                "name": "移动电源",
                "url": "category.php",
                "cat_id": []
            }
        ]
    },
    {
        "id": "120",
        "name": "创意生活",
        "cat_thumb": "images/category/small_pic/120.png",
        "url": "category.php",
        "cat_id": [
            {
                "id": "160",
                "name": "wavebetter",
                "url": "category.php",
                "cat_id": []
            },
            {
                "id": "161",
                "name": "莱克",
                "url": "category.php",
                "cat_id": []
            },
            {
                "id": "162",
                "name": "小黑伞",
                "url": "category.php",
                "cat_id": []
            }
        ]
    },
    {
        "id": "67",
        "name": "运动户外",
        "cat_thumb": "images/category/small_pic/67.png",
        "url": "category.php",
        "cat_id": [
            {
                "id": "80",
                "name": "智能穿戴",
                "url": "category.php",
                "cat_id": []
            },
            {
                "id": "145",
                "name": "户外休闲",
                "url": "category.php",
                "cat_id": [
                    {
                        "id": "158",
                        "name": "INUK",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "159",
                        "name": "海马",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "166",
                        "name": "新秀丽",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "167",
                        "name": "威戈",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "169",
                        "name": "外交官",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "170",
                        "name": "哆啦A梦",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "182",
                        "name": "H2X",
                        "url": "category.php",
                        "cat_id": []
                    },
                    {
                        "id": "190",
                        "name": "NBA",
                        "url": "category.php",
                        "cat_id": []
                    }
                ]
            }
        ]
    },
    {
        "id": "116",
        "name": "时尚奢品",
        "cat_thumb": "images/category/small_pic/116.png",
        "url": "category.php",
        "cat_id": [
            {
                "id": "117",
                "name": "手提包/钱包",
                "url": "category.php",
                "cat_id": [
                    {
                        "id": "172",
                        "name": "COACH",
                        "url": "category.php",
                        "cat_id": []
                    }
                ]
            },
            {
                "id": "118",
                "name": "手表",
                "url": "category.php",
                "cat_id": [
                    {
                        "id": "173",
                        "name": "EMPORIO ARMANI",
                        "url": "category.php",
                        "cat_id": []
                    }
                ]
            },
            {
                "id": "119",
                "name": "皮带",
                "url": "category.php",
                "cat_id": []
            }
        ]
    },
    {
        "id": "125",
        "name": "家居用品",
        "cat_thumb": "images/category/small_pic/125.png",
        "url": "category.php",
        "cat_id": [
            {
                "id": "163",
                "name": "欧姆龙",
                "url": "category.php",
                "cat_id": []
            }
        ]
    },
    {
        "id": "112",
        "name": "汽车周边",
        "cat_thumb": "images/category/small_pic/112.png",
        "url": "category.php",
        "cat_id": [
            {
                "id": "113",
                "name": "JBL",
                "url": "category.php",
                "cat_id": []
            },
            {
                "id": "189",
                "name": "NBA",
                "url": "category.php",
                "cat_id": []
            }
        ]
    }
]
}
</code></pre>

<p><code>参数说明</code></p>

<p>参数名称            |   说明    <br/>
:&mdash;&mdash;&mdash;&mdash;&ndash; | :&mdash;&mdash;&mdash;&mdash;-
response        | 响应接口结果
category        | 商城商
id              | 商品
name            | 商品
cat_thumb       | 商品
url             | 商品
cat_id          | 商品
<code>返回结果 — 失败</code></p>

<pre><code>{
    "response":"error"
}
</code></pre>

<p><code>参数说明</code></p>

<table>
<thead>
<tr>
<th style="text-align:left;">参数名称            </th>
<th style="text-align:left;">   说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">response        </td>
<td style="text-align:left;"> 响应接口结果</td>
</tr>
</tbody>
</table>


<p><a href="error_code.html">返回错误，详见错误代码页</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[移动App架构设计]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/21/geng-huan-zhu-ti/"/>
    <updated>2014-09-21T16:47:01+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/21/geng-huan-zhu-ti</id>
    <content type="html"><![CDATA[<p>Native app的开发相比传统的项目迭代周期要短很多, 需求的变化也频繁一些, 在开发的不同生命周期里采用不同的架构模式可以有效的节约开发时间, 提高开发效率, 这篇文章介绍几种常用的架构模式:</p>

<!--more-->


<h4>表现层</h4>

<h5>基本的MVC</h5>

<p>移动app一般都是采用经典的mvc架构</p>

<table>
<thead>
<tr>
<th>层次</th>
<th>作用</th>
<th>设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>模型层(model)</td>
<td>封装了应用的一系列数据, 并定义了操作, 处理这些数据的逻辑和计算规则。</td>
<td>通过Notification,KVO对控制器进行反馈</td>
</tr>
<tr>
<td>视图层(view)</td>
<td>视图对象是一个应用中, 用户可以看到的对象. 视图对象知道如何绘制自己, 也能够响应用户的操作. 视图对象的主要目的之一是将应用模型对象中的数据显示出来, 并允许用户编辑该数据</td>
<td>视图通过不能直接操作模型层, 通过target-action, delegate, dataSource和控制器进行反馈</td>
</tr>
<tr>
<td>控制器层(controller)</td>
<td>控制器层是在视图层和若干个模型层的中间人</td>
<td>c可以直接操作模型层和视图层</td>
</tr>
</tbody>
</table>


<!--层次      | 作用     | 设计原则
-------|-------|-------
模型层(model)|   封装了应用的一系列数据, 并定义了操作, 处理这些数据的逻辑和计算规则。|通过Notification,KVO对控制器进行反馈
视图层(view) |视图对象是一个应用中, 用户可以看到的对象. 视图对象知道如何绘制自己, 也能够响应用户的操作. 视图对象的主要目的之一是将应用模型对象中的数据显示出来, 并允许用户编辑该数据 |视图通过不能直接操作模型层, 通过target-action, delegate, dataSource和控制器进行反馈
控制器层(controller)    |控制器层是在视图层和若干个模型层的中间人| c可以直接操作模型层和视图层
-->


<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvc.png" alt="id1" /></p>

<h5>总结:</h5>

<ul>
<li>C对M：API</li>
<li>C对V：Outlet</li>
<li>V对C：Target-action， Delegate，Datasource</li>
<li>M对C：Notification，KVO</li>
</ul>


<h5>MVC的改进版 MVVM</h5>

<p>MVVM是在MVC的基础上多了一个View Model: 表示逻辑, 将 model 的数据转换为 view 可以呈现的东西. 适合大量展示类的App.</p>

<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvvm.png" alt="id2" /></p>

<h5>HMVC</h5>

<p>Hierarchical MVC, 把客户端应用程序分解为有层次的父子关系的MVC, 反复应用这个模式, 形成结构化的客户端架构. 适合重型B/S架构的WebApp.</p>

<p>一个MVC模块由应用程序的一个模块抽象而成. 其中很重要的一个概念就是 Parent MVC , 它可以对应界面上的实体, 也可以是一个抽象的对象. 设想一个app 有标签栏, 工具栏, 导航栏, 主工作区, 对应到HMVC上就是这个app最底部的标签栏 是 Layer1, Layer2 导航栏,主要工作区, 工具栏. 如果觉得 Layer2 太复杂可以吧主要工作区放到 Layer3, 依次类推.</p>

<p>Controller 是功能模块的总控室, 它负责和子Controller或父Controller通信，并通知它的 View 处理改变界面显示, Model 处理一些业务逻辑或数据库访问操作. 如才的例子里, 点击了工具栏里的一个按钮, 工具栏的Controller 响应这个event, 发现是要切换主工作区, 工具栏做不了,就传递他的父Controller处理(如果父Controller也处理不了, 就继续往上传递)然后标签栏的Controller处理切换主工作区.</p>

<p>优点:</p>

<p>把程序分成了几个部分, 降低了依赖性
支持鼓励重用代码, 组件或者模块。
在今后的维护中, 提高了可扩展性。</p>

<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/hmvc.png" alt="id3" /></p>

<h4>分层设计</h4>

<h5>三层架构</h5>

<p>我们在来看一下经典的三层架构</p>

<p>从上至下为</p>

<ul>
<li>表现层(UI)</li>
<li>业务逻辑层或称为领域层(BLL)</li>
<li>数据访问层(DAL)</li>
</ul>


<table>
<thead>
<tr>
<th>层次  </th>
<th> 作用    </th>
<th>设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>表现层(UI) </td>
<td> 向用户展现特定业务数据，采集用户的输入信息和操 </td>
<td>用户至上，兼顾简洁；不包含任何业务相关的逻辑处理</td>
</tr>
<tr>
<td>业务逻辑层(BLL)    </td>
<td>从ＤＡＬ中获取数据, 在ＵＩ显示; 从ＵＩ中获取用户指令和数据, 执行业务逻辑或通过ＤＡＬ写入数据源 </td>
<td> 作为U层与Ｄ层的桥梁,目的在于展现清晰的函数结构, 只负责数据处理传递, 不涉及ＳＱＬ语句和ＡＤＯ.ＮＥＴ</td>
</tr>
<tr>
<td>数据访问层(DAL)    </td>
<td> 直接操作数据库，针对数据的增添 删除 修改 查找; 具体为业务逻辑层或表示层提供数据服务。</td>
<td> 专门操作数据库, 不考虑数据合法性. 数据库错误返回－1, 逻辑错误返回0, 并告知错误原因, 成功返回1</td>
</tr>
</tbody>
</table>


<p><img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/mvc_vs_3.png" alt="id4" /></p>

<p>然后呢,我们现在的架构则是
<img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/3.png" alt="id5" /></p>

<h5>四层架构</h5>

<p>在三层架构的基础上多了业务规则层, 通常的三层是把业务逻辑和业务规则合并为一个层，统称为业务层. 业务规则层的提出,既可以及时处理用户输入的不合法信息, 又可以及时处理数据库错误, 增大了业务逻辑层的结构清晰度, 让业务逻辑人员专心致志做逻辑.</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>业务规则层</li>
<li>业务逻辑层或称为领域层</li>
<li>数据访问层</li>
</ul>


<table>
<thead>
<tr>
<th>层次  </th>
<th>作用</th>
<th>    设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>业务规则层(ECL)</td>
<td>   对于UI层传下来的参数来说，检查合法性。</td>
<td>用户至上，兼顾简洁；不包含任何业务相关的逻辑处理</td>
</tr>
</tbody>
</table>


<h5>五层架构</h5>

<p>一般情况下, 我们的业务逻辑放在中间层, 那么对内部的这些大量种类繁多，使用方法也各异的不同的类的调用任务，就完全落到了表示层. 这样势必会增加表示层的代码量, 将表示层的任务复杂化, 和表示层只负责接受用户的输入并返回结果的任务不太相称, 并增加了层与层之间的耦合程度. 因此呢,我们需要增加接口去去统一的管理这些业务, 是设计模式中Facade模式的思想.</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>业务外观层</li>
<li>业务规则层</li>
<li>业务逻辑层或称为领域层</li>
<li>数据访问层</li>
</ul>


<table>
<thead>
<tr>
<th>层次</th>
<th> 作用</th>
<th>     设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>业务外观层 </td>
<td>为负责子系统中的一组接口提供一个一致而且简单的接口。</td>
<td></td>
</tr>
</tbody>
</table>


<h5>引入service层</h5>

<p>引入service层的架构和普通的分层架构的不同是: service层内部有数据, 可以单独运行.</p>

<p>service</p>

<p>从上至下为</p>

<ul>
<li>表现层</li>
<li>服务层(service)</li>
<li>数据访问层</li>
<li>业务逻辑层</li>
</ul>


<table>
<thead>
<tr>
<th>层次</th>
<th> 作用  </th>
<th> 设计原则</th>
</tr>
</thead>
<tbody>
<tr>
<td>表现层   </td>
<td>显示与用户的互交   </td>
<td></td>
</tr>
<tr>
<td>服务层   </td>
<td>service层提供表现层的业务逻辑入口,通过定义接口服务的形式,通过接口调用来完成.</td>
<td></td>
</tr>
<tr>
<td>业务逻辑层 </td>
<td>1接收服务层传来的DTO, 然后根据业务规则, 对传入的DTO进行加工, 返回加工后的信息 2 需要为每个对象提供业务行为, 并且这些对象之间是独立的 3 业务对象之间的交互流程通过服务层来组织</td>
<td></td>
</tr>
<tr>
<td>数据访问层 </td>
<td>本地数据远程数据的访问接口    </td>
<td></td>
</tr>
</tbody>
</table>


<h5>新秀VIPER</h5>

<p>viper这里不多说了,请想了解的自行搜索
<img src="https://github.com/uxyheaven/NativeAppFrameworkDesign/raw/master/image/viper.png" alt="id6" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Modify]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/18/modify/"/>
    <updated>2014-09-18T13:42:04+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/18/modify</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用VIPER构建iOS应用]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/17/five-blog/"/>
    <updated>2014-09-17T20:33:17+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/17/five-blog</id>
    <content type="html"><![CDATA[<p>建筑领域流行这样一句话，“我们虽然在营造建筑，但建筑也会重新塑造我们”。正如所有开发者最终领悟到的，这句话同样适用于构建软件。</p>

<p>编写代码中至关重要的是，需要使每一部分容易被识别，赋有一个特定而明显的目的，并与其他部分在逻辑关系中完美契合。这就是我们所说的软件架构。好的架构不仅让一个产品成功投入使用，还可以让产品具有可维护性，并让人不断头脑清醒的对它进行维护！</p>

<!--more-->


<p>在这篇文章中，我们介绍了一种称之为 <a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">VIPER</a> 的 iOS 应用架构的方式。VIPER 已经在很多大型的项目上成功实践，但是出于本文的目的我们将通过一个待办事项清单 (to-do app) 来介绍 VIPER 。你可以在 <a href="https://github.com/objcio/issue-13-viper">GitHub</a> 上关注这个项目。</p>

<h5>什么是 VIPER？</h5>

<p>测试永远不是构建 iOS 应用的主要部分。当我们 <a href="https://github.com/mutualmobile/">Mutual Mobile</a> 着手改善我们的测试实践时，我们发现给 iOS 应用写测试代码非常困难。因此如果想要设法改变测试的现状，我们首先需要一个更好的方式来架构应用，我们称之为 VIPER。</p>

<p>VIPER 是一个创建 iOS 应用<a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">简明构架</a>的程序。VIPER 可以是视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Routing) 的首字母缩写。简明架构将一个应用程序的逻辑结构划分为不同的责任层。这使得它更容易隔离依赖项 (如数据库)，也更容易测试各层间的边界处的交互：
<img src="http://www.cocoachina.com/cms/uploads/allimg/140703/8370_140703100012_1.jpg" alt="id1" /></p>

<p>大部分 iOS 应用利用 MVC 构建，使用 MVC 应用程序架构可以引导你将每一个类看做模型，视图或控制器中的一个。但由于大部分应用程序的逻辑不会存在于模型或视图中，所以通常最终总是在控制器里实现。这就导致一个称为<a href="https://twitter.com/Colin_Campbell/status/293167951132098560">重量级视图控制器</a>的问题，在这里，视图控制器做了太多工作。为这些重量级视图控制器<a href="http://www.objc.io/issue-1/lighter-view-controllers.html">瘦身</a>并不是 iOS 开发者寻求提高代码的质量所要面临的唯一挑战，但至少这是一个很好的开端。</p>

<p>VIPER 的不同层提供了明确的程序逻辑以及导航控制代码来应对这个挑战，利用 VIPER ，你会注意到在我们的待办事项示例清单中的视图控制器可以简洁高效，意义明确地控制视图。你也会发现视图控制器中代码和所有的其他类很容易理解，容易测试，理所当然也更易维护。</p>

<h5>基于用例的应用设计</h5>

<p>应用通常是一些用户用例的集合。用例也被称为验收标准，或行为集，它们用来描述应用的用途。清单可以根据时间，类型以及名字排序，这就是一个用例。用例是应用程序中用来负责业务逻辑的一层，应独立于用户界面的实现，同时要足够小，并且有良好的定义。决定如何将一个复杂的应用分解成较小的用例非常具有挑战性，并且需要长期实践，但这对于缩小你解决的问题时所要面临的范围及完成的每个类的所要涉及的内容来说，是很有帮助的。</p>

<p>利用 VIPER 建立一个应用需要实施一组套件来满足所有的用例，应用逻辑是实现用例的主要组成部分，但却不是唯一。用例也会影响用户界面。另一个重要的方面，是要考虑用例如何与其他应用程序的核心组件相互配合，例如网络和数据持久化。组件就好比用例的插件，VIPER 则用来描述这些组件的作用是什么，如何进行交互。</p>

<p>我们其中一个用例，或者说待办事项清单中其中的一个需求是可以基于用户的选择来将待办事项分组。通过分离的逻辑将数据组织成一个用例，我们能够在测试时使用户界面代码保持干净，用例更易组装，从而确保它如我们预期的方式工作。</p>

<h5>VIPER 的主要部分</h5>

<p>VIPER 的主要部分是：</p>

<p>视图：根据展示器的要求显示界面，并将用户输入反馈给展示器。
交互器：包含由用例指定的业务逻辑。
展示器：包含为显示（从交互器接受的内容）做的准备工作的相关视图逻辑，并对用户输入进行反馈（从交互器获取新数据）。
实体：包含交互器要使用的基本模型对象。
路由：包含用来描述屏幕显示和显示顺序的导航逻辑。</p>

<p>这种分隔形式同样遵循<a href="http://www.objectmentor.com/resources/articles/srp.pdf">单一责任原则</a>。交互器负责业务分析的部分，展示器代表交互设计师，而视图相当于视觉设计师。</p>

<p>以下则是不同组件的相关图解，并展示了他们之间是如何关联的：</p>

<p><img src="http://www.cocoachina.com/cms/uploads/allimg/140703/8370_140703100110_1.png" alt="id2" /></p>

<p>虽然在应用中 VIPER 的组件可以以任意顺序实现，我们在这里选择按照我们推荐的顺序来进行介绍。你会注意到这个顺序与构建整个应用的进程大致符合 &ndash; 首先要讨论的是产品需要做什么，以及用户会如何与之交互。</p>

<h5>交互器</h5>

<p>交互器在应用中代表着一个独立的用例。它具有业务逻辑以操纵模型对象（实体）执行特定的任务。交互器中的工作应当独立与任何用户界面，同样的交互器可以同时运用于 iOS 应用或者 OS X 应用中。</p>

<p>由于交互器是一个 PONSO (Plain Old NSObject，普通的 NSObject)，它主要包含了逻辑，因此很容易使用 TDD 进行开发。</p>

<p>示例应用的主要用例是向用户展示所有的待办事项（比如任何截止于下周末的任务）。此类用例的业务逻辑主要是找出今天至下周末之间将要到期的待办事项，然后为它们分配一个相对的截止日期，比如今天，明天，本周以内，或者下周。</p>

<p>以下是来自 VTDListInteractor 的对应方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)findUpcomingItems 
</span><span class='line'>{ 
</span><span class='line'>    __weak typeof(self) welf = self; 
</span><span class='line'>    NSDate* today = [self.clock today]; 
</span><span class='line'>    NSDate* endOfNextWeek = [[NSCalendar currentCalendar] dateForEndOfFollowingWeekWithDate:today]; 
</span><span class='line'>    [self.dataManager todoItemsBetweenStartDate:today endDate:endOfNextWeek completionBlock:^(NSArray* todoItems) { 
</span><span class='line'>        [welf.output foundUpcomingItems:[welf upcomingItemsFromToDoItems:todoItems]]; 
</span><span class='line'>    }]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<h5>实体</h5>

<p>实体是被交互器操作的模型对象，并且它们只被交互器所操作。交互器永远不会传输实体至表现层 (比如说展示器)。</p>

<p>实体也应该是 PONSOs。如果你使用 Core Data，最好是将托管对象保持在你的数据层之后，交互器不应与 NSManageObjects 协同工作。</p>

<p>这里是我们的待办事项服务的实体：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface VTDTodoItem : NSObject 
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong)   NSDate*     dueDate; 
</span><span class='line'>@property (nonatomic, copy)     NSString*   name; 
</span><span class='line'> 
</span><span class='line'>+ (instancetype)todoItemWithDueDate:(NSDate*)dueDate name:(NSString*)name; 
</span><span class='line'> 
</span><span class='line'>@end 
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>不要诧异于你的实体仅仅是数据结构，任何依赖于应用的逻辑都应该放到交互器中。</p>

<h5>展示器</h5>

<p>展示器是一个主要包含了驱动用户界面的逻辑的 PONSO，它总是知道何时呈现用户界面。基于其收集来自用户交互的输入功能，它可以在合适的时候更新用户界面并向交互器发送请求。</p>

<p>当用户点击 “+” 键新建待办事项时，addNewEntry 被调用。对于此项操作，展示器会要求 wireframe 显示用户界面以增加新项目：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addNewEntry 
</span><span class='line'>{ 
</span><span class='line'>    [self.listWireframe presentAddInterface]; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>展示器还会从交互器接收结果并将结果转换成能够在视图中有效显示的形式。</p>

<p>下面是如何从交互器接受待办事项的过程，其中包含了处理数据的过程并决定展现给用户哪些内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)foundUpcomingItems:(NSArray*)upcomingItems 
</span><span class='line'>{ 
</span><span class='line'>    if ([upcomingItems count] == 0) 
</span><span class='line'>    { 
</span><span class='line'>        [self.userInterface showNoContentMessage]; 
</span><span class='line'>    } 
</span><span class='line'>    else 
</span><span class='line'>    { 
</span><span class='line'>        [self updateUserInterfaceWithUpcomingItems:upcomingItems]; 
</span><span class='line'>    } 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>实体永远不会由交互器传输给展示器，取而代之，那些无行为的简单数据结构会从交互器传输到展示器那里。这就防止了那些“真正的工作”在展示器那里进行，展示器只能负责准备那些在视图里显示的数据。</p>

<h5>视图</h5>

<p>视图一般是被动的，它通常等待展示器下发需要显示的内容，而不会向其索取数据。视图（例如登录界面的登录视图控件）所定义的方法应该允许展示器在高度抽象的层次与之交流。展示器通过内容进行表达，而不关心那些内容所显示的样子。展示器不知道 UILabel，UIButton 等的存在，它只知道其中包含的内容以及何时需要显示。内容如何被显示是由视图来进行控制的。</p>

<p>视图是一个抽象的接口 (Interface)，在 Objective-C 中使用协议被定义。一个 UIViewController 或者它的一个子类会实现视图协议。比如我们的示例中 “添加” 界面会有以下接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddViewInterface  
</span><span class='line'> 
</span><span class='line'>- (void)setEntryName:(NSString *)name; 
</span><span class='line'>- (void)setEntryDueDate:(NSDate *)date; 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>视图和视图控制器同样会操纵用户界面和相关输入。因为通常来说视图控制器是最容易处理这些输入和执行某些操作的地方，所以也就不难理解为什么视图控制器总是这么大了。为了使视图控制器保持苗条，我们需要使它们在用户进行相关操作的时候可以有途径来通知相关部分。视图控制器不应当根据这些行为进行相关决定，但是它应当将发生的事件传递到能够做决定的部分。</p>

<p>在我们的例子中，Add View Controller 有一个事件处理的属性，它实现了如下接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddModuleInterface  
</span><span class='line'> 
</span><span class='line'>- (void)cancelAddAction; 
</span><span class='line'>- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate 
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>当用户点击取消键的时候，视图控制器告知这个事件处理程序用户需要其取消这次添加的动作。这样一来，事件处理程序便可以处理关闭 add view controller 并告知列表视图进行更新。</p>

<p>视图和展示器之间边界处是一个使用 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> 的好地方。在这个示例中，视图控制器可以返回一个代表按钮操作的信号。这将允许展示器在不打破职责分离的前提下轻松地对那些信号进行响应。</p>

<h5>路由</h5>

<p>屏幕间的路径会在交互设计师创建的线框 (wireframes) 里进行定义。在 VIPER 中，路由是由两个部分来负责的：展示器和线框。一个线框对象包括 UIWindow，UINavigationController，UIViewController 等部分，它负责创建视图/视图控制器并将其装配到窗口中。</p>

<p>由于展示器包含了响应用户输入的逻辑，因此它就拥有知晓何时导航至另一个屏幕以及具体是哪一个屏幕的能力。而同时，线框知道如何进行导航。在两者结合起来的情况下，展示器可以使用线框来进行实现导航功能，它们两者一起描述了从一个屏幕至另一个屏幕的路由过程。</p>

<p>线框同时也明显是一个处理导航转场动画的地方。来看看这个 add wireframe 中的例子吧：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDAddWireframe 
</span><span class='line'> 
</span><span class='line'>- (void)presentAddInterfaceFromViewController:(UIViewController *)viewController  
</span><span class='line'>{ 
</span><span class='line'>    VTDAddViewController *addViewController = [self addViewController]; 
</span><span class='line'>    addViewController.eventHandler = self.addPresenter; 
</span><span class='line'>    addViewController.modalPresentationStyle = UIModalPresentationCustom; 
</span><span class='line'>    addViewController.transitioningDelegate = self; 
</span><span class='line'> 
</span><span class='line'>    [viewController presentViewController:addViewController animated:YES completion:nil]; 
</span><span class='line'> 
</span><span class='line'>    self.presentedViewController = viewController; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>#pragma mark - UIViewControllerTransitioningDelegate Methods 
</span><span class='line'> 
</span><span class='line'>- (id)animationControllerForDismissedController:(UIViewController *)dismissed  
</span><span class='line'>{ 
</span><span class='line'>    return [[VTDAddDismissalTransition alloc] init]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (id)animationControllerForPresentedController:(UIViewController *)presented 
</span><span class='line'>                                                                  presentingController:(UIViewController *)presenting 
</span><span class='line'>                                                                      sourceController:(UIViewController *)source  
</span><span class='line'>{ 
</span><span class='line'>    return [[VTDAddPresentationTransition alloc] init]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end 
</span></code></pre></td></tr></table></div></figure>


<p>应用使用了自定义的视图控制器转场来呈现 add view controller。因为线框部件负责实施这个转场，所以它成为了 add view controller 转场的委托，并且返回适当的转场动画。</p>

<h5>利用 VIPER 组织应用组件</h5>

<p>iOS 应用的构架需要考虑到 UIKit 和 Cocoa Touch 是建立应用的主要工具。架构需要和应用的所有组件都能够和平相处，但又需要为如何使用框架的某些部分以及它们应该在什么位置提供一些指导和建议。</p>

<p>iOS 应用程序的主力是 UIViewController，我们不难想象找一个竞争者来取代 MVC 就可以避免大量使用视图控制器。但是视图控制器现在是这个平台的核心：它们处理设备方向的变化，回应用户的输入，和类似导航控制器之类的系统系统组件集成得很好，而现在在 iOS 7 中又能实现自定义屏幕之间的转换，功能实在是太强大了。</p>

<p>有了 VIPER，视图控制器便就能真正的做它本来应该做的事情了，那就是控制视图。 我们的待办事项应拥有两个视图控制器，一个是列表视图，另一个是新建待办。因为 add view controller 要做的所有事情就是控制视图，所以实现起来非常的简单基础：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDAddViewController 
</span><span class='line'> 
</span><span class='line'>- (void)viewDidAppear:(BOOL)animated  
</span><span class='line'>{ 
</span><span class='line'>    [super viewDidAppear:animated]; 
</span><span class='line'> 
</span><span class='line'>    UITapGestureRecognizer *gestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self 
</span><span class='line'>                                                                                        action:@selector(dismiss)]; 
</span><span class='line'>    [self.transitioningBackgroundView addGestureRecognizer:gestureRecognizer]; 
</span><span class='line'>    self.transitioningBackgroundView.userInteractionEnabled = YES; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)dismiss  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler cancelAddAction]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)setEntryName:(NSString *)name  
</span><span class='line'>{ 
</span><span class='line'>    self.nameTextField.text = name; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)setEntryDueDate:(NSDate *)date  
</span><span class='line'>{ 
</span><span class='line'>    [self.datePicker setDate:date]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (IBAction)save:(id)sender  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler saveAddActionWithName:self.nameTextField.text 
</span><span class='line'>                                     dueDate:self.datePicker.date]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (IBAction)cancel:(id)sender  
</span><span class='line'>{ 
</span><span class='line'>    [self.eventHandler cancelAddAction]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>#pragma mark - UITextFieldDelegate Methods 
</span><span class='line'> 
</span><span class='line'>- (BOOL)textFieldShouldReturn:(UITextField *)textField  
</span><span class='line'>{ 
</span><span class='line'>    [textField resignFirstResponder]; 
</span><span class='line'> 
</span><span class='line'>    return YES; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>应用在接入网络以后会变得更有用处，但是究竟该在什么时候联网呢？又由谁来负责启动网络连接呢？典型的情况下，由交互器来启动网络连接操作的项目，但是它不会直接处理网络代码。它会寻找一个像是 network manager 或者 API client 这样的依赖项。交互器可能聚合来自多个源的数据来提供所需的信息，从而完成一个用例。最终，就由展示器来采集交互器反馈的数据，然后组织并进行展示。</p>

<p>数据存储模块负责提供实体给交互器。因为交互器要完成业务逻辑，因此它需要从数据存储中获取实体并操纵它们，然后将更新后的实体再放回数据存储中。数据存储管理实体的持久化，而实体应该对数据库全然不知，正因如此，实体并不知道如何对自己进行持久化。</p>

<p>交互器同样不需要知道如何将实体持久化，有时交互器更希望使用一个 data manager 来使其与数据存储的交互变得容易。Data manager 可以处理更多的针对存储的操作，比如创建获取请求，构建查询等等。这就使交互器能够将更多的注意力放在应用逻辑上，而不必再了解实体是如何被聚集或持久化的。下面我们举一个例子来说明使用 data manager 有意义的，这个例子假设你在使用 Core Data。这是示例应用程序的 data manager 的接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface VTDListDataManager : NSObject 
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong) VTDCoreDataStore *dataStore; 
</span><span class='line'> 
</span><span class='line'>- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate *)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock; 
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>当使用 TDD 来开发一个交互器时，是可以用一个测试用的模拟存储来代替生产环境的数据存储的。避免与远程服务器通讯（网络服务）以及避免读取磁盘（数据库）可以加快你测试的速度并加强其可重复性。</p>

<p>将数据存储保持为一个界限清晰的特定层的原因之一是，这可以让你延迟选择一个特定的持久化技术。如果你的数据存储是一个独立的类，那你就可以使用一个基础的持久化策略来开始你的应用，然后等到有意义的时候升级至 SQLite 或者 Core Data。而因为数据存储层的存在，你的应用代码库中就不需要改变任何东西。</p>

<p>在 iOS 的项目中使用 Core Data 经常比构架本身还容易引起更多争议。然而，利用 VIPER 来使用 Core Data 将给你带来使用 Core Data 的前所未有的良好体验。在持久化数据的工具层面上，Core Data 可以保持快速存取和低内存占用方面，简直是个神器。但是有个很恼人的地方，它会像触须一样把 NSManagedObjectContext 延伸至你所有的应用实现文件中，特别是那些它们不该待的地方。VIPER 可以使 Core Data 待在正确的地方：数据存储层。</p>

<p>在待办事项示例中，应用仅有的两部分知道使用了 Core Data，其一是数据存储本身，它负责建立 Core Data 堆栈；另一个是 data manager。Data manager 执行了获取请求，将数据存储返回的 NSManagedObject 对象转换为标准的 PONSO 模型对象，并传输回业务逻辑层。这样一来，应用程序核心将不再依赖于 Core Data，附加得到的好处是，你也再也不用担心过期数据 (stale) 和没有良好组织的多线程 NSManagedObjects 来糟蹋你的工作成果了。</p>

<p>在通过请求访问 Core Data 存储时，data manager 中看起来是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation VTDListDataManager 
</span><span class='line'> 
</span><span class='line'>- (void)todoItemsBetweenStartDate:(NSDate *)startDate endDate:(NSDate*)endDate completionBlock:(void (^)(NSArray *todoItems))completionBlock 
</span><span class='line'>{ 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; 
</span><span class='line'> 
</span><span class='line'>    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"(date &gt;= %@) AND (date &lt;= %@)", [calendar dateForBeginningOfDay:startDate], [calendar dateForEndOfDay:endDate]]; 
</span><span class='line'>    NSArray *sortDescriptors = @[]; 
</span><span class='line'> 
</span><span class='line'>    __weak typeof(self) welf = self; 
</span><span class='line'>    [self.dataStore 
</span><span class='line'>     fetchEntriesWithPredicate:predicate 
</span><span class='line'>     sortDescriptors:sortDescriptors 
</span><span class='line'>     completionBlock:^(NSArray* entries) { 
</span><span class='line'>         if (completionBlock) 
</span><span class='line'>         { 
</span><span class='line'>             completionBlock([welf todoItemsFromDataStoreEntries:entries]); 
</span><span class='line'>         } 
</span><span class='line'>     }]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (NSArray*)todoItemsFromDataStoreEntries:(NSArray *)entries 
</span><span class='line'>{ 
</span><span class='line'>    return [entries arrayFromObjectsCollectedWithBlock:^id(VTDManagedTodoItem *todo) { 
</span><span class='line'>        return [VTDTodoItem todoItemWithDueDate:todo.date name:todo.name]; 
</span><span class='line'>    }]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>与 Core Data 一样极富争议的恐怕就是 UI 故事板了。故事板具有很多有用的功能，如果完全忽视它将会是一个错误。然而，调用故事版所能提供的所有功能来完成 VIPER 的所有目标仍然是很困难的。</p>

<p>我们所能做出的妥协就是选择不使用 segues 。有时候使用 segues 是有效的，但是使用 segues 的危险性在于它们很难原封不动地保持屏幕之间的分离，以及 UI 和应用逻辑之间的分离。一般来说，如果实现 prepareForSegue 方法是必须的话，我们就尽量不去使用 segues。</p>

<p>除此之外，故事板是一个实现用户界面布局有效方法，特别是在使用自动布局的时候。我们选择在实现待办事项两个界面的实例中使用故事板，并且使用这样的代码来执行自己的导航操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static NSString *ListViewControllerIdentifier = @"VTDListViewController"; 
</span><span class='line'> 
</span><span class='line'>@implementation VTDListWireframe 
</span><span class='line'> 
</span><span class='line'>- (void)presentListInterfaceFromWindow:(UIWindow *)window  
</span><span class='line'>{ 
</span><span class='line'>    VTDListViewController *listViewController = [self listViewControllerFromStoryboard]; 
</span><span class='line'>    listViewController.eventHandler = self.listPresenter; 
</span><span class='line'>    self.listPresenter.userInterface = listViewController; 
</span><span class='line'>    self.listViewController = listViewController; 
</span><span class='line'> 
</span><span class='line'>    [self.rootWireframe showRootViewController:listViewController 
</span><span class='line'>                                      inWindow:window]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (VTDListViewController *)listViewControllerFromStoryboard  
</span><span class='line'>{ 
</span><span class='line'>    UIStoryboard *storyboard = [self mainStoryboard]; 
</span><span class='line'>    VTDListViewController *viewController = [storyboard instantiateViewControllerWithIdentifier:ListViewControllerIdentifier]; 
</span><span class='line'>    return viewController; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (UIStoryboard *)mainStoryboard  
</span><span class='line'>{ 
</span><span class='line'>    UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"Main" 
</span><span class='line'>                                                         bundle:[NSBundle mainBundle]]; 
</span><span class='line'>    return storyboard; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<h5>使用 VIPER 构建模块</h5>

<p>一般在使用 VIPER 的时候，你会发现一个屏幕或一组屏幕倾向于聚在一起作为一个模块。模块可以以多种形式体现，但一般最好把它想成是一种特性。在播客应用中，一个模块可能是音频播放器或订阅浏览器。然而在我们的待办事项应用中，列表和添加事项的屏幕都将作为单独的模块被建立。</p>

<p>将你的应用作为一组模块来设计有很多好处，其中之一就是模块可以有非常明确和定义良好的接口，并且独立于其他的模块。这就使增加或者移除特性变得更加简单，也使在界面中向用户展示各种可变模块变得更加简单。</p>

<p>我们希望能将待办事项中各模块之间分隔更加明确，我们为添加模块定义了两个协议。一个是模块接口，它定义了模块可以做什么；另一个则是模块的代理，用来描述该模块做了什么。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VTDAddModuleInterface  
</span><span class='line'> 
</span><span class='line'>- (void)cancelAddAction; 
</span><span class='line'>- (void)saveAddActionWithName:(NSString *)name dueDate:(NSDate *)dueDate; 
</span><span class='line'> 
</span><span class='line'>@end 
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>@protocol VTDAddModuleDelegate  
</span><span class='line'> 
</span><span class='line'>- (void)addModuleDidCancelAddAction; 
</span><span class='line'>- (void)addModuleDidSaveAddAction; 
</span><span class='line'> 
</span><span class='line'>@end </span></code></pre></td></tr></table></div></figure>


<p>因为模块必须要被展示，才能对用户产生价值，所以模块的展示器通常需要实现模型的接口。当另一个模型想要展现当前模块时，它的展示器就需要实现模型的委托协议，这样它就能在展示时知道当前模块做了些什么。</p>

<p>一个模块可能包括实体，交互器和管理器的通用应用逻辑层，这些通常可用于多个屏幕。当然，这取决于这些屏幕之间的交互及它们的相似度。一个模块可以像在待办事项列表里面一样，简单的只代表一个屏幕。这样一来，应用逻辑层对于它的特定模块的行为来说就非常特有了。</p>

<p>模块同样是组织代码的简便途径。将模块所有的编码都放在它自己的文件夹中并在 Xcode 中建一个 group，这会在你需要寻找和改变更加容易。当你在要寻找一个类时，它恰到好处地就在你所期待的地方，这种感觉真是无法形容的棒。</p>

<p>利用 VIPER 建立模块的另一个好处是它使得扩展到多平台时变得更加简单。独立在交互器层中的所有用例的应用逻辑允许你可以专注于为平板，电话或者 Mac 构建新的用户界面，同时可以重用你的应用层。</p>

<p>进一步来说，iPad 应用的用户界面能够将部分 iPhone 应用的视图，视图控制器及展示器进行再利用。在这种情况下，iPad 屏幕将由 ‘super’ 展示器和线框来代表，这样可以利用 iPhone 使用过的展示器和线框来组成屏幕。建立进而维护一个跨多平台的应用是一个巨大的挑战，但是好的构架可以对整个模型和应用层的再利用有大幅度的提升，并使其实现起来更加容易。</p>

<h5>利用 VIPER 进行测试</h5>

<p>VIPER 的出现激发了一个关注点的分离，这使得采用 TDD 变得更加简便。交互器包含独立与任何 UI 的纯粹逻辑，这使测试驱动开发更加简单。同时展示器包含用来为显示准备数据的逻辑，并且它也独立于任何一个 UIKit 部件。对于这个逻辑的开发也很容易用测试来驱动。</p>

<p>我们更倾向于先从交互器下手。用户界面里所有部分都服务于用例，而通过采用 TDD 来测试驱动交互器的 API 可以让你对用户界面和用例之间的关系有一个更好的了解。</p>

<p>作为实例，我们来看一下负责待办事项列表的交互器。寻找待办事项的策略是要找出所有的将在下周末前截止的项目，并将这些项目分别归类至截止于今天，明天，本周或者下周。</p>

<p>我们编写的第一个测试是为了保证交互器能够找到所有的截止于下周末的待办事项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFindingUpcomingItemsRequestsAllToDoItemsFromTodayThroughEndOfNextWeek 
</span><span class='line'>{ 
</span><span class='line'>    [[self.dataManager expect] todoItemsBetweenStartDate:self.today endDate:self.endOfNextWeek completionBlock:OCMOCK_ANY]; 
</span><span class='line'>    [self.interactor findUpcomingItems]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>一旦知道了交互器找到了正确的待办事项后，我们就需要编写几个小测试用来确认它确实将待办事项分配到了正确的相对日期组内（比如说今天，明天，等等）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFindingUpcomingItemsWithOneItemDueTodayReturnsOneUpcomingItemsForToday 
</span><span class='line'>{ 
</span><span class='line'>    NSArray *todoItems = @[[VTDTodoItem todoItemWithDueDate:self.today name:@"Item 1"]]; 
</span><span class='line'>    [self dataStoreWillReturnToDoItems:todoItems]; 
</span><span class='line'> 
</span><span class='line'>    NSArray *upcomingItems = @[[VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:self.today title:@"Item 1"]]; 
</span><span class='line'>    [self expectUpcomingItems:upcomingItems]; 
</span><span class='line'> 
</span><span class='line'>    [self.interactor findUpcomingItems]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>既然我们已经知道了交互器的 API 长什么样，接下来就是开发展示器。一旦展示器接收到了交互器传来的待办事项，我们就需要测试看看我们是否适当的将数据进行格式化并且在用户界面中正确的显示它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFoundZeroUpcomingItemsDisplaysNoContentMessage 
</span><span class='line'>{ 
</span><span class='line'>    [[self.ui expect] showNoContentMessage]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[]]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)testFoundUpcomingItemForTodayDisplaysUpcomingDataWithNoDay 
</span><span class='line'>{ 
</span><span class='line'>    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Today" 
</span><span class='line'>                                                          sectionImageName:@"check" 
</span><span class='line'>                                                                 itemTitle:@"Get a haircut" 
</span><span class='line'>                                                                itemDueDay:@""]; 
</span><span class='line'>    [[self.ui expect] showUpcomingDisplayData:displayData]; 
</span><span class='line'> 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar gregorianCalendar]; 
</span><span class='line'>    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29]; 
</span><span class='line'>    VTDUpcomingItem *haircut = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationToday dueDate:dueDate title:@"Get a haircut"]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[haircut]]; 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>- (void)testFoundUpcomingItemForTomorrowDisplaysUpcomingDataWithDay 
</span><span class='line'>{ 
</span><span class='line'>    VTDUpcomingDisplayData *displayData = [self displayDataWithSectionName:@"Tomorrow" 
</span><span class='line'>                                                          sectionImageName:@"alarm" 
</span><span class='line'>                                                                 itemTitle:@"Buy groceries" 
</span><span class='line'>                                                                itemDueDay:@"Thursday"]; 
</span><span class='line'>    [[self.ui expect] showUpcomingDisplayData:displayData]; 
</span><span class='line'> 
</span><span class='line'>    NSCalendar *calendar = [NSCalendar gregorianCalendar]; 
</span><span class='line'>    NSDate *dueDate = [calendar dateWithYear:2014 month:5 day:29]; 
</span><span class='line'>    VTDUpcomingItem *groceries = [VTDUpcomingItem upcomingItemWithDateRelation:VTDNearTermDateRelationTomorrow dueDate:dueDate title:@"Buy groceries"]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter foundUpcomingItems:@[groceries]]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>同样需要测试的是应用是否在用户想要新建待办事项时正确启动了相应操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAddNewToDoItemActionPresentsAddToDoUI 
</span><span class='line'>{ 
</span><span class='line'>    [[self.wireframe expect] presentAddInterface]; 
</span><span class='line'> 
</span><span class='line'>    [self.presenter addNewEntry]; 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>这时我们可以开发视图功能了，并且在没有待办事项的时候我们想要展示一个特殊的信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testShowingNoContentMessageShowsNoContentView 
</span><span class='line'>{ 
</span><span class='line'>    [self.view showNoContentMessage]; 
</span><span class='line'> 
</span><span class='line'>    XCTAssertEqualObjects(self.view.view, self.view.noContentView, @"the no content view should be the view"); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>有待办事项出现时，我们要确保列表是显示出来的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testShowingUpcomingItemsShowsTableView 
</span><span class='line'>{ 
</span><span class='line'>    [self.view showUpcomingDisplayData:nil]; 
</span><span class='line'> 
</span><span class='line'>    XCTAssertEqualObjects(self.view.view, self.view.tableView, @"the table view should be the view"); 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>首先建立交互器是一种符合 TDD 的自然规律。如果你首先开发交互器，紧接着是展示器，你就可以首先建立一个位于这些层的套件测试，并且为实现这是实例奠定基础。由于你不需要为了测试它们而去与用户界面进行交互，所以这些类可以进行快速迭代。在你需要开发视图的时候，你会有一个可以工作并测试过的逻辑和表现层来与其进行连接。在快要完成对视图的开发时，你会发现第一次运行程序时所有部件都运行良好，因为你所有已通过的测试已经告诉你它可以工作。</p>

<h5>结论</h5>

<p>我们希望你喜欢这篇对 VIPER 的介绍。或许你们都很好奇接下来应该做什么，如果你希望通过 VIPER 来对你下一个应用进行设计，该从哪里开始呢？</p>

<p>我们竭尽全力使这篇文章和我们利用 VIPER 实现的应用实例足够明确并且进行了很好的定义。我们的待办事项里列表程序相当直接简单，但是它准确地解释了如何利用 VIPER 来建立一个应用。在实际的项目中，你可以根据你自己的挑战和约束条件来决定要如何实践这个例子。根据以往的经验，我们的每个项目在使用 VIPER 时都或多或少地改变了一些策略，但它们无一例外的都从中得益，找到了正确的方向。</p>

<p>很多情况下由于某些原因，你可能会想要偏离 VIPER 所指引的道路。可能你遇到了很多 &lsquo;bunny&rsquo; 对象，或者你的应用使用了故事板的 segues。没关系的，在这些情况下，你只需要在做决定时稍微考虑下 VIPER 所代表的精神就好。VIPER 的核心在于它是建立在单一责任原则上的架构。如果你碰到了些许麻烦，想想这些原则再考虑如何前进。</p>

<p>你一定想知道在现有的应用中能否只用 VIPER 。在这种情况下，你可以考虑使用 VIPER 构建新的特性。我们许多现有项目都使用了这个方法。你可以利用 VIPER 建立一个模块，这能帮助你发现许多建立在单一责任原则基础上造成难以运用架构的现有问题。</p>

<p>软件开发最伟大的事情之一就是每个应用程序都是不同的，而设计每个应用的架构的方式也是不同的。这就意味着每个应用对于我们来说都是一个学习和尝试的机遇，如果你决定开始使用 VIPER，你会受益匪浅。感谢你的阅读。</p>

<h5>Swift 补充</h5>

<p>苹果上周在 WWDC 介绍了一门称之为 Swift 的编程语言来作为 Cocoa 和 Cocoa Touch 开发的未来。现在发表关于 Swift 的完整意见还为时尚早，但众所周知编程语言对我们如何设计和构建应用有着重大影响。我们决定使用 Swift 重写我们的待办事项清单，帮助我们学习它对 VIPER 意味着什么。至今为止，收获颇丰。Swift 中的一些特性对于构建应用的体验有着显著的提升。</p>

<h5>结构体</h5>

<p>在 VIPER 中我们使用小型，轻量级的 model 类来在比如从展示器到视图这样不同的层间传递数据。这些 PONSOs 通常是只是简单地带有少量数据，并且通常这些类不会被继承。Swift 的结构体非常适合这个情况。下面的结构体的例子来自 VIPER Swift。这个结构体需要被判断是否相等，所以我们重载了 == 操作符来比较这个类型的两个实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct UpcomingDisplayItem : Equatable, Printable { 
</span><span class='line'>    let title : String = "" 
</span><span class='line'>    let dueDate : String = "" 
</span><span class='line'> 
</span><span class='line'>    var description : String { get { 
</span><span class='line'>        return "\(title) -- \(dueDate)" 
</span><span class='line'>    }} 
</span><span class='line'> 
</span><span class='line'>    init(title: String, dueDate: String) { 
</span><span class='line'>        self.title = title 
</span><span class='line'>        self.dueDate = dueDate 
</span><span class='line'>    } 
</span><span class='line'>} 
</span><span class='line'> 
</span><span class='line'>func == (leftSide: UpcomingDisplayItem, rightSide: UpcomingDisplayItem) -&gt; Bool { 
</span><span class='line'>    var hasEqualSections = false 
</span><span class='line'>    hasEqualSections = rightSide.title == leftSide.title 
</span><span class='line'> 
</span><span class='line'>    if hasEqualSections == false { 
</span><span class='line'>        return false 
</span><span class='line'>    } 
</span><span class='line'> 
</span><span class='line'>    hasEqualSections = rightSide.dueDate == rightSide.dueDate 
</span><span class='line'> 
</span><span class='line'>    return hasEqualSections 
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>类型安全</h5>

<p>也许 Objective-C 和 Swift 的最大区别是它们在对于类型处理上的不同。 Objective-C 是动态类型，而 Swift 故意在编译时做了严格的类型检查。对于一个类似 VIPER 的架构， 应用由不同层构成，类型安全是提升程序员效率和设计架构有非常大的好处。编译器帮助你确保正确类型的容器和对象在层的边界传递。如上所示，这是一个使用结构体的好地方。如果一个结构体的被设计为存在于两层之间，那么由于类型安全，你可以保证它将永远无法脱离这些层之间。</p>

<h5>扩展阅读</h5>

<p><a href="https://github.com/objcio/issue-13-viper">VIPER TODO, 文章示例</a></p>

<p><a href="https://github.com/objcio/issue-13-viper-swift">VIPER SWIFT, 基于 Swift 的文章示例</a></p>

<p><a href="https://github.com/mutualmobile/Counter">另一个计数器应用</a></p>

<p><a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">Mutual Mobile 关于 VIPER 的介绍</a></p>

<p><a href="http://blog.8thlight.com/uncle-bob/2011/11/22/Clean-Architecture.html">简明架构</a></p>

<p><a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a></p>

<p><a href="http://objccn.io/issue-1-3/">测试 View Controllers</a></p>

<p><a href="http://inessential.com/2014/03/16/smaller_please">Bunnies</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程操作：锁 互斥 同步]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/17/fourth-blog/"/>
    <updated>2014-09-17T19:03:45+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/17/fourth-blog</id>
    <content type="html"><![CDATA[<p>在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题，本文简单介绍：</p>

<h5>方法一，@synchronized(id anObject),(最简单的方法)</h5>

<p>会自动对参数对象加锁，保证临界区内的代码线程安全</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@synchronized(self)  
</span><span class='line'>{  
</span><span class='line'>     // 这段代码对其他 @synchronized(self) 都是互斥的         
</span><span class='line'>     // self 指向同一个对象  
</span><span class='line'>}   </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>方法二，NSLock</h5>

<p>NSLock对象实现了NSLocking protocol，包含几个方法：
lock，加锁
unlock，解锁
tryLock，尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO
lockBeforeDate:，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO
比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLock *theLock = [[NSLock alloc] init];   
</span><span class='line'>if ([thelock lock])   
</span><span class='line'>{  
</span><span class='line'>   //do something here  
</span><span class='line'>   [theLock unlock];   
</span><span class='line'>}   </span></code></pre></td></tr></table></div></figure>


<h5>方法三，NSRecursiveLock，递归锁</h5>

<p>NSRecursiveLock，多次调用不会阻塞已获取该锁的线程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];   
</span><span class='line'> void MyRecursiveFunction(int value)   
</span><span class='line'>{   
</span><span class='line'>  [theLock lock];   
</span><span class='line'>  if (value != 0)   
</span><span class='line'>  &lt;span style=“font-size:14px;”&gt; &lt;/span&gt;{   
</span><span class='line'>    –value;   
</span><span class='line'>    MyRecursiveFunction(value);   
</span><span class='line'> }  
</span><span class='line'>   [theLock unlock];   
</span><span class='line'>}   
</span><span class='line'> MyRecursiveFunction(5);  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>方法四，NSConditionLock，条件锁</h5>

<p>NSConditionLock，条件锁，可以设置条件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//公共部分  
</span><span class='line'>id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];       
</span><span class='line'> //线程一，生产者  
</span><span class='line'> while(true) {   
</span><span class='line'>        [condLock lockWhenCondition:NO_DATA];   
</span><span class='line'>        //生产数据  
</span><span class='line'>        [condLock unlockWithCondition:HAS_DATA];   
</span><span class='line'>}     
</span><span class='line'> //线程二，消费者  
</span><span class='line'> while (true) {   
</span><span class='line'>        [condLock lockWhenCondition:HAS_DATA];   
</span><span class='line'>        //消费  
</span><span class='line'>        [condLock unlockWithCondition:NO_DATA];   
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h5>方法五，NSDistributedLock，分布锁</h5>

<p>NSDistributedLock，分布锁，文件方式实现，可以跨进程
用tryLock方法获取锁。
用unlock方法释放锁。
如果一个获取锁的进程在释放锁之前挂了，那么锁就一直得不到释放了，此时可以通过breakLock强行获取锁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《抬起头吧》]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/17/third-blog/"/>
    <updated>2014-09-17T18:54:32+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/17/third-blog</id>
    <content type="html"><![CDATA[<h4>《Look up》-《抬起头吧》很有感触</h4>

<p>我有好几百位手机好友，但我仍然常常感到孤独；我每天跟他们聊天，但是好像他们并不了解真正的我。我的疑问来自于人与人之间的相处方式，我究竟是想看着他们的眼睛，还是手机上的昵称？直到有一天我发现，所谓的社交网络，并不完全是我们看到的那样。当我们打开电脑或者手机，其实也就关上了彼此心灵沟通的大门。</p>

<!--more-->


<p>假如有一天，你离开了网络，你就会发现，我们生活在一个令人困惑的世界中，一个我们本该主宰却被其掌控的世界，一个只顾自身利益、自身形象和自我推销的世界。在这个世界里，商人兜售着我们的个人信息。我们只会分享自己最好的一面，却不带任何真实感情。人生最快乐的事就是和别人共享生活的美好，但如果其他人都不在现场，我们还会一样快乐吗？</p>

<p>我们经常转发一些经过修饰和夸大的信息，只是为了得到别人的赞美。我们不停地刷新朋友圈。那些流行的文字和图片，让生活看起来似乎很精彩，好像就发生在你我身边，只是不知道是否有人真正用心去看。</p>

<p>远离网络吧，好好利用你的时间去看一本书，去陪一陪父母或者去旅行。活在当下，留心你身边的每一件事，把宝贵的时光放在真实和有意义的事情上，与亲朋好友在一起，和他们聊聊天说说话，不要再一直盯着你的手机和电脑。你需要的只是开始与人交谈。我无法忍受朋友聚餐的时候，每个人都在低头看手机。我们开始变得不合群，不再满足于和他人进行言语上的交流。</p>

<p>我们身边的孩子们，自从出生的那一刻开始，就看着我们活着像被操控的机器人。当我们还是个孩子时，我们不会和现在的孩子一样宅在家里，我们会与小伙伴们到户外尽情地去玩耍，即使鞋子穿破了，膝盖也受了伤，我们依然会尽情享受那些真正属于我们的欢乐时光。而现在，这一切变得少之又少，我们这代人都是只愿玩手机的低头一族。
抬起头吧，放下手机。看看你身边的人和事，让他们成为你今天的焦点，也让自己成为他们的焦点。我们需要真实的交谈。即使身在那里，改变已经发生。你不需要去告诉几百人你刚才做了些什么。</p>

<p>当你有了家庭，当你第一次抱起你的宝贝孩子，你想休息，他却让你整夜都无法入睡的时候，那是幸福和甜蜜的烦恼。当他长大成人并有了自己的家室，当有一天你抱起你的孙辈，他用稚嫩的声音叫你一声爷爷的时候，你会觉得时光飞逝人生苦短。当你回顾此生，你庆幸自己没有碌碌无为虚度光阴。</p>

<p>我们的生命有限，请不要将你的时光浪费在虚拟的网络上。</p>

<p>此刻，我们仍在不停地发送和接收无用的讯息。我们花上一整天的时间，却没有跟亲朋好友有任何真实的联系，没有什么比这更糟糕。别让你的生活追随浮华的网络。给人们你的爱，不要给他们你的赞，不要再为没有人关注而烦恼。
抬起头吧，放下手机。走出门去面对真实的世界，放下令你分心的一切。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试题-干货]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/17/second/"/>
    <updated>2014-09-17T17:29:15+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/17/second</id>
    <content type="html"><![CDATA[<p>很全的面试题，有百度腾讯各大公司的真题，快来看看吧。</p>

<h4>Part 1</h4>

<p>1、说说OC内存管理；</p>

<p>2、ASIRequest是什么；</p>

<p>3、怎么输出json字符串；</p>

<!--more-->


<p>4、说说http头部有哪些内容；</p>

<p>5、说说OC生命周期；
6、运用第三方框架，到时候出了问题，谁来负责</p>

<p>7、自己写一个strcpy函数</p>

<p>8、字母统计(如，输入字符串“aabbbccddddaaaaa”，输出“2a3b2c4d5a”)</p>

<p>9、你用过哪些框架</p>

<p>10、进程与线程的区别</p>

<p>11、开辟线程的方式有哪些</p>

<p>12、实现进程同步的方式有哪些，或者说你怎么实现进程同步</p>

<p>13、请你谈谈同步和异步，用操作系统知识解释一下。</p>

<p>14、请你谈谈多态</p>

<p>15、怎么将数据写入文件（归档，解当）</p>

<p>16、写一个set方法（retain和copy权限）</p>

<p>17、</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Int* fun()
</span><span class='line'>{
</span><span class='line'>   Int a=5;
</span><span class='line'>   Int * p=&a;
</span><span class='line'>   Return p;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>请问：在主函数里面调用fun函数，这样可以吗？如果不可以，请说明为什么，并给出一种解决方案。</p>

<p>18、在颜色中，有GB8888和 GB565标准，前者32位，其中R占8位，G占8位，B占8位，透明度占8位，后者16位，其中，R占5位，G占6位，B占5位。现在要将一个GB8888类型颜色转换成GB565类型，怎么转</p>

<p>19、判断一个数是否为素数</p>

<p>20、优化代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   1、int a=b*4;
</span><span class='line'>   2、int a=b/8;
</span><span class='line'>   3、int a=b%1;
</span><span class='line'>   4、int a=b%16;
</span><span class='line'>   5、int a=(b*3)/8;</span></code></pre></td></tr></table></div></figure>


<p> 21、什么是内联函数？</p>

<p>22、assign,retain,copy的区别</p>

<p>23、面向对象的特性</p>

<p>24、实现一个view从顶部移到底部的动画</p>

<p>25、#ff3344转换成uicolor</p>

<p>26、判断一个链表是否有循环</p>

<p>27、写一个代理类</p>

<p>28、进程之间是怎么通信的</p>

<p>29、oc有哪些优点和缺点</p>

<p>30、什么时候用delegate,什么时候用Notification?</p>

<p>31、写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。当你写下面的代码时会发生什么事？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>least = MIN(*p++, b);</span></code></pre></td></tr></table></div></figure>


<p>32、MVC模式的理解</p>

<p>33、堆和栈的区别</p>

<p>34、自动释放池是什么,如何工作</p>

<p>35、写一个委托的interface</p>

<p>36、objective-c的内存管理</p>

<p>37、什么是Notification？</p>

<p>38、下面的声明都是什么意思？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>constint a;
</span><span class='line'>intconst a;
</span><span class='line'>constint *a;
</span><span class='line'>int* const a;
</span><span class='line'>intconst * a const;</span></code></pre></td></tr></table></div></figure>


<h4>Part 2</h4>

<p><img src="http://nsobject.u.qiniudn.com/wp-content/uploads/2014/11/ssss.jpg" alt="id1" /></p>

<h4>Part 3</h4>

<p>这个是百度面试</p>

<p>Objective C runtime library：Objective C的对象模型，block的底层实现结构，消息发送，消息转发，这些都需要背后C一层的描述，内存管理。
Core Data：中多线程中处理大量数据同步时的操作。
Multithreading：什么时候处理多线程，几种方式，优缺点。
Delegate， Notification，KVO， other 优缺点
设计一个progress bar解决方案，追问到 Core Graphic、CGPath、maskLayer。
设计一个popup view被追问到 keyWindow、UIWindow的layer、UIView hierarchy。
从设计模式的角度分析Delegate、Notification、KVO的区别。被追问到自己写的library和开源的项目中用到哪些设计模式，为什么使用，有哪些好处和坏处，现在能否改进。
算是问题3的追问，设计一个方案来检测KVO的同步异步问题。willChange和 didChange的不同点，然后被追问到有没有其他地方也有类似情况，被追问到Core Data 中falut object。
这个是问题4的追问，设计一个KVO系统。
Multithreading，什么时候采用Multithreading方案，以及理由。追问到系统还有哪些在后台运行的thread，被追问到view life cycle、iOS6之后的不同以及内存管理。
Multithreading中常常遇到的问题，追问到死锁，优先级翻转，线程池等。
百度有一个亿级别的APP需要统计用户行为的日志系统。不使用数据库，只是使用普通文件，设计一个系统。被追问到内存映射文件。这个问题本来是服务器的问题，我表示从来没做过，回答很瞎。
算法考了2个。一个是如何求2个集合的交集。另一个是百亿数据中查找相同的数字以及出现的次数。</p>

<p>为什么做Windows Mobile
为什么改iOS
为什么来百度
为什么iPhone 可以成功，那些吸引你
如何看待AppStore 现在的生态圈</p>

<h4>Part 4</h4>

<p>下边是腾讯初级工程师面试题</p>

<p>1。简述push原理，push的证书和其它的右什么不一样？
2。viewcontroller的一些方法的说明viewDidLoad, viewWillDisappear, viewWillAppear方法的 顺序和 作用？
3。frame 和 bounds 的 区别 ，bound的大小改变frame 改变吗？
4。sqlite中插入特殊字符的方法和接收到处理方法。
5。谈谈你对数组和连表认识，还有你是怎么用他们的？
6。冒泡算法。
7。socket编程简述
8。asihttp代码原理 ，异步请求的原理，异步请求最大数目，为什么只能这么多？
9。http请求方式？
10。uiview的圆角属性设置方法。
（m_mainImgView.layer.cornerRadius = 6;
m_mainImgView.layer.masksToBounds = YES;）
11。 masksToBounds属性的作用。（决定子layer是否被当前layer的边界剪切。默认是NO。）</p>

<p>1Objective－C内部的实现
2CALayer和View的关系
3 http协议，tcp/ip
4 UITableView的那些元素是可以自定义的？
5 c语言的，定义变量，比如int，在什么情况下，其最大值是不同的
6 比较32位平台和64位平台不同
7 iphone app为什么会被打回来，如何避免??
8 为啥离开团队？
1.针对第一个问题，可以看看下面的教程</p>

<p>Object c研究的比较深入的教程</p>

<p><a href="http://www.cnblogs.com/yaski/">http://www.cnblogs.com/yaski/</a></p>

<p>第6章写的尤其好</p>

<p><a href="http://archive.cnblogs.com/a/1886332/">KVO/KVC 实现机理分析</a></p>

<p>2.CALayer和View的关系
一个UIView包含CALayer树，CALayer是一个数据模型，包含了一些用于显示的对象，但本身不用于显示。</p>

<p>CALayer相当于photoshop的一个层，很多动画可以通过设置CALayer来实现。据说有人用CALayer显示图片来播放视频。</p>

<p>Core animation应该是用CAlayer来实现各种动画。</p>

<h4>Part 5</h4>

<p>下面都是很基础的问题</p>

<h5>1、Object-C有多继承吗？没有的话用什么代替？cocoa 中所有的类都是NSObject 的子类</h5>

<p>多继承在这里是用protocol 委托代理 来实现的</p>

<p>你不用去考虑繁琐的多继承 ,虚基类的概念.</p>

<p>ood的多态特性 在 obj-c 中通过委托来实现.</p>

<h5>2、Object-C有私有方法吗？私有变量呢？</h5>

<p>objective-c – 类里面的方法只有两种, 静态方法和实例方法. 这似乎就不是完整的面向对象了,按照OO的原则就是一个对象只暴露有用的东西. 如果没有了私有方法的话, 对于一些小范围的代码重用就不那么顺手了. 在类里面声名一个私有方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Controller : NSObject { NSString *something; }
</span><span class='line'>+ (void)thisIsAStaticMethod;
</span><span class='line'>– (void)thisIsAnInstanceMethod;
</span><span class='line'>@end
</span><span class='line'>@interface Controller (private) -
</span><span class='line'>(void)thisIsAPrivateMethod;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>@private可以用来修饰私有变量</p>

<p>在Objective‐C中，所有实例变量默认都是私有的，所有实例方法默认都是公有的</p>

<h5>3、关键字const什么含义？</h5>

<p>const意味着”只读”，下面的声明都是什么意思？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const int a;
</span><span class='line'>int const a;
</span><span class='line'>const int *a;
</span><span class='line'>int * const a;
</span><span class='line'>int const * a const;</span></code></pre></td></tr></table></div></figure>


<p>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整 型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型 数是不可修改的，同时指针也是不可修改的）。</p>

<p>结论：</p>

<p>•; 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）</p>

<p>•; 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。</p>

<p>•; 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</p>

<p>欲阻止一个变量被改变，可以使用 const 关键字。在定义该 const 变量时，通常需要对它进行初</p>

<p>始化，因为以后就没有机会再去改变它了；</p>

<p>（2）对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指定为 const；</p>

<p>（3）在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</p>

<p>（4）对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；</p>

<p>（5）对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”。</p>

<h5>4、关键字volatile有什么含义？并给出三个不同例子？</h5>

<p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到</p>

<p>这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p>

<p>并行设备的硬件寄存器（如：状态寄存器）</p>

<p>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</p>

<p>多线程应用中被几个任务共享的变量</p>

<p>一个参数既可以是const还可以是volatile吗？解释为什么。</p>

<p>一个指针可以是volatile 吗？解释为什么。</p>

<p>下面是答案：</p>

<p>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p>

<p>是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</p>

<h5>5.static作用？</h5>

<p>函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次，</p>

<p>因此其值在下次调用时仍维持上次的值；</p>

<p>（2）在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；</p>

<p>（3）在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明</p>

<p>它的模块内；</p>

<p>（4）在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</p>

<p>（5）在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。</p>

<h5>6、#import和#include的区别，@class代表什么？</h5>

<p>@class一般用于头文件中需要声明该类的某个实例变量的时候用到，在m文件中还是需要使用#import</p>

<p>而#import比起#include的好处就是不会引起重复包含</p>

<h5>7、线程和进程的区别？</h5>

<p>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。</p>

<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一 个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程 序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>

<h5>8、堆和栈的区别？</h5>

<p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>

<p>申请大小：</p>

<p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因 此，能从栈获得的空间较小。</p>

<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>

<p>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</p>

<p>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>

<p>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</p>

<h5>9、Object-C的内存管理？</h5>

<p>1.当你使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当你不再使用该对象时,你要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.</p>

<p>2.当你通过任何其他方法获得一个对象时,则假设该对象的保留计数器值为1,而且已经被设置为自动释放,你不需要执行任何操作来确保该对象被清理.如果你打算在一段时间内拥有该对象,则需要保留它并确保在操作完成时释放它.</p>

<p>3.如果你保留了某个对象,你需要(最终)释放或自动释放该对象.必须保持retain方法和release方法的使用次数相等.</p>

<h5>10、为什么很多内置的类，如TableViewController的delegate的属性是assign不是retain？</h5>

<p>循环引用</p>

<p>所有的引用计数系统，都存在循环应用的问题。例如下面的引用关系：</p>

<p>对象a创建并引用到了对象b.</p>

<p>对象b创建并引用到了对象c.</p>

<p>对象c创建并引用到了对象b.</p>

<p>这时候b和c的引用计数分别是2和1。当a不再使用b，调用release释放对b的所有权，因为c还引用了b，所以b的引用计数为1，b不会被释放。b不释放，c的引用计数就是1，c也不会被释放。从此，b和c永远留在内存中。</p>

<p>这种情况，必须打断循环引用，通过其他规则来维护引用关系。比如，我们常见的delegate往往是assign方式的属性而不是retain方式的属 性，赋值不会增加引用计数，就是为了防止delegation两端产生不必要的循环引用。如果一个UITableViewController 对象a通 过retain获取了UITableView对象b的所有权，这个UITableView对象b的delegate又是a，如果这个delegate是 retain方式的，那基本上就没有机会释放这两个对象了。自己在设计使用delegate模式时，也要注意这点。</p>

<h5>11、定义属性时，什么情况使用copy、assign、retain？</h5>

<p>assign用于简单数据类型，如NSInteger,double,bool,</p>

<p>retain和copy用于对象，</p>

<p>copy用于当a指向一个对象，b也想指向同样的对象的时候，如果用assign，a如果释放，再调用b会crash,如果用copy 的方式，a和b各自有自己的内存，就可以解决这个问题。</p>

<p>retain 会使计数器加一，也可以解决assign的问题。</p>

<p>另外：atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。</p>

<p>加了atomic，setter函数会变成下面这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (property != newValue) {
</span><span class='line'>  [property release];
</span><span class='line'>  property = [newValue retain];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>12、对象是什么时候被release的？</h5>

<p>引用计数为0时。</p>

<p>autorelease实际上只是把对release的调用延迟了，对于每一个Autorelease，系统只是把该Object放入了当前的 Autorelease pool中，当该pool被释放时，该pool中的所有Object会被调用Release。对于每一个Runloop，系统会 隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个 Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object（就是autorelease的对 象）会被release。那什么是一个Runloop呢？一个UI事件，Timer call， delegate call， 都会是一个新的 Runloop</p>

<h5>13、iOS有没有垃圾回收？</h5>

<p>Objective-C 2.0也是有垃圾回收机制的，但是只能在Mac OS X Leopard 10.5 以上的版本使用。</p>

<h5>14、tableView的重用机制？</h5>

<p>查看UITableView头文件，会找到NSMutableArray<em>  visiableCells，和 NSMutableDictnery</em> reusableTableCells两个结构。visiableCells内保存当前显示的 cells，reusableTableCells保存可重用的cells。</p>

<p>TableView显示之初，reusableTableCells为空，那么 tableView dequeueReusableCellWithIdentifier:CellIdentifier返回nil。开始的cell都 是通过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] </span></code></pre></td></tr></table></div></figure>


<p>来创建，而且cellForRowAtIndexPath只是调用最大显示cell数的次数。</p>

<p>比如：有100条数据，iPhone一屏最多显示10个cell。程序最开始显示TableView的情况是：</p>

<p>1.用 [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 创建10次cell，并给cell指定同样的重用标识(当然，可以为不同显示类型的cell指定不同的标识)。并且10个cell全部都加入到 visiableCells数组，reusableTableCells为空。</p>

<p>2.向下拖动tableView，当cell1完全移出屏幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。 cell11加入到visiableCells，cell1移出visiableCells，cell1加入到reusableTableCells。</p>

<p>3.接着向下拖动tableView，因为reusableTableCells中已经有值，所以，当需要显示新的 cell，cellForRowAtIndexPath再次被调用的时 候，tableView dequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。 cell1加入到visiableCells，cell1移出reusableTableCells；cell2移出 visiableCells，cell2加入到reusableTableCells。之后再需要显示的Cell就可以正常重用了。</p>

<h5>15、ViewController 的loadView、viewDidLoad、viewDidUnload分别是什么时候调用的，在自定义ViewCointroller时在这几个函数中应该做什么工作？</h5>

<p>由init、loadView、viewDidLoad、viewDidUnload、dealloc的关系说起</p>

<p>init方法</p>

<p>在init方法中实例化必要的对象（遵从LazyLoad思想）</p>

<p>init方法中初始化ViewController本身</p>

<p>loadView方法</p>

<p>当view需要被展示而它却是nil时，viewController会调用该方法。不要直接调用该方法。</p>

<p>如果手工维护views，必须重载重写该方法</p>

<p>如果使用IB维护views，必须不能重载重写该方法</p>

<p>loadView和IB构建view</p>

<p>你在控制器中实现了loadView方法，那么你可能会在应用运行的某个时候被内存管理控制调用。 如果设备内存不足的时候， view 控制器会收到 didReceiveMemoryWarning的消息。 默认的实现是检查当前控制器的view是否在使用。如果它的view不在当前正在使用的 view hierarchy里面，且你的控制器实现了loadView方法，那么这个view将被release, loadView方法将被再次调用 来创建一个新的view。</p>

<p>viewDidLoad方法</p>

<p>viewDidLoad 此方法只有当view从nib文件初始化的时候才被调用。</p>

<p>重载重写该方法以进一步定制view</p>

<p>在iPhone OS 3.0及之后的版本中，还应该重载重写viewDidUnload来释放对view的任何索引</p>

<p>viewDidLoad后调用数据Model</p>

<p>viewDidUnload方法</p>

<p>当系统内存吃紧的时候会调用该方法（注：viewController没有被dealloc）</p>

<p>内存吃紧时，在iPhone OS 3.0之前didReceiveMemoryWarning是释放无用内存的唯一方式，但是OS 3.0及以后viewDidUnload方法是更好的方式</p>

<p>在该方法中将所有IBOutlet（无论是property还是实例变量）置为nil（系统release view时已经将其release掉了）</p>

<p>在该方法中释放其他与view有关的对象、其他在运行时创建（但非系统必须）的对象、在viewDidLoad中被创建的对象、缓存数据 等 release对象后，将对象置为nil（IBOutlet只需要将其置为nil，系统release view时已经将其release掉了）</p>

<p>一般认为viewDidUnload是viewDidLoad的镜像，因为当view被重新请求时，viewDidLoad还会重新被执行</p>

<p>viewDidUnload中被release的对象必须是很容易被重新创建的对象（比如在viewDidLoad或其他方法中创建的对象），不要release用户数据或其他很难被重新创建的对象</p>

<p>dealloc方法</p>

<p>viewDidUnload和dealloc方法没有关联，dealloc还是继续做它该做的事情</p>

<h5>16、ViewController的didReceiveMemoryWarning是在什么时候调用的？默认的操作是什么？</h5>

<p>当程序接到内存警告时View Controller将会收到这个消息：didReceiveMemoryWarning</p>

<p>从iOS3.0开始，不需要重载这个函数，把释放内存的代码放到viewDidUnload中去。</p>

<p>这个函数的默认实现是:检查controller是否可以安全地释放它的view(这里加粗的view指的是controller的view属性)，比如view本身没有superview并且可以被很容易地重建（从nib或者loadView函数）。</p>

<p>如果view可以被释放，那么这个函数释放view并调用viewDidUnload。</p>

<p>你可以重载这个函数来释放controller中使用的其他内存。但要记得调用这个函数的super实现来允许父类（一般是UIVIewController）释放view。</p>

<p>如果你的ViewController保存着view的子view的引用，那么，在早期的iOS版本中，你应该在这个函数中来释放这些引用。而在iOS3.0或更高版本中，你应该在viewDidUnload中释放这些引用。</p>

<h5>17、列举Cocoa中常见的集中多线程的实现，并谈谈多线程安全的几种解决办法，一般什么地方会用到多线程？</h5>

<p>NSThread,GCD等。尽量用上层分装好的方法去实现多线程而不是手动调用NSThread。</p>

<h5>18、怎么理解MVC，在Cocoa中MVC是怎么实现的？</h5>

<p>Model: 代表你的应用程序是什么（不是怎么展现）</p>

<p>Controller: 控制你的Model怎么展现给用户（UI逻辑）</p>

<p>View: Controller的奴隶。。。</p>

<p>1 Model，Controller，View相互通讯的规则：</p>

<p>Controller可以直接和Model通信</p>

<p>Controller也可以直接和View通信</p>

<p>Model和View永远不能直接通信</p>

<p>iOS中View和Controller的通信是透明和固定的，主要通过outlet和action实现</p>

<p>View使用Delegate接口和Controller同步信息</p>

<p>View不直接和数据通信，使用dataSource接口从Controller处获取数据</p>

<p>View的delegate和dataSource一般就是Controller</p>

<p>Controller负责为View翻译和格式化Model的数据</p>

<p>Model使用Notification &amp; KVO的方式分发数据更新信息，Controller可以有选择的监听自己感兴趣的信息。</p>

<p>View也可以监听广播信息，但一般不是Model发出的信息</p>

<p>一个完整的App就是很多MVC的集合</p>

<h5>19、delegate和notification区别，分别在什么情况下使用？</h5>

<p>Delegate:</p>

<p>消息的发送者(sender)告知接收者(receiver)某个事件将要发生，delegate同意然然后发送者响应事件，delegate机制使得接收者可以改变发送者的行为。通常发送者和接收者的关系是直接的一对多的关系。</p>

<p>Notification:</p>

<p>消息的发送者告知接收者事件已经发生或者将要发送，仅此而已，接收者并不能反过来影响发送者的行为。通常发送者和接收者的关系是间接的多对多关系。</p>

<ol>
<li><p>效率肯定是delegate比nsnotification高。</p></li>
<li><p>delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值，也就是delegate方法 的结果。比如-windowShouldClose:，需要关心返回的是yes还是no。所以delegate方法往往包含should这个很传神的词。 也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一步。相反 的，notification最大的特色就是不关心接受者的态度，我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。所以 notification往往用did这个词汇，比如NSWindowDidResizeNotification，那么nswindow对象放出这个 notification后就什么都不管了也不会等待接受者的反应。</p></li>
</ol>


<p>1）两个模块之间联系不是很紧密，就用notification传值，例如多线程之间传值用notificaiton。</p>

<p>2）delegate只是一种较为简单的回调，且主要用在一个模块中，例如底层功能完成了，需要把一些值传到上层去，就事先把上层的函数通过 delegate传到底层，然后在底层call这个delegate，它们都在一个模块中，完成一个功能，例如 说 NavgationController 从 B 界面到A 点返回按钮 (调用popViewController方法) 可以用delegate 比较好。</p>

<h5>20、self.跟self什么区别？</h5>

<h5>21、id、nil代表什么？</h5>

<p>id和void <em>并非完全一样。在上面的代码中，id是指向struct objc_object的一个指针，这个意思基本上是说，id是一个指向任何 一个继承了Object（或者NSObject）类的对象。需要注意的是id是一个指针，所以你在使用id的时候不需要加星号。比如id foo=nil 定义了一个nil指针，这个指针指向NSObject的一个任意子类。而id </em>foo=nil则定义了一个指针，这个指针指向另一个指针，被指向的这个 指针指向NSObject的一个子类。</p>

<p>nil和C语言的NULL相同，在objc/objc.h中定义。nil表示一个Objctive-C对象，这个对象的指针指向空（没有东西就是空）。</p>

<p>首字母大写的Nil和nil有一点不一样，Nil定义一个指向空的类（是Class，而不是对象）。</p>

<p>SEL是“selector”的一个类型，表示一个方法的名字</p>

<p>Method（我们常说的方法）表示一种类型，这种类型与selector和实现(implementation)相关</p>

<p>IMP定义为 id (*IMP) (id, SEL, …)。这样说来， IMP是一个指向函数的指针，这个被指向的函数包括id(“self”指针)，调用的SEL（方法名），再加上一些其他参数.说白了IMP就是实现方法。</p>

<h5>22、内存管理 Autorelease、retain、copy、assign的set方法和含义？</h5>

<p>1，你初始化(alloc/init)的对象，你需要释放(release)它。例如：</p>

<p>NSMutableArray aArray = [[NSArray alloc] init]; 后，需要 [aArray release];</p>

<p>2，你retain或copy的，你需要释放它。例如：</p>

<p>[aArray retain] 后，需要 [aArray release];</p>

<p>3，被传递(assign)的对象，你需要斟酌的retain和release。例如：</p>

<p>obj2 = [[obj1 someMethod] autorelease];</p>

<p>对象2接收对象1的一个自动释放的值，或传递一个基本数据类型(NSInteger，NSString)时：你或希望将对象2进行retain，以防止它在被使用之前就被自动释放掉。但是在retain后，一定要在适当的时候进行释放。</p>

<p>关于索引计数(Reference Counting)的问题</p>

<p>retain值 = 索引计数(Reference Counting)</p>

<p>NSArray对象会retain(retain值加一)任何数组中的对象。当NSArray被卸载(dealloc)的时候，所有数组中的对象会被 执行一次释放(retain值减一)。不仅仅是NSArray，任何收集类(Collection Classes)都执行类似操作。例如 NSDictionary，甚至UINavigationController。</p>

<p>Alloc/init建立的对象，索引计数为1。无需将其再次retain。</p>

<p>[NSArray array]和[NSDate date]等“方法”建立一个索引计数为1的对象，但是也是一个自动释放对象。所以是本地临时对象，那么无所谓了。如果是打算在全Class中使用的变量(iVar)，则必须retain它。</p>

<p>缺省的类方法返回值都被执行了“自动释放”方法。(*如上中的NSArray)</p>

<p>在类中的卸载方法“dealloc”中，release所有未被平衡的NS对象。(*所有未被autorelease，而retain值为1的)</p>

<h5>23、类别的作用？</h5>

<p>有时我们需要在一个已经定义好的类中增加一些方法，而不想去重写该类。比如，当工程已经很大，代码量比较多，或者类中已经包住很多方法，已经有其他代码调用了该类创建对象并使用该类的方法时，可以使用类别对该类扩充新的方法。</p>

<p>注意：类别只能扩充方法，而不能扩充成员变量。</p>

<h5>24、委托（举例）</h5>

<p>委托代理（degegate），顾名思义，把某个对象要做的事情委托给别的对象去做。那么别的对象就是这个对象的代理，代替它来打理要做的事。反映到程序中，首先要明确一个对象的委托方是哪个对象，委托所做的内容是什么。</p>

<p>委托机制是一种设计模式，在很多语言中都用到的，这只是个通用的思想，网上会有很多关于这方面的介绍。</p>

<p>那么在苹果开发过程中，用到委托的程序实现思想如下，我主要拿如何在视图之间传输信息做个例子。</p>

<p>譬如：在两个页面（UIIview视图对象）实现传值，用委托（delegate）可以很好做到！</p>

<p>方法：</p>

<p>类A</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface A：UIView
</span><span class='line'>id transparendValueDelegate;
</span><span class='line'>@property(nomatic, retain) id transparendValueDelegate;
</span><span class='line'>@end
</span><span class='line'>@implemtion A
</span><span class='line'>@synthesize transparendValueDelegate
</span><span class='line'>-(void)Function
</span><span class='line'>{
</span><span class='line'>  NSString* value = @”hello”;
</span><span class='line'>  //让代理对象执行transparendValue动作
</span><span class='line'>  [transparendValueDelegate transparendValue: value];
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>类B</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface B：UIView
</span><span class='line'>NSString* value;
</span><span class='line'>@end
</span><span class='line'>@implemtion B
</span><span class='line'>-(void)transparendValue:(NSString*)fromValue
</span><span class='line'>{
</span><span class='line'>  value = fromValue;
</span><span class='line'>  NSLog(@”the value is %@ “,value);
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>//下面的设置A代理委托对象为B</p>

<p>//在定义A和B类对象处：</p>

<p>A* a = [[A alloc] init];</p>

<p>B* b = [[B alloc] init];</p>

<ol type="a">
<li>transparendValueDelegate = b;//设置对象a代理为对象b</li>
</ol>


<p>这样在视图A和B之间可以通过委托来传值！</p>

<h5>25、retainCount？</h5>

<h5>26.属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用</h5>

<p>assign：指定setter方法用简单的赋值，这是默认操作。你可以对标量类型（如int）使用这个属性。你可以想象一个float，它不是一个对象，所以它不能retain、copy。</p>

<p>retain：指定retain应该在后面的对象上调用，前一个值发送一条release消息。你可以想象一个NSString实例，它是一个对象，而且你可能想要retain它。</p>

<p>copy：指定应该使用对象的副本（深度复制），前一个值发送一条release消息。基本上像retain，但是没有增加引用计数，是分配一块新的内存来放置它。</p>

<p>readonly：将只生成getter方法而不生成setter方法（getter方法没有get前缀）。</p>

<p>readwrite：默认属性，将生成不带额外参数的getter和setter方法（setter方法只有一个参数）。</p>

<p>atomic：对于对象的默认属性，就是setter/getter生成的方法是一个原子操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行setter全部语句之前，另一个线程开始执行setter的情况，相关于方法头尾加了锁一样。</p>

<p>nonatomic：不保证setter/getter的原子性，多线程情况下数据可能会有问题。</p>

<h5>27.类变量的@protected ,@private ,@public ,@package声明各有什么含义</h5>

<p>Objective-C 对存取权限的设定。也是变量的作用域。</p>

<p>protected 该类和所有的子类中的方法可以直接访问这样的变量，这是默认的。</p>

<p>private — 该类中的方法可以访问这样的变量，子类不可以。 public — 除了自己和子类中的方法外，也可以被其他类或者其他模块中的方法所访问。开放性最大。 package — 对于64位图像，这样的成员变量可以在实现这个类的图像中随意访问。</p>

<h5>28.浅拷贝和深拷贝区别是什么</h5>

<p>简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误</p>

<h5>29.Cocoa中与虚基类的概念么？怎么简洁的实现</h5>

<h5>30.NSString 和 NSMutableString 有什么区别</h5>

<p>NSString相当于一个const char* 不可以改变。</p>

<p>而 NSMutableString相当于 char* 可以改变内部的内容。</p>

<h5>31.自动释放池跟GC有什么区别？iPhone上有GC么？［pool release］ 和［pool drain］有什么区别</h5>

<p>”Autorelease Pools”(自动释放池)在应用中的使用技巧。</p>

<p>1，Autorelease Pools概要</p>

<p>一个”Autorelease Pool”实例中“包含”其它各种调用了”autorelease”方法的对象。当它释放时，其中所有被管理对象都会收 到”relrease”的消信。注意，同一个对象可以被多次调用”autorelease”方法，并可以放到同一个”Autorelease Pool” 中。引入这个自动释放池机制，对象的”autorelease”方法代替”relrease”方法可以延长它的生命周期，直接到当 前”Autorelrease Pool”释放。如果想让此对象的生命周期超过”Autorelease Pool”，还可以再次”retain”，呵 呵，有意思吧?且让我慢慢道来。</p>

<p>Cocoa总是认为当前至少有一个”Autorelease Pool”对象是可用的。若此对象并不存在，你调用的”autorelease”的所有对象都不会被自动释放掉，可想而知，造成内存泄露。Cocoa把这个错误信息写入日志??仅仅是为了以后分析。</p>

<p>你可以用”alloc”与”init”方法创建一个”NSAutoreleasePool”对象，并且可以调用”release”或”drain” （”release”与”drain”的区别是”drain”在有GC的环境中会引起GC回收操作，”release”反之。但在非GC环境中，两者相 同。官方的说法是为了程序的兼容性，应该考虑用”drain”代替”release”，）方法来回收它（调用它的”autorelease” 或”retain”方法会引起异常）。在一个完整的上下文最后”Autorelease Pool”对象应该被”release”掉（在方法内或一段循环 体内创建的”Autorelease Pool”对象）。</p>

<p>“Autorelease Pools”的所有实例在栈中管理（我们暂时叫他“自动释放池栈”），并且它们是可以被嵌套的（父生子，子生孙。。。子子孙 孙 ^_^）。例如，当我们创建一个”Autorelease Pool”对象后，它就被自动放到“自动释放池栈”的栈顶。当本池对象回收时，它就随之从 这个栈中POP掉。那么也就是说，当任何一个对象调用”autorelease”方法后，它会被放入当前线程中当前栈顶的自动释放池中。</p>

<p>接下来我们聊聊”Autorelease Pools”的嵌套问题。在你的应用中，你可以任意多的创建”Autorelease Pool”对象，而这些 对象被当前线程的“自动释放池栈”所管理。那么除了一个接一个的顺序创建并销毁它的情况外，还有一种使用方式，就是嵌套式的创建与使用。例如：在你的主函 数创建了一个”autorelease pool”，然后又调用了创建了”autorelease pool”实例的其它方法；或是在外循环中创建 了”Autorelease Pool”的实例，而内循环中也做了相同的事情。有意思吧，呵呵，嵌套的机制使父Pool实例释放后，它的所有子Pool也 将释放。但这里还存在一些副作用，后续文章会详细讨论。</p>

<p>“Application kit”在一个事件循环里会自动创建一个”autorelease pool”。像鼠标键的按下与释放，所以你编写的代码通常不需要考虑太多这方面的事情。当然，有以下三种情况你会创建与销毁自己的Pool实例：</p>

<p>1，应用不是基于”Application Kit”，像”Command-line tool”，因为它并没有内置的”autorelease pools”的支持。</p>

<p>2，创建线程，你必需在线程开始时创建一个”Autorelease Pool”实例。反之，会造成内存池露（会在以后的文章详细说明线程与池的技巧）。</p>

<p>3，一个循环内创建了太多的临时对象，你应该为他们创建一个”Autorelease Pool”对象，并在下次循还前销毁它们。</p>

<p>2，自动释放池中的”Non-AppKit”应用</p>

<p>在”Non-AppKit”应用中使用自动释放池的机制其实是相当简单的事情。你仅仅需要在main()起始处创建”Autorelease Pool” 对象，并在结尾处释放掉它。就像在Xcode的Foundation Tool的创建模版里写的一样。这个确保你在应用生命周期内至少有一 个”Autorelease Pool”是可用的。但是，这也使所有在此期间的所有”autorelease”的对象都必需在应用结束后才被释放。这也许 会引起在应用的使用中不断的增长，所以，你仍然考虑在不同的作用域创建新的”Autorelease Pool”。</p>

<p>大多应用中都存在各种级别的循环机制。在这些应用中，你可以在每个循环内的开头创建一个”Autorelease Pool”对象，并在结尾处释放掉它。</p>

<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void main()
</span><span class='line'>{
</span><span class='line'>  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
</span><span class='line'>  NSArray *args = [[NSProcessInfo processInfo] arguments];
</span><span class='line'>  unsigned count, limit = [args count];
</span><span class='line'>  for (count = 0; count &lt; limit; count++)
</span><span class='line'>  {
</span><span class='line'>  NSAutoreleasePool *loopPool = [[NSAutoreleasePool alloc] init];
</span><span class='line'>  NSString *fileContents;
</span><span class='line'>  NSString *fileName;
</span><span class='line'>  fileName = [args objectAtIndex:count];
</span><span class='line'>  fileContents = [[[NSString alloc] initWithContentsOfFile:fileName] autorelease];
</span><span class='line'>  // this is equivalent to using stringWithContentsOfFile:
</span><span class='line'>  [loopPool release];
</span><span class='line'>  }
</span><span class='line'>  [pool drain];
</span><span class='line'>  exit (EXIT_SUCCESS);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在命令行中处理所有以参数传来的文件。一次循环处理一个文件。在循环的开头创建一个”NSAutoreleasePool”对象，并在循环结束时释放掉。 因此，任何在其中创建并调用“autorelease”的对象都将添加到这个Pool实例中，当本池被释放后，这些对象也将被回收。注意，任何在作用域内 创建的”autoreleased”对象（像”fileName”），虽然并没有显示的调用”autorelease”方法，但都将被当前池所管理并释 放。</p>

<h5>32.C和obj-c 如何混用</h5>

<p>1）obj-c的编译器处理后缀为m的文件时，可以识别obj-c和c的代码，处理mm文件可以识别obj-c,c,c++代码，但cpp文件必须只能用c/c++代码，而且cpp文件include的头文件中，也不能出现obj-c的代码，因为cpp只是cpp</p>

<p>2)在mm文件中混用cpp直接使用即可，所以obj-c混cpp不是问题</p>

<p>3）在cpp中混用obj-c其实就是使用obj-c编写的模块是我们想要的。</p>

<p>如果模块以类实现，那么要按照cpp class的标准写类的定义，头文件中不能出现obj-c的东西，包括#import cocoa的。实现文件中，即类的实现代码中可以使用obj-c的东西，可以import,只是后缀是mm。</p>

<p>如果模块以函数实现，那么头文件要按c的格式声明函数，实现文件中，c++函数内部可以用obj-c，但后缀还是mm或m。</p>

<p>总结：只要cpp文件和cpp include的文件中不包含obj-c的东西就可以用了，cpp混用obj-c的关键是使用接口，而不能直接使用实现代 码，实际上cpp混用的是obj-c编译后的o文件，这个东西其实是无差别的，所以可以用。obj-c的编译器支持cpp</p>

<h5>33.响应者链是什么</h5>

<p>响应者链是Application Kit事件处理架构的中心机制。它由一系列链接在一起的响应者对象组成，事件或者动作消息可以沿着这些对象进行传 递。如图6-20显示的那样，如果一个响应者对象不能处理某个事件或动作－也就是说，它不响应那个消息，或者不认识那个事件，则将该消息重新发送给链中的 下一个响应者。消息沿着响应者链向上、向更高级别的对象传递，直到最终被处理（如果最终还是没有被处理，就会被抛弃）。</p>

<p>当Application Kit在应用程序中构造对象时，会为每个窗口建立响应者链。响应者链中的基本对象是NSWindow对象及其视图层次。在视图层次中级别较低的视图将比级别更高的视图优先获得处理事件或动作消息的机会。NSWindow中保有一个第一响应者的引用，它通常是当前窗口中处于选择状态的视图，窗口通常把响应消息的机会首先给它。对于事件消息，响应者链通常以发生事件的窗口对应的NSWindow对象作为结束，虽然其它对象也可以作为下一个响应者被加入到NSWindow对象的后面。</p>

<h5>34..UIscrollVew用到了什么设计模式？还能再foundation库中找到类似的吗？</h5>

<p>组合模式composition，所有的container view都用了这个模式</p>

<p>观察者模式observer，所有的UIResponder都用了这个模式。</p>

<p>模板(Template)模式，所有datasource和delegate接口都是模板模式的典型应用</p>

<h5>33. .timer的间隔周期准吗？为什么？怎样实现一个精准的timer?</h5>

<p>NSTimer可以精确到50-100毫秒.</p>

<p>NSTimer不是绝对准确的,而且中间耗时或阻塞错过下一个点,那么下一个点就pass过去了</p>

<p>此份面试题包含40个题目，是现在网上能搜索到的一个比较热的一份，但是答案并不是很详细和完整，基本答案来着cocoaChina，和一些自己的补充。</p>

<h5>34.Difference between shallow copy and deep copy?</h5>

<p>浅复制和深复制的区别？</p>

<p>答案：浅层复制：只复制指向对象的指针，而不复制引用对象本身。</p>

<p>深层复制：复制引用对象本身。</p>

<p>意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源</p>

<p>还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了</p>

<p>两份独立对象本身。</p>

<p>用网上一哥们通俗的话将就是：</p>

<p>浅复制好比你和你的影子，你完蛋，你的影子也完蛋</p>

<p>深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</p>

<h5>35.What is advantage of categories? What is difference between implementing a category and inheritance?</h5>

<p>类别的作用？继承和类别在实现中有何区别？</p>

<p>答案：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。</p>

<p>并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。</p>

<p>类别主要有3个作用：</p>

<p>(1)将类的实现分散到多个不同文件或多个不同框架中。</p>

<p>(2)创建对私有方法的前向引用。</p>

<p>(3)向对象添加非正式协议。</p>

<p>继承可以增加，修改或者删除方法，并且可以增加属性。</p>

<h5>36.Difference between categories and extensions?</h5>

<p>类别和类扩展的区别。</p>

<p>答案：category和extensions的不同在于后者可以添加属性。另外后者添加的方法是必须要实现的。</p>

<p>extensions可以认为是一个私有的Category。</p>

<h5>37.Difference between protocol in objective c and interfaces in java?</h5>

<p>oc中的协议和java中的接口概念有何不同？</p>

<p>答案：OC中的代理有2层含义，官方定义为 formal和informal protocol。前者和Java接口一样。</p>

<p>informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。</p>

<p>其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，也写在了学习教程里</p>

<p>“非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法，你可以使用他们更好的完成工作”。</p>

<p>这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明一个这样的类别去实现。然后你在后期可以直接使用这些更好的方法。</p>

<p>这么看，总觉得类别这玩意儿有点像协议的可选协议。”</p>

<p>现在来看，其实protocal已经开始对两者都统一和规范起来操作，因为资料中说“非正式协议使用interface修饰“，</p>

<p>现在我们看到协议中两个修饰词：“必须实现(@requied)”和“可选实现(@optional)”。</p>

<h5>38.What are KVO and KVC?</h5>

<p>答案：kvc:键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。</p>

<p>很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。</p>

<p>kvo:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。</p>

<p>具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。</p>

<p>比如我自定义的一个button</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];
</span><span class='line'>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
</span><span class='line'>{
</span><span class='line'>  if([keyPath isEqualToString:@"highlighted"] ) {
</span><span class='line'>  [self setNeedsDisplay];
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。</p>

<p>对于kvc机制如何通过key寻找到value：</p>

<p>“当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过几种不同的方式解析这个调用。首先 查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量（iVar），如果还没有找到，程序会继续 试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个 NSUndefinedKeyException异常错误。</p>

<p>(cocoachina.com注：Key-Value Coding查找方法的时候，不仅仅会查找someKey这个方法，还会查找 getsomeKey这个方法，前面加一个get，或者<em>someKey以及</em>getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找 someKey这个变量，也会查找_someKey这个变量是否存在。）</p>

<p>设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。“</p>

<p>来至cocoa，这个说法应该挺有道理。</p>

<p>因为我们知道button却是存在一个highlighted实例变量.因此为何上面我们只是add一个相关的keypath就行了，</p>

<p>可以按照kvc查找的逻辑理解，就说的过去了。</p>

<h5>39.What is purpose of delegates?</h5>

<p>代理的作用？</p>

<p>答案：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。</p>

<p>另外一点，代理可以理解为java中的回调监听机制的一种类似。</p>

<h5>40.What are mutable and immutable types in Objective C?</h5>

<p>oc中可修改和不可以修改类型。</p>

<p>答案：可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。</p>

<p>比如NSArray和NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。</p>

<h5>41.When we call objective c is runtime language what does it mean?</h5>

<p>我们说的oc是动态运行时语言是什么意思？</p>

<p>答案：多态。 主要是将数据类型的确定由编译时，推迟到了运行时。</p>

<p>这个问题其实浅涉及到两个概念，运行时和多态。</p>

<p>简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。</p>

<p>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat;</p>

<p>那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。</p>

<p>也就是不同的对象以自己的方式响应了相同的消息（响应了eat这个选择器）。</p>

<p>因此也可以说，运行时机制是多态的基础？~~~</p>

<h5>42.what is difference between NSNotification and protocol?</h5>

<p>通知和协议的不同之处？</p>

<p>答案：协议有控制链(has-a)的关系，通知没有。</p>

<p>首先我一开始也不太明白，什么叫控制链（专业术语了~）。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解</p>

<p>简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。</p>

<p>代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。</p>

<p>只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的</p>

<p>发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。</p>

<p>因此控制链（has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。</p>

<h5>43.What is push notification?</h5>

<p>什么是推送消息？</p>

<p>答案：太简单，不作答~~~~~~~~~~</p>

<p>这是cocoa上的答案。</p>

<p>其实到不是说太简单，只是太泛泛的一个概念的东西。就好比说，什么是人。</p>

<p>推送通知更是一种技术。</p>

<p>简单点就是客户端获取资源的一种手段。</p>

<p>普通情况下，都是客户端主动的pull。</p>

<p>推送则是服务器端主动push。</p>

<h5>44.Polymorphism？</h5>

<p>关于多态性</p>

<p>答案：多态，子类指针可以赋值给父类。</p>

<p>这个题目其实可以出到一切面向对象语言中，</p>

<p>因此关于多态，继承和封装基本最好都有个自我意识的理解，也并非一定要把书上资料上写的能背出来。</p>

<p>最重要的是转化成自我理解。</p>

<h5>45.Singleton?</h5>

<p>对于单例的理解</p>

<p>答案：11，12题目其实出的有点泛泛的感觉了，可能说是编程语言需要或是必备的基础。</p>

<p>基本能用熟悉的语言写出一个单例，以及可以运用到的场景或是你编程中碰到过运用的此种模式的框架类等。</p>

<p>进一步点，考虑下如何在多线程访问单例时的安全性。</p>

<h5>46.What is responder chain?</h5>

<p>说说响应链</p>

<p>答案： 事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播。</p>

<p>可以说点事件的分发，传递以及处理。具体可以去看下touch事件这块。因为问的太抽象化了</p>

<p>严重怀疑题目出到越后面就越笼统。</p>

<h5>47.Difference between frame and bounds?</h5>

<p>frame和bounds有什么不同？</p>

<p>答案:frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统）</p>

<p>bounds指的是：该view在本身坐标系统中 的位置和大小。（参照点是本身坐标系统）</p>

<h5>48.Difference between method and selector?</h5>

<p>方法和选择器有何不同？</p>

<p>答案：selector是一个方法的名字，method是一个组合体，包含了名字和实现.</p>

<p>详情可以看apple文档。</p>

<h5>49.Is there any garbage collection mechanism in Objective C.?</h5>

<p>OC的垃圾回收机制？</p>

<p>答案： OC2.0有Garbage collection，但是iOS平台不提供。</p>

<p>一般我们了解的objective-c对于内存管理都是手动操作的，但是也有自动释放池。</p>

<p>但是差了大部分资料，貌似不要和arc机制搞混就好了。</p>

<p>求更多~~</p>

<h5>50.NSOperation queue?</h5>

<p>答案：存放NSOperation的集合类。</p>

<p>操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。</p>

<p>网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。</p>

<p>这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，</p>

<p>但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。</p>

<p>但是转念一想其实可以参考银行的取票和叫号系统。</p>

<p>因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。</p>

<p>但是后来看到一票关于这操作队列话题的文章，其中有一句提到</p>

<p>“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”</p>

<p>瞬间觉得这个queue名字有点忽悠人了，还不如pool~</p>

<p>综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。</p>

<h5>51.What is lazy loading?</h5>

<p>答案：懒汉模式，只在用到的时候才去初始化。</p>

<p>也可以理解成延时加载。</p>

<p>我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。</p>

<p>一个延时载，避免内存过高，一个异步加载，避免线程堵塞。</p>

<h5>52.Can we use two tableview controllers on one viewcontroller?</h5>

<p>是否在一个视图控制器中嵌入两个tableview控制器？</p>

<p>答案：一个视图控制只提供了一个View视图，理论上一个tableViewController也不能放吧，</p>

<p>只能说可以嵌入一个tableview视图。当然，题目本身也有歧义，如果不是我们定性思维认为的UIViewController，</p>

<p>而是宏观的表示视图控制者，那我们倒是可以把其看成一个视图控制者，它可以控制多个视图控制器，比如TabbarController</p>

<p>那样的感觉。</p>

<h5>53.Can we use one tableview with two different datasources? How you will achieve this?</h5>

<p>一个tableView是否可以关联两个不同的数据源？你会怎么处理？</p>

<p>答案：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。</p>

<p>因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。</p>

<p>因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢？想让列表如何显示，不同的数据源分区块显示？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建博客操作]]></title>
    <link href="http://swplzj.github.io/blog/2014/09/17/firstblog/"/>
    <updated>2014-09-17T14:26:01+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/09/17/firstblog</id>
    <content type="html"><![CDATA[<p>终于搭建好自己的博客了，搭建过程中遇到好多问题，参考了好多文章，创建博客所用到的操作记录下来留作纪念。</p>

<p><a href="http://blog.segmentfault.com/yaashion_xiang/1190000000364677">搭建博客参考的文章</a></p>

<p><a href="https://github.com/imathis/octopress/wiki">官方参考文档</a></p>

<!--more-->


<h4>创建一篇博文</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post["post title"] #octopress 将在工作目录的 source/_post/目录下生成相应的 markdown 文件。然后可以使用 mou 工具去修改编辑内容。</span></code></pre></td></tr></table></div></figure>


<h4>生成预览</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview #可以通过 localhost:4000 在本机实时观察最新的编辑效果。</span></code></pre></td></tr></table></div></figure>


<h4>在线发布</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy #完成编辑后，可以将最新的内容部署到 github 上去。成功后，即可在线访问。</span></code></pre></td></tr></table></div></figure>


<h4>向 github 提交源文件更新</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add -A
</span><span class='line'>git commit -m :"提交内容"
</span><span class='line'>git push</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages
</span><span class='line'>生成静态站点：rake generate
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<h4>提交源文件，即source分支</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m 'your message'
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<h4>克隆主题</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd Octopress  
</span><span class='line'>git clone https://github.com/sevenadrian/foxslide .themes/foxslide  
</span><span class='line'>rake install['foxslide']  
</span><span class='line'>rake generate  
</span><span class='line'>rake deploy 
</span><span class='line'>cd octopress
</span><span class='line'>git submodule add GIT_URL .themes/THEME_NAME
</span><span class='line'>rake install['THEME_NAME']
</span><span class='line'>rake generate</span></code></pre></td></tr></table></div></figure>


<h4>拉取master分支</h4>

<p>进入_deploy目录，运行如下命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git pull origin master  </span></code></pre></td></tr></table></div></figure>


<h4>在开始处理博客事务之前，需要同步github仓库的数据</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd Octopress/  
</span><span class='line'>git pull origin source  
</span><span class='line'>cd _deploy  
</span><span class='line'>git commit --amend 
</span><span class='line'>git rebase.</span></code></pre></td></tr></table></div></figure>


<h5>因为你是从octopress github上clone的，所以你需要把origin这个branch换一个名字</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git remote rename origin octopress  
</span><span class='line'>git remote add origin (your github url)  </span></code></pre></td></tr></table></div></figure>


<h4>把你的github branch作为默认的branch</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config branch.master.remote origin  </span></code></pre></td></tr></table></div></figure>


<h4>把你的octopress导入到github上去</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git push -u origin master  </span></code></pre></td></tr></table></div></figure>


<h6>添加继续阅读</h6>

<p>需要在文章中写<!--more--></p>

<h6>Octopress添加回到顶部功能</h6>

<p><a href="http://www.tuicool.com/articles/qu6ZfiV">http://www.tuicool.com/articles/qu6ZfiV</a></p>

<h4>添加分页功能</h4>

<p><a href="http://www.tuicool.com/articles/mIVJ7j">http://www.tuicool.com/articles/mIVJ7j</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XCODE LLDB命令的简单实用说明]]></title>
    <link href="http://swplzj.github.io/blog/2014/07/21/geng-huan-zhu-ti%20copy/"/>
    <updated>2014-07-21T16:47:01+08:00</updated>
    <id>http://swplzj.github.io/blog/2014/07/21/geng-huan-zhu-ti copy</id>
    <content type="html"><![CDATA[<p>po（print object）是LLDB的一个命令，其主要功能是输出objective-c中对象（objects）的信息，与之相似的另外一个命令是 p（print），其主要功能是输出原生类型（boolean、integer、float、etc）的信息。</p>

<!--more-->


<p>可以在控制台输入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>po self.view 或者
</span><span class='line'>p self.view.subViews.count</span></code></pre></td></tr></table></div></figure>


<h4>技巧一：运行时修改变量的值</h4>

<p>你以前怎么验证是不是某个变量的值导致整段程序不能正常工作？修改代码中的变量的值，然后cmd+r重新启动app？现在你不需要这么做了，只需要设置一个断点，当程序在这进入调试模式后，使用expr命令即可在运行时修改变量的值。</p>

<p>假如有一个loginWithUsername:方法，需要两个参数：username，password。</p>

<p>首先设置好断点，如下图所示：</p>

<p><img src="http://static.oschina.net/uploads/space/2013/0320/230128_xFae_724414.png" title="设置断点" alt="id1" /></p>

<p>运行app，进入断点模式后，在（lldb）后输入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>expr username = @"username"
</span><span class='line'>expr password = @"badpassword"</span></code></pre></td></tr></table></div></figure>


<p>控制台会返回以下信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(NSString *) $0 = 0x3d3504c4 @"username"
</span><span class='line'>(NSString *) $1 = 0x1d18ef60 @"badpassword"</span></code></pre></td></tr></table></div></figure>


<p>现在跳出断点，执行断点之后的两条输出语句，控制台会有以下输出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(0x1c59aae0) A line for the breakpoint
</span><span class='line'>(0x1c59aae0) Username and Password after: username:badpassword</span></code></pre></td></tr></table></div></figure>


<p>看到看吧，我们在运行时修改了变量的值，事情还可以变的更简单一些，我们可以编辑断点，让它自动填充需要的修改的变量的值，并且可以选择在此断点处不进入断点模式，仅仅修改指定变量的值，然后自动执行后续代码。</p>

<p>右击断点选择“Edit Breakpoint…”（或者按住cmd+option，单击断点），然后如下图所示设置断点</p>

<p><img src="http://static.oschina.net/uploads/space/2013/0320/231442_eqyO_724414.png" title="编辑断点" alt="id2" /></p>

<p>注意选中了最后一行（“Automatically continue after evaluating”）的选择框，这就保证运行到这个断点的时，填充变量的值，然后继续运行，并不在此处断点进入调试模式。</p>

<p>运行app，你会得到和上述手动设置变量的值一样的输出。</p>

<p>接下来单击断点，使其处于禁用状态，现在箭头的颜色应该是浅蓝色的，重新运行app，你会发现username和password的值没有在运行时被改变了。</p>

<h4>技巧二：设置断点触发条件</h4>

<p>断点的另外一个重要作用，是可以设置触发断点生效的条件，这样我们就可以在运行时针对特定的数据进行分析，观察app是否运行在正确的轨道上。如下图：</p>

<p><img src="http://static.oschina.net/uploads/space/2013/0320/232822_rEBO_724414.png" title="触发条件" alt="id3" /></p>

<p>上述截图可以看到如下语句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(BOOL)[(NSString*)[item valueForKey:@"ID"] isEqualToString:@"93306"]</span></code></pre></td></tr></table></div></figure>


<p>通过这行语句，我们告诉编译器：当item中ID等于93306时，此断点生效，进入断点调试模式。</p>

<h4>技巧三：格式化输出数据</h4>

<p>如果你厌倦了代码里无穷无尽的NSLog，幸运的是我们可以在编辑断点使其输出格式化字符串就像平常编码时一样。不过有一点需要注意，平常编码时可能会使用NSString‘s stringWithFormat:输出格式化字符串，不过这个方法貌似在断点中木有效果，你需要使用alloc/init形式的方法，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>po [[NSString alloc] initWithFormat:@"Item index is: %d", index]</span></code></pre></td></tr></table></div></figure>


<p>运行app，就能在控制台看到想要的输出啦！</p>

<p>简单！强大！这就是LLDB给你的选择，从此代码里可以不用再有NSLog满天飞的情况了，代码变得更干净了，心情变得更愉悦了！</p>

<p>LLDB还有很多强大的地方，本教程只不过揭开了它的面纱，即便如此，仍让我们沉醉不已。</p>

<h4>另附命令合集</h4>

<p>apropos           — Find a list of debugger commands related to a particular
                        word/subject.</p>

<p>  breakpoint        — A set of commands for operating on breakpoints. Also see
                       _regexp-break.</p>

<p>  command           — A set of commands for managing or customizing the
                       debugger commands.</p>

<p>  disassemble       — Disassemble bytes in the current function, or elsewhere
                       in the executable program as specified by the user.</p>

<p>  expression        — Evaluate a C/ObjC/C++ expression in the current program
                       context, using user defined variables and variables
                       currently in scope.</p>

<p>  frame             — A set of commands for operating on the current thread’s
                       frames.</p>

<p>  gdb-remote        — Connect to a remote GDB server.  If no hostname is
                       provided, localhost is assumed.</p>

<p>  gui               — Switch into the curses based GUI mode.</p>

<p>  help              — Show a list of all debugger commands, or give details
                       about specific commands.</p>

<p>  kdp-remote        — Connect to a remote KDP server.  udp port 41139 is the
                       default port number.</p>

<p>  log               — A set of commands for operating on logs.</p>

<p>  memory            — A set of commands for operating on memory.</p>

<p>  platform          — A set of commands to manage and create platforms.</p>

<p>  plugin            — A set of commands for managing or customizing plugin
                       commands.</p>

<p>  process           — A set of commands for operating on a process.</p>

<p>  quit              — Quit out of the LLDB debugger.</p>

<p>  register          — A set of commands to access thread registers.</p>

<p>  script            — Pass an expression to the script interpreter for
                       evaluation and return the results. Drop into the
                       interactive interpreter if no expression is given.</p>

<p>  settings          — A set of commands for manipulating internal settable
                       debugger variables.</p>

<p>  source            — A set of commands for accessing source file information</p>

<p>  target            — A set of commands for operating on debugger targets.</p>

<p>  thread            — A set of commands for operating on one or more threads
                       within a running process.</p>

<p>  type              — A set of commands for operating on the type system</p>

<p>  version           — Show version of LLDB debugger.</p>

<p>  watchpoint        — A set of commands for operating on watchpoints.</p>

<p>Current command abbreviations (type ‘help command alias’ for more info):</p>

<p>  add-dsym  — (‘target symbols add’)  Add a debug symbol file to one of the
               target’s current modules by specifying a path to a debug symbols
               file, or using the options to specify a module to download
               symbols for.</p>

<p>  attach    — (‘_regexp-attach’)  Attach to a process id if in decimal,
               otherwise treat the argument as a process name to attach to.</p>

<p>  b         — (‘_regexp-break’)  Set a breakpoint using a regular expression
               to specify the location, where <linenum> is in decimal and
               <address> is in hex.</p>

<p>  bt        — (‘_regexp-bt’)  Show a backtrace.  An optional argument is
               accepted; if that argument is a number, it specifies the number
               of frames to display.  If that argument is ‘all’, full
               backtraces of all threads are displayed.</p>

<p>  c         — (‘process continue’)  Continue execution of all threads in the
               current process.</p>

<p>  call      — (‘expression –’)  Evaluate a C/ObjC/C++ expression in the
               current program context, using user defined variables and
               variables currently in scope.</p>

<p>  continue  — (‘process continue’)  Continue execution of all threads in the
               current process.</p>

<p>  detach    — (‘process detach’)  Detach from the current process being
               debugged.</p>

<p>  di        — (‘disassemble’)  Disassemble bytes in the current function, or
               elsewhere in the executable program as specified by the user.</p>

<p>  dis       — (‘disassemble’)  Disassemble bytes in the current function, or
               elsewhere in the executable program as specified by the user.</p>

<p>  display   — (‘_regexp-display’)  Add an expression evaluation stop-hook.</p>

<p>  down      — (‘_regexp-down’)  Go down “n” frames in the stack (1 frame by
               default).</p>

<p>  env       — (‘_regexp-env’)  Implements a shortcut to viewing and setting
               environment variables.</p>

<p>  exit      — (‘quit’)  Quit out of the LLDB debugger.</p>

<p>  f         — (‘frame select’)  Select a frame by index from within the
               current thread and make it the current frame.</p>

<p>  file      — (‘target create’)  Create a target using the argument as the
               main executable.</p>

<p>  finish    — (‘thread step-out’)  Finish executing the function of the
               currently selected frame and return to its call site in
               specified thread (current thread, if none specified).</p>

<p>  image     — (‘target modules’)  A set of commands for accessing information
               for one or more target modules.</p>

<p>  j         — (‘_regexp-jump’)  Sets the program counter to a new address.</p>

<p>  jump      — (‘_regexp-jump’)  Sets the program counter to a new address.</p>

<p>  kill      — (‘process kill’)  Terminate the current process being debugged.</p>

<p>  l         — (‘_regexp-list’)  Implements the GDB ‘list’ command in all of
               its forms except FILE:FUNCTION and maps them to the appropriate
               ‘source list’ commands.</p>

<p>  list      — (‘_regexp-list’)  Implements the GDB ‘list’ command in all of
               its forms except FILE:FUNCTION and maps them to the appropriate
               ‘source list’ commands.</p>

<p>  n         — (‘thread step-over’)  Source level single step in specified
               thread (current thread, if none specified), stepping over
               calls.</p>

<p>  next      — (‘thread step-over’)  Source level single step in specified
               thread (current thread, if none specified), stepping over
               calls.</p>

<p>  nexti     — (‘thread step-inst-over’)  Single step one instruction in
               specified thread (current thread, if none specified), stepping
               over calls.</p>

<p>  ni        — (‘thread step-inst-over’)  Single step one instruction in
               specified thread (current thread, if none specified), stepping
               over calls.</p>

<p>  p         — (‘expression –’)  Evaluate a C/ObjC/C++ expression in the
               current program context, using user defined variables and
               variables currently in scope.</p>

<p>  po        — (‘expression -O  — ‘)  Evaluate a C/ObjC/C++ expression in the
               current program context, using user defined variables and
               variables currently in scope.</p>

<p>  print     — (‘expression –’)  Evaluate a C/ObjC/C++ expression in the
               current program context, using user defined variables and
               variables currently in scope.</p>

<p>  q         — (‘quit’)  Quit out of the LLDB debugger.</p>

<p>  r         — (‘process launch -c /bin/sh –’)  Launch the executable in the
               debugger.</p>

<p>  rbreak    — (‘breakpoint set -r %1′)  Sets a breakpoint or set of
               breakpoints in the executable.</p>

<p>  repl      — (‘expression -r  — ‘)  Evaluate a C/ObjC/C++ expression in the
               current program context, using user defined variables and
               variables currently in scope.</p>

<p>  run       — (‘process launch -c /bin/sh –’)  Launch the executable in the
               debugger.</p>

<p>  s         — (‘thread step-in’)  Source level single step in specified thread=
               (current thread, if none specified).</p>

<p>  si        — (‘thread step-inst’)  Single step one instruction in specified
               thread (current thread, if none specified).</p>

<p>  step      — (‘thread step-in’)  Source level single step in specified thread
               (current thread, if none specified).</p>

<p>  stepi     — (‘thread step-inst’)  Single step one instruction in specified
               thread (current thread, if none specified).</p>

<p>  t         — (‘thread select’)  Select a thread as the currently active
               thread.</p>

<p>  tbreak    — (‘_regexp-tbreak’)  Set a one shot breakpoint using a regular
               expression to specify the location, where <linenum> is in
               decimal and <address> is in hex.</p>

<p>  undisplay — (‘_regexp-undisplay’)  Remove an expression evaluation
               stop-hook.</p>

<p>  up        — (‘_regexp-up’)  Go up “n” frames in the stack (1 frame by
               default).</p>

<p>  x         — (‘memory read’)  Read from the memory of the process being
               debug</p>
]]></content>
  </entry>
  
</feed>
